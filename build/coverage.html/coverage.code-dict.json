{"/home/travis/build/npmtest/node-npmtest-pomelo/test.js":"/* istanbul instrument in package npmtest_pomelo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-pomelo/lib.npmtest_pomelo.js":"/* istanbul instrument in package npmtest_pomelo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_pomelo = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_pomelo = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-pomelo/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-pomelo && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_pomelo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_pomelo\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_pomelo.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_pomelo.rollup.js'] =\n            local.assetsDict['/assets.npmtest_pomelo.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_pomelo.__dirname + '/lib.npmtest_pomelo.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/index.js":"module.exports = require('./lib/pomelo');","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/pomelo.js":"/*!\n * Pomelo\n * Copyright(c) 2012 xiechengchao <xiecc@163.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nvar fs = require('fs');\nvar path = require('path');\nvar application = require('./application');\nvar Package = require('../package');\n\n/**\n * Expose `createApplication()`.\n *\n * @module\n */\n\nvar Pomelo = module.exports = {};\n\n/**\n * Framework version.\n */\n\nPomelo.version = Package.version;\n\n/**\n * Event definitions that would be emitted by app.event\n */\nPomelo.events = require('./util/events');\n\n/**\n * auto loaded components\n */\nPomelo.components = {};\n\n/**\n * auto loaded filters\n */\nPomelo.filters = {};\n\n/**\n * auto loaded rpc filters\n */\nPomelo.rpcFilters = {};\n\n/**\n * connectors\n */\nPomelo.connectors = {};\nPomelo.connectors.__defineGetter__('sioconnector', load.bind(null, './connectors/sioconnector'));\nPomelo.connectors.__defineGetter__('hybridconnector', load.bind(null, './connectors/hybridconnector'));\nPomelo.connectors.__defineGetter__('udpconnector', load.bind(null, './connectors/udpconnector'));\nPomelo.connectors.__defineGetter__('mqttconnector', load.bind(null, './connectors/mqttconnector'));\n\n/**\n * pushSchedulers\n */\nPomelo.pushSchedulers = {};\nPomelo.pushSchedulers.__defineGetter__('direct', load.bind(null, './pushSchedulers/direct'));\nPomelo.pushSchedulers.__defineGetter__('buffer', load.bind(null, './pushSchedulers/buffer'));\n\nvar self = this;\n\n/**\n * Create an pomelo application.\n *\n * @return {Application}\n * @memberOf Pomelo\n * @api public\n */\nPomelo.createApp = function (opts) {\n  var app = application;\n  app.init(opts);\n  self.app = app;\n  return app;\n};\n\n/**\n * Get application\n */\nObject.defineProperty(Pomelo, 'app', {\n  get:function () {\n    return self.app;\n  }\n});\n\n/**\n * Auto-load bundled components with getters.\n */\nfs.readdirSync(__dirname + '/components').forEach(function (filename) {\n  if (!/\\.js$/.test(filename)) {\n    return;\n  }\n  var name = path.basename(filename, '.js');\n  var _load = load.bind(null, './components/', name);\n  \n  Pomelo.components.__defineGetter__(name, _load);\n  Pomelo.__defineGetter__(name, _load);\n});\n\nfs.readdirSync(__dirname + '/filters/handler').forEach(function (filename) {\n  if (!/\\.js$/.test(filename)) {\n    return;\n  }\n  var name = path.basename(filename, '.js');\n  var _load = load.bind(null, './filters/handler/', name);\n  \n  Pomelo.filters.__defineGetter__(name, _load);\n  Pomelo.__defineGetter__(name, _load);\n});\n\nfs.readdirSync(__dirname + '/filters/rpc').forEach(function (filename) {\n  if (!/\\.js$/.test(filename)) {\n    return;\n  }\n  var name = path.basename(filename, '.js');\n  var _load = load.bind(null, './filters/rpc/', name);\n  \n  Pomelo.rpcFilters.__defineGetter__(name, _load);\n});\n\nfunction load(path, name) {\n  if (name) {\n    return require(path + name);\n  }\n  return require(path);\n}\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/application.js":"/*!\n * Pomelo -- proto\n * Copyright(c) 2012 xiechengchao <xiecc@163.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nvar utils = require('./util/utils');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar EventEmitter = require('events').EventEmitter;\nvar events = require('./util/events');\nvar appUtil = require('./util/appUtil');\nvar Constants = require('./util/constants');\nvar appManager = require('./common/manager/appManager');\nvar fs = require('fs');\nvar path = require('path');\n\n/**\n * Application prototype.\n *\n * @module\n */\nvar Application = module.exports = {};\n\n/**\n * Application states\n */\nvar STATE_INITED  = 1;  // app has inited\nvar STATE_START = 2;  // app start\nvar STATE_STARTED = 3;  // app has started\nvar STATE_STOPED  = 4;  // app has stoped\n\n/**\n * Initialize the server.\n *\n *   - setup default configuration\n */\nApplication.init = function(opts) {\n  opts = opts || {};\n  this.loaded = [];       // loaded component list\n  this.components = {};   // name -> component map\n  this.settings = {};     // collection keep set/get\n  var base = opts.base || path.dirname(require.main.filename);\n  this.set(Constants.RESERVED.BASE, base, true);\n  this.event = new EventEmitter();  // event object to sub/pub events\n\n  // current server info\n  this.serverId = null;   // current server id\n  this.serverType = null; // current server type\n  this.curServer = null;  // current server info\n  this.startTime = null; // current server start time\n\n  // global server infos\n  this.master = null;         // master server info\n  this.servers = {};          // current global server info maps, id -> info\n  this.serverTypeMaps = {};   // current global type maps, type -> [info]\n  this.serverTypes = [];      // current global server type list\n  this.lifecycleCbs = {};     // current server custom lifecycle callbacks\n  this.clusterSeq = {};       // cluster id seqence\n\n  appUtil.defaultConfiguration(this);\n\n  this.state = STATE_INITED;\n  logger.info('application inited: %j', this.getServerId());\n};\n\n/**\n * Get application base path\n *\n *  // cwd: /home/game/\n *  pomelo start\n *  // app.getBase() -> /home/game\n *\n * @return {String} application base path\n *\n * @memberOf Application\n */\nApplication.getBase = function() {\n  return this.get(Constants.RESERVED.BASE);\n};\n\n/**\n * Override require method in application\n *\n * @param {String} relative path of file\n *\n * @memberOf Application\n */\nApplication.require = function(ph) {\n  return require(path.join(Application.getBase(), ph));\n};\n\n/**\n * Configure logger with {$base}/config/log4js.json\n * \n * @param {Object} logger pomelo-logger instance without configuration\n *\n * @memberOf Application\n */\nApplication.configureLogger = function(logger) {\n  if (process.env.POMELO_LOGGER !== 'off') {\n    var base = this.getBase();\n    var env = this.get(Constants.RESERVED.ENV);\n    var originPath = path.join(base, Constants.FILEPATH.LOG);\n    var presentPath = path.join(base, Constants.FILEPATH.CONFIG_DIR, env, path.basename(Constants.FILEPATH.LOG));\n    if(fs.existsSync(originPath)) {\n      logger.configure(originPath, {serverId: this.serverId, base: base});\n    } else if(fs.existsSync(presentPath)) {\n      logger.configure(presentPath, {serverId: this.serverId, base: base});\n    } else {\n      logger.error('logger file path configuration is error.');\n    }\n  }\n};\n\n/**\n * add a filter to before and after filter\n *\n * @param {Object} filter provide before and after filter method.\n *                        A filter should have two methods: before and after.\n * @memberOf Application\n */\nApplication.filter = function (filter) {\n  this.before(filter);\n  this.after(filter);\n};\n\n/**\n * Add before filter.\n *\n * @param {Object|Function} bf before fileter, bf(msg, session, next)\n * @memberOf Application\n */\nApplication.before = function (bf) {\n  addFilter(this, Constants.KEYWORDS.BEFORE_FILTER, bf);\n};\n\n/**\n * Add after filter.\n *\n * @param {Object|Function} af after filter, `af(err, msg, session, resp, next)`\n * @memberOf Application\n */\nApplication.after = function (af) {\n  addFilter(this, Constants.KEYWORDS.AFTER_FILTER, af);\n};\n\n/**\n * add a global filter to before and after global filter\n *\n * @param {Object} filter provide before and after filter method.\n *                        A filter should have two methods: before and after.\n * @memberOf Application\n */\nApplication.globalFilter = function (filter) {\n  this.globalBefore(filter);\n  this.globalAfter(filter);\n};\n\n/**\n * Add global before filter.\n *\n * @param {Object|Function} bf before fileter, bf(msg, session, next)\n * @memberOf Application\n */\nApplication.globalBefore = function (bf) {\n  addFilter(this, Constants.KEYWORDS.GLOBAL_BEFORE_FILTER, bf);\n};\n\n/**\n * Add global after filter.\n *\n * @param {Object|Function} af after filter, `af(err, msg, session, resp, next)`\n * @memberOf Application\n */\nApplication.globalAfter = function (af) {\n  addFilter(this, Constants.KEYWORDS.GLOBAL_AFTER_FILTER, af);\n};\n\n/**\n * Add rpc before filter.\n *\n * @param {Object|Function} bf before fileter, bf(serverId, msg, opts, next)\n * @memberOf Application\n */\nApplication.rpcBefore = function(bf) {\n  addFilter(this, Constants.KEYWORDS.RPC_BEFORE_FILTER, bf);\n};\n\n/**\n * Add rpc after filter.\n *\n * @param {Object|Function} af after filter, `af(serverId, msg, opts, next)`\n * @memberOf Application\n */\nApplication.rpcAfter = function(af) {\n  addFilter(this, Constants.KEYWORDS.RPC_AFTER_FILTER, af);\n};\n\n/**\n * add a rpc filter to before and after rpc filter\n *\n * @param {Object} filter provide before and after filter method.\n *                        A filter should have two methods: before and after.\n * @memberOf Application\n */\nApplication.rpcFilter = function(filter) {\n  this.rpcBefore(filter);\n  this.rpcAfter(filter);\n};\n\n/**\n * Load component\n *\n * @param  {String} name    (optional) name of the component\n * @param  {Object} component component instance or factory function of the component\n * @param  {[type]} opts    (optional) construct parameters for the factory function\n * @return {Object}     app instance for chain invoke\n * @memberOf Application\n */\nApplication.load = function(name, component, opts) {\n  if(typeof name !== 'string') {\n    opts = component;\n    component = name;\n    name = null;\n    if(typeof component.name === 'string') {\n      name = component.name;\n    }\n  }\n\n  if(typeof component === 'function') {\n    component = component(this, opts);\n  }\n\n  if(!name && typeof component.name === 'string') {\n    name = component.name;\n  }\n\n  if(name && this.components[name]) {\n    // ignore duplicat component\n    logger.warn('ignore duplicate component: %j', name);\n    return;\n  }\n\n  this.loaded.push(component);\n  if(name) {\n    // components with a name would get by name throught app.components later.\n    this.components[name] = component;\n  }\n\n  return this;\n};\n\n/**\n * Load Configure json file to settings.(support different enviroment directory & compatible for old path)\n *\n * @param {String} key environment key\n * @param {String} val environment value\n * @param {Boolean} reload whether reload after change default false\n * @return {Server|Mixed} for chaining, or the setting value\n * @memberOf Application\n */\nApplication.loadConfigBaseApp = function (key, val, reload) {\n  var self = this;\n  var env = this.get(Constants.RESERVED.ENV);\n  var originPath = path.join(Application.getBase(), val);\n  var presentPath = path.join(Application.getBase(), Constants.FILEPATH.CONFIG_DIR, env, path.basename(val));\n  var realPath;\n  if(fs.existsSync(originPath)) {\n     realPath = originPath;\n     var file = require(originPath);\n     if (file[env]) {\n       file = file[env];\n     }\n     this.set(key, file);\n  } else if(fs.existsSync(presentPath)) {\n    realPath = presentPath;\n    var pfile = require(presentPath);\n    this.set(key, pfile);\n  } else {\n    logger.error('invalid configuration with file path: %s', key);\n  }\n\n  if(!!realPath && !!reload) {\n    fs.watch(realPath, function (event, filename) {\n      if(event === 'change') {\n        delete require.cache[require.resolve(realPath)];\n        self.loadConfigBaseApp(key, val);\n      }\n    });\n  }\n};\n\n/**\n * Load Configure json file to settings.\n *\n * @param {String} key environment key\n * @param {String} val environment value\n * @return {Server|Mixed} for chaining, or the setting value\n * @memberOf Application\n */\nApplication.loadConfig = function(key, val) {\n  var env = this.get(Constants.RESERVED.ENV);\n  val = require(val);\n  if (val[env]) {\n    val = val[env];\n  }\n  this.set(key, val);\n};\n\n/**\n * Set the route function for the specified server type.\n *\n * Examples:\n *\n *  app.route('area', routeFunc);\n *\n *  var routeFunc = function(session, msg, app, cb) {\n *    // all request to area would be route to the first area server\n *    var areas = app.getServersByType('area');\n *    cb(null, areas[0].id);\n *  };\n *\n * @param  {String} serverType server type string\n * @param  {Function} routeFunc  route function. routeFunc(session, msg, app, cb)\n * @return {Object}     current application instance for chain invoking\n * @memberOf Application\n */\nApplication.route = function(serverType, routeFunc) {\n  var routes = this.get(Constants.KEYWORDS.ROUTE);\n  if(!routes) {\n    routes = {};\n    this.set(Constants.KEYWORDS.ROUTE, routes);\n  }\n  routes[serverType] = routeFunc;\n  return this;\n};\n\n/**\n * Set before stop function. It would perform before servers stop.\n *\n * @param  {Function} fun before close function\n * @return {Void}\n * @memberOf Application\n */\nApplication.beforeStopHook = function(fun) {\n  logger.warn('this method was deprecated in pomelo 0.8');\n  if(!!fun && typeof fun === 'function') {\n    this.set(Constants.KEYWORDS.BEFORE_STOP_HOOK, fun);\n  }\n};\n\n/**\n * Start application. It would load the default components and start all the loaded components.\n *\n * @param  {Function} cb callback function\n * @memberOf Application\n */\n Application.start = function(cb) {\n  this.startTime = Date.now();\n  if(this.state > STATE_INITED) {\n    utils.invokeCallback(cb, new Error('application has already start.'));\n    return;\n  }\n  \n  var self = this;\n  appUtil.startByType(self, function() {\n    appUtil.loadDefaultComponents(self);\n    var startUp = function() {\n      appUtil.optComponents(self.loaded, Constants.RESERVED.START, function(err) {\n        self.state = STATE_START;\n        if(err) {\n          utils.invokeCallback(cb, err);\n        } else {\n          logger.info('%j enter after start...', self.getServerId());\n          self.afterStart(cb);\n        }\n      });\n    };\n    var beforeFun = self.lifecycleCbs[Constants.LIFECYCLE.BEFORE_STARTUP];\n    if(!!beforeFun) {\n      beforeFun.call(null, self, startUp);\n    } else {\n      startUp();\n    }\n  });\n};\n\n/**\n * Lifecycle callback for after start.\n *\n * @param  {Function} cb callback function\n * @return {Void}\n */\nApplication.afterStart = function(cb) {\n  if(this.state !== STATE_START) {\n    utils.invokeCallback(cb, new Error('application is not running now.'));\n    return;\n  }\n\n  var afterFun = this.lifecycleCbs[Constants.LIFECYCLE.AFTER_STARTUP];\n  var self = this;\n  appUtil.optComponents(this.loaded, Constants.RESERVED.AFTER_START, function(err) {\n    self.state = STATE_STARTED;\n    var id = self.getServerId();\n    if(!err) {\n      logger.info('%j finish start', id);\n    }\n    if(!!afterFun) {\n      afterFun.call(null, self, function() {\n        utils.invokeCallback(cb, err);\n      });\n    } else {\n      utils.invokeCallback(cb, err);\n    }\n    var usedTime = Date.now() - self.startTime;\n    logger.info('%j startup in %s ms', id, usedTime);\n    self.event.emit(events.START_SERVER, id);\n  });\n};\n\n/**\n * Stop components.\n *\n * @param  {Boolean} force whether stop the app immediately\n */\nApplication.stop = function(force) {\n  if(this.state > STATE_STARTED) {\n    logger.warn('[pomelo application] application is not running now.');\n    return;\n  }\n  this.state = STATE_STOPED;\n  var self = this;\n\n  this.stopTimer = setTimeout(function() {\n    process.exit(0);\n  }, Constants.TIME.TIME_WAIT_STOP);\n\n  var cancelShutDownTimer =function(){\n      if(!!self.stopTimer) {\n        clearTimeout(self.stopTimer);\n      }\n  };\n  var shutDown = function() {\n    appUtil.stopComps(self.loaded, 0, force, function() {\n      cancelShutDownTimer();\n      if(force) {\n        process.exit(0);\n      }\n    });\n  };\n  var fun = this.get(Constants.KEYWORDS.BEFORE_STOP_HOOK);\n  var stopFun = this.lifecycleCbs[Constants.LIFECYCLE.BEFORE_SHUTDOWN];\n  if(!!stopFun) {\n    stopFun.call(null, this, shutDown, cancelShutDownTimer);\n  } else if(!!fun) {\n    utils.invokeCallback(fun, self, shutDown, cancelShutDownTimer);\n  } else {\n    shutDown();\n  }\n};\n\n/**\n * Assign `setting` to `val`, or return `setting`'s value.\n *\n * Example:\n *\n *  app.set('key1', 'value1');\n *  app.get('key1');  // 'value1'\n *  app.key1;         // undefined\n *\n *  app.set('key2', 'value2', true);\n *  app.get('key2');  // 'value2'\n *  app.key2;         // 'value2'\n *\n * @param {String} setting the setting of application\n * @param {String} val the setting's value\n * @param {Boolean} attach whether attach the settings to application\n * @return {Server|Mixed} for chaining, or the setting value\n * @memberOf Application\n */\nApplication.set = function (setting, val, attach) {\n  if (arguments.length === 1) {\n    return this.settings[setting];\n  }\n  this.settings[setting] = val;\n  if(attach) {\n    this[setting] = val;\n  }\n  return this;\n};\n\n/**\n * Get property from setting\n *\n * @param {String} setting application setting\n * @return {String} val\n * @memberOf Application\n */\nApplication.get = function (setting) {\n  return this.settings[setting];\n};\n\n/**\n * Check if `setting` is enabled.\n *\n * @param {String} setting application setting\n * @return {Boolean}\n * @memberOf Application\n */\nApplication.enabled = function (setting) {\n  return !!this.get(setting);\n};\n\n/**\n * Check if `setting` is disabled.\n *\n * @param {String} setting application setting\n * @return {Boolean}\n * @memberOf Application\n */\nApplication.disabled = function (setting) {\n  return !this.get(setting);\n};\n\n/**\n * Enable `setting`.\n *\n * @param {String} setting application setting\n * @return {app} for chaining\n * @memberOf Application\n */\nApplication.enable = function (setting) {\n  return this.set(setting, true);\n};\n\n/**\n * Disable `setting`.\n *\n * @param {String} setting application setting\n * @return {app} for chaining\n * @memberOf Application\n */\nApplication.disable = function (setting) {\n  return this.set(setting, false);\n};\n\n/**\n * Configure callback for the specified env and server type.\n * When no env is specified that callback will\n * be invoked for all environments and when no type is specified\n * that callback will be invoked for all server types.\n *\n * Examples:\n *\n *  app.configure(function(){\n *    // executed for all envs and server types\n *  });\n *\n *  app.configure('development', function(){\n *    // executed development env\n *  });\n *\n *  app.configure('development', 'connector', function(){\n *    // executed for development env and connector server type\n *  });\n *\n * @param {String} env application environment\n * @param {Function} fn callback function\n * @param {String} type server type\n * @return {Application} for chaining\n * @memberOf Application\n */\nApplication.configure = function (env, type, fn) {\n  var args = [].slice.call(arguments);\n  fn = args.pop();\n  env = type = Constants.RESERVED.ALL;\n\n  if(args.length > 0) {\n    env = args[0];\n  }\n  if(args.length > 1) {\n    type = args[1];\n  }\n\n  if (env === Constants.RESERVED.ALL || contains(this.settings.env, env)) {\n    if (type === Constants.RESERVED.ALL || contains(this.settings.serverType, type)) {\n      fn.call(this);\n    }\n  }\n  return this;\n};\n\n/**\n * Register admin modules. Admin modules is the extends point of the monitor system.\n *\n * @param {String} module (optional) module id or provoided by module.moduleId\n * @param {Object} module module object or factory function for module\n * @param {Object} opts construct parameter for module\n * @memberOf Application\n */\nApplication.registerAdmin = function(moduleId, module, opts) {\n  var modules = this.get(Constants.KEYWORDS.MODULE);\n  if(!modules) {\n    modules = {};\n    this.set(Constants.KEYWORDS.MODULE, modules);\n  }\n\n  if(typeof moduleId !== 'string') {\n    opts = module;\n    module = moduleId;\n    if(module) {\n      moduleId = module.moduleId;\n    }\n  }\n\n  if(!moduleId){\n    return;\n  }\n\n  modules[moduleId] = {\n    moduleId: moduleId,\n    module: module,\n    opts: opts\n  };\n};\n\n/**\n * Use plugin.\n *\n * @param  {Object} plugin plugin instance\n * @param  {[type]} opts    (optional) construct parameters for the factory function\n * @memberOf Application\n */\nApplication.use = function(plugin, opts) {\n  if(!plugin.components) {\n    logger.error('invalid components, no components exist');\n    return;\n  }\n\n  var self = this;\n  opts = opts || {};\n  var dir = path.dirname(plugin.components);\n\n  if(!fs.existsSync(plugin.components)) {\n    logger.error('fail to find components, find path: %s', plugin.components);\n    return;\n  }\n\n  fs.readdirSync(plugin.components).forEach(function (filename) {\n    if (!/\\.js$/.test(filename)) {\n      return;\n    }\n    var name = path.basename(filename, '.js');\n    var param = opts[name] || {};\n    var absolutePath = path.join(dir, Constants.DIR.COMPONENT, filename);\n    if(!fs.existsSync(absolutePath)) {\n      logger.error('component %s not exist at %s', name, absolutePath);\n    } else {\n      self.load(require(absolutePath), param);\n    }\n  });\n\n  // load events\n  if(!plugin.events) {\n    return;\n  } else {\n    if(!fs.existsSync(plugin.events)) {\n      logger.error('fail to find events, find path: %s', plugin.events);\n      return;\n    }\n\n    fs.readdirSync(plugin.events).forEach(function (filename) {\n      if (!/\\.js$/.test(filename)) {\n        return;\n      }\n      var absolutePath = path.join(dir, Constants.DIR.EVENT, filename);\n      if(!fs.existsSync(absolutePath)) {\n        logger.error('events %s not exist at %s', filename, absolutePath);\n      } else {\n        bindEvents(require(absolutePath), self);\n      }\n    });\n  }\n};\n\n/**\n * Application transaction. Transcation includes conditions and handlers, if conditions are satisfied, handlers would be executed.\n * And you can set retry times to execute handlers. The transaction log is in file logs/transaction.log.\n *\n * @param {String} name transaction name\n * @param {Object} conditions functions which are called before transaction\n * @param {Object} handlers functions which are called during transaction\n * @param {Number} retry retry times to execute handlers if conditions are successfully executed\n * @memberOf Application\n */\nApplication.transaction = function(name, conditions, handlers, retry) {\n  appManager.transaction(name, conditions, handlers, retry);\n};\n\n/**\n * Get master server info.\n *\n * @return {Object} master server info, {id, host, port}\n * @memberOf Application\n */\nApplication.getMaster = function() {\n  return this.master;\n};\n\n/**\n * Get current server info.\n *\n * @return {Object} current server info, {id, serverType, host, port}\n * @memberOf Application\n */\nApplication.getCurServer = function() {\n  return this.curServer;\n};\n\n/**\n * Get current server id.\n *\n * @return {String|Number} current server id from servers.json\n * @memberOf Application\n */\nApplication.getServerId = function() {\n  return this.serverId;\n};\n\n/**\n * Get current server type.\n *\n * @return {String|Number} current server type from servers.json\n * @memberOf Application\n */\nApplication.getServerType = function() {\n  return this.serverType;\n};\n\n/**\n * Get all the current server infos.\n *\n * @return {Object} server info map, key: server id, value: server info\n * @memberOf Application\n */\nApplication.getServers = function() {\n  return this.servers;\n};\n\n/**\n * Get all server infos from servers.json.\n *\n * @return {Object} server info map, key: server id, value: server info\n * @memberOf Application\n */\nApplication.getServersFromConfig = function() {\n  return this.get(Constants.KEYWORDS.SERVER_MAP);\n};\n\n/**\n * Get all the server type.\n *\n * @return {Array} server type list\n * @memberOf Application\n */\nApplication.getServerTypes = function() {\n  return this.serverTypes;\n};\n\n/**\n * Get server info by server id from current server cluster.\n *\n * @param  {String} serverId server id\n * @return {Object} server info or undefined\n * @memberOf Application\n */\nApplication.getServerById = function(serverId) {\n  return this.servers[serverId];\n};\n\n/**\n * Get server info by server id from servers.json.\n *\n * @param  {String} serverId server id\n * @return {Object} server info or undefined\n * @memberOf Application\n */\n\nApplication.getServerFromConfig = function(serverId) {\n  return this.get(Constants.KEYWORDS.SERVER_MAP)[serverId];\n};\n\n/**\n * Get server infos by server type.\n *\n * @param  {String} serverType server type\n * @return {Array}      server info list\n * @memberOf Application\n */\nApplication.getServersByType = function(serverType) {\n  return this.serverTypeMaps[serverType];\n};\n\n/**\n * Check the server whether is a frontend server\n *\n * @param  {server}  server server info. it would check current server\n *            if server not specified\n * @return {Boolean}\n *\n * @memberOf Application\n */\nApplication.isFrontend = function(server) {\n  server = server || this.getCurServer();\n  return !!server && server.frontend === 'true';\n};\n\n/**\n * Check the server whether is a backend server\n *\n * @param  {server}  server server info. it would check current server\n *            if server not specified\n * @return {Boolean}\n * @memberOf Application\n */\nApplication.isBackend = function(server) {\n  server = server || this.getCurServer();\n  return !!server && !server.frontend;\n};\n\n/**\n * Check whether current server is a master server\n *\n * @return {Boolean}\n * @memberOf Application\n */\nApplication.isMaster = function() {\n  return this.serverType === Constants.RESERVED.MASTER;\n};\n\n/**\n * Add new server info to current application in runtime.\n *\n * @param {Array} servers new server info list\n * @memberOf Application\n */\nApplication.addServers = function(servers) {\n  if(!servers || !servers.length) {\n    return;\n  }\n\n  var item, slist;\n  for(var i=0, l=servers.length; i<l; i++) {\n    item = servers[i];\n    // update global server map\n    this.servers[item.id] = item;\n\n    // update global server type map\n    slist = this.serverTypeMaps[item.serverType];\n    if(!slist) {\n      this.serverTypeMaps[item.serverType] = slist = [];\n    }\n    replaceServer(slist, item);\n\n    // update global server type list\n    if(this.serverTypes.indexOf(item.serverType) < 0) {\n      this.serverTypes.push(item.serverType);\n    }\n  }\n  this.event.emit(events.ADD_SERVERS, servers);\n};\n\n/**\n * Remove server info from current application at runtime.\n *\n * @param  {Array} ids server id list\n * @memberOf Application\n */\nApplication.removeServers = function(ids) {\n  if(!ids || !ids.length) {\n    return;\n  }\n\n  var id, item, slist;\n  for(var i=0, l=ids.length; i<l; i++) {\n    id = ids[i];\n    item = this.servers[id];\n    if(!item) {\n      continue;\n    }\n    // clean global server map\n    delete this.servers[id];\n\n    // clean global server type map\n    slist = this.serverTypeMaps[item.serverType];\n    removeServer(slist, id);\n    // TODO: should remove the server type if the slist is empty?\n  }\n  this.event.emit(events.REMOVE_SERVERS, ids);\n};\n\n/**\n * Replace server info from current application at runtime.\n *\n * @param  {Object} server id map\n * @memberOf Application\n */\nApplication.replaceServers = function(servers) {\n  if(!servers){\n    return;\n  }\n\n  this.servers = servers;\n  this.serverTypeMaps = {};\n  this.serverTypes = [];\n  var serverArray = [];\n  for(var id in servers){\n    var server = servers[id];\n    var serverType = server[Constants.RESERVED.SERVER_TYPE];\n    var slist = this.serverTypeMaps[serverType];\n    if(!slist) {\n      this.serverTypeMaps[serverType] = slist = [];\n    }\n    this.serverTypeMaps[serverType].push(server);\n    // update global server type list\n    if(this.serverTypes.indexOf(serverType) < 0) {\n      this.serverTypes.push(serverType);\n    }\n    serverArray.push(server);\n  }\n  this.event.emit(events.REPLACE_SERVERS, serverArray);\n};\n\n/**\n * Add crons from current application at runtime.\n *\n * @param  {Array} crons new crons would be added in application\n * @memberOf Application\n */\nApplication.addCrons = function(crons) {\n  if(!crons || !crons.length) {\n    logger.warn('crons is not defined.');\n    return;\n  }\n  this.event.emit(events.ADD_CRONS, crons);\n};\n\n/**\n * Remove crons from current application at runtime.\n *\n * @param  {Array} crons old crons would be removed in application\n * @memberOf Application\n */\nApplication.removeCrons = function(crons) {\n  if(!crons || !crons.length) {\n    logger.warn('ids is not defined.');\n    return;\n  }\n  this.event.emit(events.REMOVE_CRONS, crons);\n};\n\nvar replaceServer = function(slist, serverInfo) {\n  for(var i=0, l=slist.length; i<l; i++) {\n    if(slist[i].id === serverInfo.id) {\n      slist[i] = serverInfo;\n      return;\n    }\n  }\n  slist.push(serverInfo);\n};\n\nvar removeServer = function(slist, id) {\n  if(!slist || !slist.length) {\n    return;\n  }\n\n  for(var i=0, l=slist.length; i<l; i++) {\n    if(slist[i].id === id) {\n      slist.splice(i, 1);\n      return;\n    }\n  }\n};\n\nvar contains = function(str, settings) {\n  if(!settings) {\n    return false;\n  }\n\n  var ts = settings.split(\"|\");\n  for(var i=0, l=ts.length; i<l; i++) {\n    if(str === ts[i]) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvar bindEvents = function(Event, app) {\n  var emethods = new Event(app);\n  for(var m in emethods) {\n    if(typeof emethods[m] === 'function') {\n      app.event.on(m, emethods[m].bind(emethods));\n    }\n  }\n};\n\nvar addFilter = function(app, type, filter) {\n var filters = app.get(type);\n  if(!filters) {\n    filters = [];\n    app.set(type, filters);\n  }\n  filters.push(filter);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/util/utils.js":"var os = require('os');\nvar util = require('util');\nvar exec = require('child_process').exec;\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar Constants = require('./constants');\nvar pomelo = require('../pomelo');\n\nvar utils = module.exports;\n\n/**\n * Invoke callback with check\n */\nutils.invokeCallback = function(cb) {\n  if (typeof cb === 'function') {\n    var len = arguments.length;\n    if(len == 1) {\n      return cb();\n    }\n\n    if(len == 2) {\n      return cb(arguments[1]);\n    }\n\n    if(len == 3) {\n      return cb(arguments[1], arguments[2]);\n    }\n\n    if(len == 4) {\n      return cb(arguments[1], arguments[2], arguments[3]);\n    }\n\n    var args = Array(len - 1);\n    for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n    cb.apply(null, args);\n    // cb.apply(null, Array.prototype.slice.call(arguments, 1));\n  }\n};\n\n/**\n * Get the count of elements of object\n */\nutils.size = function(obj) {\n  var count = 0;\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i) && typeof obj[i] !== 'function') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Check a string whether ends with another string\n */\nutils.endsWith = function(str, suffix) {\n  if (typeof str !== 'string' || typeof suffix !== 'string' ||\n    suffix.length > str.length) {\n    return false;\n  }\n  return str.indexOf(suffix, str.length - suffix.length) !== -1;\n};\n\n/**\n * Check a string whether starts with another string\n */\nutils.startsWith = function(str, prefix) {\n  if (typeof str !== 'string' || typeof prefix !== 'string' ||\n    prefix.length > str.length) {\n    return false;\n  }\n\n  return str.indexOf(prefix) === 0;\n};\n\n/**\n * Compare the two arrays and return the difference.\n */\nutils.arrayDiff = function(array1, array2) {\n  var o = {};\n  for(var i = 0, len = array2.length; i < len; i++) {\n    o[array2[i]] = true;\n  }\n\n  var result = [];\n  for(i = 0, len = array1.length; i < len; i++) {\n    var v = array1[i];\n    if(o[v]) continue;\n    result.push(v);\n  }\n  return result;\n};\n\n/*\n * Date format\n */\nutils.format = function(date, format) {\n  format = format || 'MMddhhmm';\n  var o = {\n    \"M+\": date.getMonth() + 1, //month\n    \"d+\": date.getDate(), //day\n    \"h+\": date.getHours(), //hour\n    \"m+\": date.getMinutes(), //minute\n    \"s+\": date.getSeconds(), //second\n    \"q+\": Math.floor((date.getMonth() + 3) / 3), //quarter\n    \"S\": date.getMilliseconds() //millisecond\n  };\n\n  if (/(y+)/.test(format)) {\n    format = format.replace(RegExp.$1, (date.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n  }\n\n  for (var k in o) {\n    if (new RegExp(\"(\" + k + \")\").test(format)) {\n      format = format.replace(RegExp.$1, RegExp.$1.length === 1 ? o[k] :\n        (\"00\" + o[k]).substr((\"\" + o[k]).length));\n    }\n  }\n  return format;\n};\n\n/**\n * check if has Chinese characters.\n */\nutils.hasChineseChar = function(str) {\n  if (/.*[\\u4e00-\\u9fa5]+.*$/.test(str)) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * transform unicode to utf8\n */\nutils.unicodeToUtf8 = function(str) {\n  var i, len, ch;\n  var utf8Str = \"\";\n  len = str.length;\n  for (i = 0; i < len; i++) {\n    ch = str.charCodeAt(i);\n\n    if ((ch >= 0x0) && (ch <= 0x7F)) {\n      utf8Str += str.charAt(i);\n\n    } else if ((ch >= 0x80) && (ch <= 0x7FF)) {\n      utf8Str += String.fromCharCode(0xc0 | ((ch >> 6) & 0x1F));\n      utf8Str += String.fromCharCode(0x80 | (ch & 0x3F));\n\n    } else if ((ch >= 0x800) && (ch <= 0xFFFF)) {\n      utf8Str += String.fromCharCode(0xe0 | ((ch >> 12) & 0xF));\n      utf8Str += String.fromCharCode(0x80 | ((ch >> 6) & 0x3F));\n      utf8Str += String.fromCharCode(0x80 | (ch & 0x3F));\n\n    } else if ((ch >= 0x10000) && (ch <= 0x1FFFFF)) {\n      utf8Str += String.fromCharCode(0xF0 | ((ch >> 18) & 0x7));\n      utf8Str += String.fromCharCode(0x80 | ((ch >> 12) & 0x3F));\n      utf8Str += String.fromCharCode(0x80 | ((ch >> 6) & 0x3F));\n      utf8Str += String.fromCharCode(0x80 | (ch & 0x3F));\n\n    } else if ((ch >= 0x200000) && (ch <= 0x3FFFFFF)) {\n      utf8Str += String.fromCharCode(0xF8 | ((ch >> 24) & 0x3));\n      utf8Str += String.fromCharCode(0x80 | ((ch >> 18) & 0x3F));\n      utf8Str += String.fromCharCode(0x80 | ((ch >> 12) & 0x3F));\n      utf8Str += String.fromCharCode(0x80 | ((ch >> 6) & 0x3F));\n      utf8Str += String.fromCharCode(0x80 | (ch & 0x3F));\n\n    } else if ((ch >= 0x4000000) && (ch <= 0x7FFFFFFF)) {\n      utf8Str += String.fromCharCode(0xFC | ((ch >> 30) & 0x1));\n      utf8Str += String.fromCharCode(0x80 | ((ch >> 24) & 0x3F));\n      utf8Str += String.fromCharCode(0x80 | ((ch >> 18) & 0x3F));\n      utf8Str += String.fromCharCode(0x80 | ((ch >> 12) & 0x3F));\n      utf8Str += String.fromCharCode(0x80 | ((ch >> 6) & 0x3F));\n      utf8Str += String.fromCharCode(0x80 | (ch & 0x3F));\n\n    }\n\n  }\n  return utf8Str;\n};\n\n/**\n * Ping server to check if network is available\n *\n */\nutils.ping = function(host, cb) {\n  if(!module.exports.isLocal(host)) {\n    var cmd = 'ping -w 15 ' + host;\n    exec(cmd, function(err, stdout, stderr) {\n      if(!!err) {\n        cb(false);\n        return;\n      }\n      cb(true);\n    });\n  } else {\n    cb(true);\n  }\n};\n\n/**\n * Check if server is exsit. \n *\n */\nutils.checkPort = function(server, cb) {\n  if (!server.port && !server.clientPort) {\n    this.invokeCallback(cb, 'leisure');\n    return;\n  }\n  var self = this;\n  var port = server.port || server.clientPort;\n  var host = server.host;\n  var generateCommand = function(self, host, port) {\n    var cmd;\n    var ssh_params = pomelo.app.get(Constants.RESERVED.SSH_CONFIG_PARAMS);\n    if(!!ssh_params && Array.isArray(ssh_params)) {\n      ssh_params = ssh_params.join(' ');\n    }\n    else {\n      ssh_params = \"\";\n    }\n    if (!self.isLocal(host)) {\n      cmd = util.format('ssh %s %s \"netstat -an|awk \\'{print $4}\\'|grep %s|wc -l\"', host, ssh_params, port);\n    } else {\n      cmd = util.format('netstat -an|awk \\'{print $4}\\'|grep %s|wc -l', port);\n    }\n    return cmd;\n  };\n  var cmd1 = generateCommand(self, host, port);\n  var child = exec(cmd1, function(err, stdout, stderr) {\n    if(err) {\n      logger.error('command %s execute with error: %j', cmd1, err.stack);\n      self.invokeCallback(cb, 'error');\n    } else if(stdout.trim() !== '0') {\n      self.invokeCallback(cb, 'busy');\n    } else {\n      port = server.clientPort;\n      var cmd2 = generateCommand(self, host, port);\n      exec(cmd2, function(err, stdout, stderr) {\n        if(err) {\n          logger.error('command %s execute with error: %j', cmd2, err.stack);\n          self.invokeCallback(cb, 'error');\n        } else if (stdout.trim() !== '0') {\n          self.invokeCallback(cb, 'busy');\n        } else {\n          self.invokeCallback(cb, 'leisure');\n        }\n      });\n    }\n  });\n};\n\nutils.isLocal = function(host) {\n  var app = require('../pomelo').app;\n  if(!app) {\n    return host === '127.0.0.1' || host === 'localhost' || host === '0.0.0.0' || inLocal(host);\n  } else {\n    return host === '127.0.0.1' || host === 'localhost' || host === '0.0.0.0' || inLocal(host) || host === app.master.host;\n  }\n};\n\n/**\n * Load cluster server.\n *\n */\nutils.loadCluster = function(app, server, serverMap) {\n  var increaseFields = {};\n  var host = server.host;\n  var count = parseInt(server[Constants.RESERVED.CLUSTER_COUNT]);\n  var seq = app.clusterSeq[server.serverType];\n  if(!seq) {\n    seq = 0;\n    app.clusterSeq[server.serverType] = count;\n  } else {\n    app.clusterSeq[server.serverType] = seq + count;\n  }\n\n  for(var key in server) {\n    var value = server[key].toString();\n    if(value.indexOf(Constants.RESERVED.CLUSTER_SIGNAL) > 0) {\n      var base = server[key].slice(0, -2);\n      increaseFields[key] = base;\n    }\n  }\n\n  var clone = function(src) {\n    var rs = {};\n    for(var key in src) {\n      rs[key] = src[key];\n    }\n    return rs;\n  };\n  for(var i=0, l=seq; i<count; i++,l++) {\n    var cserver = clone(server);\n    cserver.id = Constants.RESERVED.CLUSTER_PREFIX + server.serverType + '-' + l;\n    for(var k in increaseFields) {\n      var v = parseInt(increaseFields[k]);\n      cserver[k] = v + i;\n    }\n    serverMap[cserver.id] = cserver;\n  }\n};\n\nutils.extends = function(origin, add) {\n  if (!add || !this.isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nutils.headHandler = function(headBuffer) {\n  var len = 0;\n  for(var i=1; i<4; i++) {\n    if(i > 1) {\n      len <<= 8;\n    }\n    len += headBuffer.readUInt8(i);\n  }\n  return len;\n};\n\nvar inLocal = function(host) {\n  for (var index in localIps) {\n    if (host === localIps[index]) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvar localIps = function() {\n  var ifaces = os.networkInterfaces();\n  var ips = [];\n  var func = function(details) {\n    if (details.family === 'IPv4') {\n      ips.push(details.address);\n    }\n  };\n  for (var dev in ifaces) {\n    ifaces[dev].forEach(func);\n  }\n  return ips;\n}();\n\nutils.isObject = function(arg) {\n  return typeof arg === 'object' && arg !== null;\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-logger/index.js":"module.exports = require('./lib/logger');","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-logger/lib/logger.js":"var log4js = require('log4js');\nvar fs = require('fs');\nvar util = require('util');\n\n\nvar funcs = {\n\t'env': doEnv,\n\t'args': doArgs,\n\t'opts': doOpts\n};\n\nfunction getLogger(categoryName) {\n\tvar args = arguments;\n\tvar prefix = \"\";\n\tfor (var i = 1; i < args.length; i++) {\n\t\tif (i !== args.length - 1)\n\t\t\tprefix = prefix + args[i] + \"] [\";\n\t\telse\n\t\t\tprefix = prefix + args[i];\n\t}\n\tif (typeof categoryName === 'string') {\n\t\t// category name is __filename then cut the prefix path\n\t\tcategoryName = categoryName.replace(process.cwd(), '');\n\t}\n\tvar logger = log4js.getLogger(categoryName);\n\tvar pLogger = {};\n\tfor (var key in logger) {\n\t\tpLogger[key] = logger[key];\n\t}\n\n\t['log', 'debug', 'info', 'warn', 'error', 'trace', 'fatal'].forEach(function(item) {\n\t\tpLogger[item] = function() {\n\t\t\tvar p = \"\";\n\t\t\tif (!process.env.RAW_MESSAGE) {\n\t\t\t\tif (args.length > 1) {\n\t\t\t\t\tp = \"[\" + prefix + \"] \";\n\t\t\t\t}\n\t\t\t\tif (args.length && process.env.LOGGER_LINE) {\n\t\t\t\t\tp = getLine() + \": \" + p;\n\t\t\t\t}\n\t\t\t\tp = colorize(p, colours[item]);\n\t\t\t}\n\n\t\t\tif (args.length) {\n\t\t\t\targuments[0] = p + arguments[0];\n\t\t\t}\n\t\t\tlogger[item].apply(logger, arguments);\n\t\t}\n\t});\n\treturn pLogger;\n};\n\nvar configState = {};\n\nfunction initReloadConfiguration(filename, reloadSecs) {\n\tif (configState.timerId) {\n\t\tclearInterval(configState.timerId);\n\t\tdelete configState.timerId;\n\t}\n\tconfigState.filename = filename;\n\tconfigState.lastMTime = getMTime(filename);\n\tconfigState.timerId = setInterval(reloadConfiguration, reloadSecs * 1000);\n};\n\nfunction getMTime(filename) {\n\tvar mtime;\n\ttry {\n\t\tmtime = fs.statSync(filename).mtime;\n\t} catch (e) {\n\t\tthrow new Error(\"Cannot find file with given path: \" + filename);\n\t}\n\treturn mtime;\n};\n\nfunction loadConfigurationFile(filename) {\n\tif (filename) {\n\t\treturn JSON.parse(fs.readFileSync(filename, \"utf8\"));\n\t}\n\treturn undefined;\n};\n\nfunction reloadConfiguration() {\n\tvar mtime = getMTime(configState.filename);\n\tif (!mtime) {\n\t\treturn;\n\t}\n\tif (configState.lastMTime && (mtime.getTime() > configState.lastMTime.getTime())) {\n\t\tconfigureOnceOff(loadConfigurationFile(configState.filename));\n\t}\n\tconfigState.lastMTime = mtime;\n};\n\n\nfunction configureOnceOff(config) {\n\tif (config) {\n\t\ttry {\n\t\t\tconfigureLevels(config.levels);\n\t\t\tif (config.replaceConsole) {\n\t\t\t\tlog4js.replaceConsole();\n\t\t\t} else {\n\t\t\t\tlog4js.restoreConsole();\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Problem reading log4js config \" + util.inspect(config) +\n\t\t\t\t\". Error was \\\"\" + e.message + \"\\\" (\" + e.stack + \")\"\n\t\t\t);\n\t\t}\n\t}\n};\n\nfunction configureLevels(levels) {\n\tif (levels) {\n\t\tfor (var category in levels) {\n\t\t\tif (levels.hasOwnProperty(category)) {\n\t\t\t\tlog4js.getLogger(category).setLevel(levels[category]);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Configure the logger.\n * Configure file just like log4js.json. And support ${scope:arg-name} format property setting.\n * It can replace the placeholder in runtime.\n * scope can be:\n *     env: environment variables, such as: env:PATH\n *     args: command line arguments, such as: args:1\n *     opts: key/value from opts argument of configure function\n *\n * @param  {String|Object} config configure file name or configure object\n * @param  {Object} opts   options\n * @return {Void}\n */\n\nfunction configure(config, opts) {\n\tvar filename = config;\n\tconfig = config || process.env.LOG4JS_CONFIG;\n\topts = opts || {};\n\n\tif (typeof config === 'string') {\n\t\tconfig = JSON.parse(fs.readFileSync(config, \"utf8\"));\n\t}\n\n\tif (config) {\n\t\tconfig = replaceProperties(config, opts);\n\t}\n\n\tif (config && config.lineDebug) {\n\t\tprocess.env.LOGGER_LINE = true;\n\t}\n\n\tif (config && config.rawMessage) {\n\t\tprocess.env.RAW_MESSAGE = true;\n\t}\n\n\tif (filename && config && config.reloadSecs) {\n\t\tinitReloadConfiguration(filename, config.reloadSecs);\n\t}\n\n\t// config object could not turn on the auto reload configure file in log4js\n\n\tlog4js.configure(config, opts);\n};\n\nfunction replaceProperties(configObj, opts) {\n\tif (configObj instanceof Array) {\n\t\tfor (var i = 0, l = configObj.length; i < l; i++) {\n\t\t\tconfigObj[i] = replaceProperties(configObj[i], opts);\n\t\t}\n\t} else if (typeof configObj === 'object') {\n\t\tvar field;\n\t\tfor (var f in configObj) {\n\t\t\tif (!configObj.hasOwnProperty(f)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfield = configObj[f];\n\t\t\tif (typeof field === 'string') {\n\t\t\t\tconfigObj[f] = doReplace(field, opts);\n\t\t\t} else if (typeof field === 'object') {\n\t\t\t\tconfigObj[f] = replaceProperties(field, opts);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn configObj;\n}\n\nfunction doReplace(src, opts) {\n\tif (!src) {\n\t\treturn src;\n\t}\n\n\tvar ptn = /\\$\\{(.*?)\\}/g;\n\tvar m, pro, ts, scope, name, defaultValue, func, res = '',\n\t\tlastIndex = 0;\n\twhile ((m = ptn.exec(src))) {\n\t\tpro = m[1];\n\t\tts = pro.split(':');\n\t\tif (ts.length !== 2 && ts.length !== 3) {\n\t\t\tres += pro;\n\t\t\tcontinue;\n\t\t}\n\n\t\tscope = ts[0];\n\t\tname = ts[1];\n\t\tif (ts.length === 3) {\n\t\t\tdefaultValue = ts[2];\n\t\t}\n\n\t\tfunc = funcs[scope];\n\t\tif (!func && typeof func !== 'function') {\n\t\t\tres += pro;\n\t\t\tcontinue;\n\t\t}\n\n\t\tres += src.substring(lastIndex, m.index);\n\t\tlastIndex = ptn.lastIndex;\n\t\tres += (func(name, opts) || defaultValue);\n\t}\n\n\tif (lastIndex < src.length) {\n\t\tres += src.substring(lastIndex);\n\t}\n\n\treturn res;\n}\n\nfunction doEnv(name) {\n\treturn process.env[name];\n}\n\nfunction doArgs(name) {\n\treturn process.argv[name];\n}\n\nfunction doOpts(name, opts) {\n\treturn opts ? opts[name] : undefined;\n}\n\nfunction getLine() {\n\tvar e = new Error();\n\t// now magic will happen: get line number from callstack\n\tvar line = e.stack.split('\\n')[3].split(':')[1];\n\treturn line;\n}\n\nfunction colorizeStart(style) {\n\treturn style ? '\\x1B[' + styles[style][0] + 'm' : '';\n}\n\nfunction colorizeEnd(style) {\n\treturn style ? '\\x1B[' + styles[style][1] + 'm' : '';\n}\n/**\n * Taken from masylum's fork (https://github.com/masylum/log4js-node)\n */\nfunction colorize(str, style) {\n\treturn colorizeStart(style) + str + colorizeEnd(style);\n}\n\nvar styles = {\n\t//styles\n\t'bold': [1, 22],\n\t'italic': [3, 23],\n\t'underline': [4, 24],\n\t'inverse': [7, 27],\n\t//grayscale\n\t'white': [37, 39],\n\t'grey': [90, 39],\n\t'black': [90, 39],\n\t//colors\n\t'blue': [34, 39],\n\t'cyan': [36, 39],\n\t'green': [32, 39],\n\t'magenta': [35, 39],\n\t'red': [31, 39],\n\t'yellow': [33, 39]\n};\n\nvar colours = {\n\t'all': \"grey\",\n\t'trace': \"blue\",\n\t'debug': \"cyan\",\n\t'info': \"green\",\n\t'warn': \"yellow\",\n\t'error': \"red\",\n\t'fatal': \"magenta\",\n\t'off': \"grey\"\n};\n\nmodule.exports = {\n\tgetLogger: getLogger,\n\tgetDefaultLogger: log4js.getDefaultLogger,\n\n\taddAppender: log4js.addAppender,\n\tloadAppender: log4js.loadAppender,\n\tclearAppenders: log4js.clearAppenders,\n\tconfigure: configure,\n\n\treplaceConsole: log4js.replaceConsole,\n\trestoreConsole: log4js.restoreConsole,\n\n\tlevels: log4js.levels,\n\tsetGlobalLogLevel: log4js.setGlobalLogLevel,\n\n\tlayouts: log4js.layouts,\n\tappenders: log4js.appenders\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-logger/node_modules/log4js/lib/log4js.js":"\"use strict\";\n/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview log4js is a library to log in JavaScript in similar manner\n * than in log4j for Java. The API should be nearly the same.\n *\n * <h3>Example:</h3>\n * <pre>\n *  var logging = require('log4js');\n *  //add an appender that logs all messages to stdout.\n *  logging.addAppender(logging.consoleAppender());\n *  //add an appender that logs \"some-category\" to a file\n *  logging.addAppender(logging.fileAppender(\"file.log\"), \"some-category\");\n *  //get a logger\n *  var log = logging.getLogger(\"some-category\");\n *  log.setLevel(logging.levels.TRACE); //set the Level\n *\n *  ...\n *\n *  //call the log\n *  log.trace(\"trace me\" );\n * </pre>\n *\n * NOTE: the authors below are the original browser-based log4js authors\n * don't try to contact them about bugs in this version :)\n * @version 1.0\n * @author Stephan Strittmatter - http://jroller.com/page/stritti\n * @author Seth Chisamore - http://www.chisamore.com\n * @since 2005-05-20\n * @static\n * Website: http://log4js.berlios.de\n */\nvar events = require('events')\n, async = require('async')\n, fs = require('fs')\n, path = require('path')\n, util = require('util')\n, layouts = require('./layouts')\n, levels = require('./levels')\n, loggerModule = require('./logger')\n, LoggingEvent = loggerModule.LoggingEvent\n, Logger = loggerModule.Logger\n, ALL_CATEGORIES = '[all]'\n, appenders = {}\n, loggers = {}\n, appenderMakers = {}\n, appenderShutdowns = {}\n, defaultConfig =   {\n  appenders: [\n    { type: \"console\" }\n  ],\n  replaceConsole: false\n};\n\nfunction hasLogger(logger) {\n  return loggers.hasOwnProperty(logger);\n}\n\n\nfunction getBufferedLogger(categoryName) {\n    var base_logger = getLogger(categoryName);\n    var logger = {};\n    logger.temp = [];\n    logger.target = base_logger;\n    logger.flush = function () {\n        for (var i = 0; i < logger.temp.length; i++) {\n            var log = logger.temp[i];\n            logger.target[log.level](log.message);\n            delete logger.temp[i];\n        }\n    };\n    logger.trace = function (message) { logger.temp.push({level: 'trace', message: message}); };\n    logger.debug = function (message) { logger.temp.push({level: 'debug', message: message}); };\n    logger.info = function (message) { logger.temp.push({level: 'info', message: message}); };\n    logger.warn = function (message) { logger.temp.push({level: 'warn', message: message}); };\n    logger.error = function (message) { logger.temp.push({level: 'error', message: message}); };\n    logger.fatal = function (message) { logger.temp.push({level: 'fatal', message: message}); };\n\n    return logger;\n}\n\n\n/**\n * Get a logger instance. Instance is cached on categoryName level.\n * @param  {String} categoryName name of category to log to.\n * @return {Logger} instance of logger for the category\n * @static\n */\nfunction getLogger (categoryName) {\n\n  // Use default logger if categoryName is not specified or invalid\n  if (typeof categoryName !== \"string\") {\n    categoryName = Logger.DEFAULT_CATEGORY;\n  }\n\n  var appenderList;\n  if (!hasLogger(categoryName)) {\n    // Create the logger for this name if it doesn't already exist\n    loggers[categoryName] = new Logger(categoryName);\n    if (appenders[categoryName]) {\n      appenderList = appenders[categoryName];\n      appenderList.forEach(function(appender) {\n        loggers[categoryName].addListener(\"log\", appender);\n      });\n    }\n    if (appenders[ALL_CATEGORIES]) {\n      appenderList = appenders[ALL_CATEGORIES];\n      appenderList.forEach(function(appender) {\n        loggers[categoryName].addListener(\"log\", appender);\n      });\n    }\n  }\n  \n  return loggers[categoryName];\n}\n\n/**\n * args are appender, then zero or more categories\n */\nfunction addAppender () {\n  var args = Array.prototype.slice.call(arguments);\n  var appender = args.shift();\n  if (args.length === 0 || args[0] === undefined) {\n    args = [ ALL_CATEGORIES ];\n  }\n  //argument may already be an array\n  if (Array.isArray(args[0])) {\n    args = args[0];\n  }\n  \n  args.forEach(function(category) {\n    addAppenderToCategory(appender, category);\n    \n    if (category === ALL_CATEGORIES) {\n      addAppenderToAllLoggers(appender);\n    } else if (hasLogger(category)) {\n      loggers[category].addListener(\"log\", appender);\n    }\n  });\n}\n\nfunction addAppenderToAllLoggers(appender) {\n  for (var logger in loggers) {\n    if (hasLogger(logger)) {\n      loggers[logger].addListener(\"log\", appender);\n    }\n  }\n}\n\nfunction addAppenderToCategory(appender, category) {\n  if (!appenders[category]) {\n    appenders[category] = [];\n  }\n  appenders[category].push(appender);\n}\n\nfunction clearAppenders () {\n  appenders = {};\n  for (var logger in loggers) {\n    if (hasLogger(logger)) {\n      loggers[logger].removeAllListeners(\"log\");\n    }\n  }\n}\n\nfunction configureAppenders(appenderList, options) {\n  clearAppenders();\n  if (appenderList) {\n    appenderList.forEach(function(appenderConfig) {\n      loadAppender(appenderConfig.type);\n      var appender;\n      appenderConfig.makers = appenderMakers;\n      try {\n        appender = appenderMakers[appenderConfig.type](appenderConfig, options);\n        addAppender(appender, appenderConfig.category);\n      } catch(e) {\n        throw new Error(\"log4js configuration problem for \" + util.inspect(appenderConfig), e);\n      }\n    });\n  }\n}\n\nfunction configureLevels(levels) {\n  if (levels) {\n    for (var category in levels) {\n      if (levels.hasOwnProperty(category)) {\n        if(category === ALL_CATEGORIES) {\n          setGlobalLogLevel(levels[category]);\n        }\n        getLogger(category).setLevel(levels[category]);\n      }\n    }\n  }\n}\n\nfunction setGlobalLogLevel(level) {\n  Logger.prototype.level = levels.toLevel(level, levels.TRACE);\n}\n\n/**\n * Get the default logger instance.\n * @return {Logger} instance of default logger\n * @static\n */\nfunction getDefaultLogger () {\n  return getLogger(Logger.DEFAULT_CATEGORY);\n}\n\nvar configState = {};\n\nfunction loadConfigurationFile(filename) {\n  if (filename) {\n    return JSON.parse(fs.readFileSync(filename, \"utf8\"));\n  }\n  return undefined;\n}\n\nfunction configureOnceOff(config, options) {\n  if (config) {\n    try {\n      configureAppenders(config.appenders, options);\n      configureLevels(config.levels);\n      \n      if (config.replaceConsole) {\n        replaceConsole();\n      } else {\n        restoreConsole();\n      }\n    } catch (e) {\n      throw new Error(\n        \"Problem reading log4js config \" + util.inspect(config) + \n          \". Error was \\\"\" + e.message + \"\\\" (\" + e.stack + \")\"\n      );\n    }\n  }\n}\n\nfunction reloadConfiguration() {\n  var mtime = getMTime(configState.filename);\n  if (!mtime) return;\n\n  if (configState.lastMTime && (mtime.getTime() > configState.lastMTime.getTime())) {\n    configureOnceOff(loadConfigurationFile(configState.filename));\n  }\n  configState.lastMTime = mtime;\n}\n\nfunction getMTime(filename) {\n  var mtime;\n  try {\n    mtime = fs.statSync(configState.filename).mtime;\n  } catch (e) {\n    getLogger('log4js').warn('Failed to load configuration file ' + filename);\n  }\n  return mtime;\n}\n\nfunction initReloadConfiguration(filename, options) {\n  if (configState.timerId) {\n    clearInterval(configState.timerId);\n    delete configState.timerId;\n  }\n  configState.filename = filename;\n  configState.lastMTime = getMTime(filename);\n  configState.timerId = setInterval(reloadConfiguration, options.reloadSecs*1000);\n}\n\nfunction configure(configurationFileOrObject, options) {\n  var config = configurationFileOrObject;\n  config = config || process.env.LOG4JS_CONFIG;\n  options = options || {};\n  \n  if (config === undefined || config === null || typeof(config) === 'string') {\n    if (options.reloadSecs) {\n      initReloadConfiguration(config, options);\n    }\n    config = loadConfigurationFile(config) || defaultConfig;\n  } else {\n    if (options.reloadSecs) {\n      getLogger('log4js').warn(\n        'Ignoring configuration reload parameter for \"object\" configuration.'\n      );\n    }\n  }\n  configureOnceOff(config, options);\n}\n\nvar originalConsoleFunctions = {\n  log: console.log,\n  debug: console.debug,\n  info: console.info,\n  warn: console.warn,\n  error: console.error\n};\n\nfunction replaceConsole(logger) {\n  function replaceWith(fn) {\n    return function() {\n      fn.apply(logger, arguments);\n    };\n  }\n  logger = logger || getLogger(\"console\");\n  ['log','debug','info','warn','error'].forEach(function (item) {\n    console[item] = replaceWith(item === 'log' ? logger.info : logger[item]);\n  });\n}\n\nfunction restoreConsole() {\n  ['log', 'debug', 'info', 'warn', 'error'].forEach(function (item) {\n    console[item] = originalConsoleFunctions[item];\n  });\n}\n\n/**\n * Load an appenderModule based on the provided appender filepath. Will first\n * check if the appender path is a subpath of the log4js \"lib/appenders\" directory.\n * If not, it will attempt to load the the appender as complete path.\n *\n * @param {string} appender The filepath for the appender.\n * @returns {Object|null} The required appender or null if appender could not be loaded.\n * @private\n */\nfunction requireAppender(appender) {\n  var appenderModule;\n  try {\n    appenderModule = require('./appenders/' + appender);\n  } catch (e) {\n    appenderModule = require(appender);\n  }\n  return appenderModule;\n}\n\n/**\n * Load an appender. Provided the appender path to be loaded. If appenderModule is defined,\n * it will be used in place of requiring the appender module.\n *\n * @param {string} appender The path to the appender module.\n * @param {Object|void} [appenderModule] The pre-required appender module. When provided,\n * instead of requiring the appender by its path, this object will be used.\n * @returns {void}\n * @private\n */\nfunction loadAppender(appender, appenderModule) {\n  appenderModule = appenderModule || requireAppender(appender);\n\n  if (!appenderModule) {\n    throw new Error(\"Invalid log4js appender: \" + util.inspect(appender));\n  }\n\n  module.exports.appenders[appender] = appenderModule.appender.bind(appenderModule);\n  if (appenderModule.shutdown) {\n    appenderShutdowns[appender] = appenderModule.shutdown.bind(appenderModule);\n  }\n  appenderMakers[appender] = appenderModule.configure.bind(appenderModule);\n}\n\n/**\n * Shutdown all log appenders. This will first disable all writing to appenders\n * and then call the shutdown function each appender.\n *\n * @params {Function} cb - The callback to be invoked once all appenders have\n *  shutdown. If an error occurs, the callback will be given the error object\n *  as the first argument.\n * @returns {void}\n */\nfunction shutdown(cb) {\n  // First, disable all writing to appenders. This prevents appenders from\n  // not being able to be drained because of run-away log writes.\n  loggerModule.disableAllLogWrites();\n\n  // Next, get all the shutdown functions for appenders as an array.\n  var shutdownFunctions = Object.keys(appenderShutdowns).reduce(\n    function(accum, category) {\n      return accum.concat(appenderShutdowns[category]);\n    }, []);\n\n  // Call each of the shutdown functions.\n  async.each(\n    shutdownFunctions,\n    function(shutdownFn, done) {\n      shutdownFn(done);\n    },\n\t\tcb\n  );\n}\n\nmodule.exports = {\n  getBufferedLogger: getBufferedLogger,\n  getLogger: getLogger,\n  getDefaultLogger: getDefaultLogger,\n  hasLogger: hasLogger,\n  \n  addAppender: addAppender,\n  loadAppender: loadAppender,\n  clearAppenders: clearAppenders,\n  configure: configure,\n  shutdown: shutdown,\n  \n  replaceConsole: replaceConsole,\n  restoreConsole: restoreConsole,\n  \n  levels: levels,\n  setGlobalLogLevel: setGlobalLogLevel,\n  \n  layouts: layouts,\n  appenders: {},\n  appenderMakers: appenderMakers,\n  connectLogger: require('./connect-logger').connectLogger\n};\n\n//set ourselves up\nconfigure();\n\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-logger/node_modules/log4js/lib/layouts.js":"\"use strict\";\nvar dateFormat = require('./date_format')\n, os = require('os')\n, eol = os.EOL || '\\n'\n, util = require('util')\n, replacementRegExp = /%[sdj]/g\n, layoutMakers = {\n  \"messagePassThrough\": function() { return messagePassThroughLayout; }, \n  \"basic\": function() { return basicLayout; }, \n  \"colored\": function() { return colouredLayout; }, \n  \"coloured\": function() { return colouredLayout; }, \n  \"pattern\": function (config) {\n    return patternLayout(config && config.pattern, config && config.tokens);\n\t}\n}\n, colours = {\n  ALL: \"grey\", \n  TRACE: \"blue\", \n  DEBUG: \"cyan\", \n  INFO: \"green\", \n  WARN: \"yellow\", \n  ERROR: \"red\", \n  FATAL: \"magenta\", \n  OFF: \"grey\"\n};\n\nfunction wrapErrorsWithInspect(items) {\n  return items.map(function(item) {\n    if ((item instanceof Error) && item.stack) {\n      return { inspect: function() { return util.format(item) + '\\n' + item.stack; } };\n    } else {\n      return item;\n    }\n  });\n}\n\nfunction formatLogData(logData) {\n  var data = Array.isArray(logData) ? logData : Array.prototype.slice.call(arguments);\n  return util.format.apply(util, wrapErrorsWithInspect(data));\n}\n\nvar styles = {\n    //styles\n  'bold'      : [1,  22],\n  'italic'    : [3,  23],\n  'underline' : [4,  24],\n  'inverse'   : [7,  27],\n  //grayscale\n  'white'     : [37, 39],\n  'grey'      : [90, 39],\n  'black'     : [90, 39],\n  //colors\n  'blue'      : [34, 39],\n  'cyan'      : [36, 39],\n  'green'     : [32, 39],\n  'magenta'   : [35, 39],\n  'red'       : [31, 39],\n  'yellow'    : [33, 39]\n};\n\nfunction colorizeStart(style) {\n  return style ? '\\x1B[' + styles[style][0] + 'm' : '';\n}\nfunction colorizeEnd(style) {\n  return style ? '\\x1B[' + styles[style][1] + 'm' : '';\n}\n/**\n * Taken from masylum's fork (https://github.com/masylum/log4js-node)\n */\nfunction colorize (str, style) {\n  return colorizeStart(style) + str + colorizeEnd(style);\n}\n\nfunction timestampLevelAndCategory(loggingEvent, colour) {\n  var output = colorize(\n    formatLogData(\n      '[%s] [%s] %s - '\n      , dateFormat.asString(loggingEvent.startTime)\n      , loggingEvent.level\n      , loggingEvent.categoryName\n    )\n    , colour\n  );\n  return output;\n}\n\n/**\n * BasicLayout is a simple layout for storing the logs. The logs are stored\n * in following format:\n * <pre>\n * [startTime] [logLevel] categoryName - message\\n\n * </pre>\n *\n * @author Stephan Strittmatter\n */\nfunction basicLayout (loggingEvent) {\n  return timestampLevelAndCategory(loggingEvent) + formatLogData(loggingEvent.data);\n}\n\n/**\n * colouredLayout - taken from masylum's fork.\n * same as basicLayout, but with colours.\n */\nfunction colouredLayout (loggingEvent) {\n  return timestampLevelAndCategory(\n    loggingEvent,\n    colours[loggingEvent.level.toString()]\n  ) + formatLogData(loggingEvent.data);\n}\n\nfunction messagePassThroughLayout (loggingEvent) {\n  return formatLogData(loggingEvent.data);\n}\n\n/**\n * PatternLayout\n * Format for specifiers is %[padding].[truncation][field]{[format]}\n * e.g. %5.10p - left pad the log level by 5 characters, up to a max of 10\n * Fields can be any of:\n *  - %r time in toLocaleTimeString format\n *  - %p log level\n *  - %c log category\n *  - %h hostname\n *  - %m log data\n *  - %d date in various formats\n *  - %% %\n *  - %n newline\n *  - %z pid\n *  - %x{<tokenname>} add dynamic tokens to your log. Tokens are specified in the tokens parameter\n * You can use %[ and %] to define a colored block.\n *\n * Tokens are specified as simple key:value objects. \n * The key represents the token name whereas the value can be a string or function\n * which is called to extract the value to put in the log message. If token is not\n * found, it doesn't replace the field.\n *\n * A sample token would be: { \"pid\" : function() { return process.pid; } }\n *\n * Takes a pattern string, array of tokens and returns a layout function.\n * @param {String} Log format pattern String\n * @param {object} map object of different tokens\n * @return {Function}\n * @author Stephan Strittmatter\n * @author Jan Schmidle\n */\nfunction patternLayout (pattern, tokens) {\n  var TTCC_CONVERSION_PATTERN  = \"%r %p %c - %m%n\";\n  var regex = /%(-?[0-9]+)?(\\.?[0-9]+)?([\\[\\]cdhmnprzx%])(\\{([^\\}]+)\\})?|([^%]+)/;\n  \n  pattern = pattern || TTCC_CONVERSION_PATTERN;\n\n  function categoryName(loggingEvent, specifier) {\n    var loggerName = loggingEvent.categoryName;\n    if (specifier) {\n      var precision = parseInt(specifier, 10);\n      var loggerNameBits = loggerName.split(\".\");\n      if (precision < loggerNameBits.length) {\n        loggerName = loggerNameBits.slice(loggerNameBits.length - precision).join(\".\");\n      }\n    }\n    return loggerName;\n  }\n\n  function formatAsDate(loggingEvent, specifier) {\n    var format = dateFormat.ISO8601_FORMAT;\n    if (specifier) {\n      format = specifier;\n      // Pick up special cases\n      if (format == \"ISO8601\") {\n        format = dateFormat.ISO8601_FORMAT;\n      } else if (format == \"ISO8601_WITH_TZ_OFFSET\") {\n        format = dateFormat.ISO8601_WITH_TZ_OFFSET_FORMAT; \n      } else if (format == \"ABSOLUTE\") {\n        format = dateFormat.ABSOLUTETIME_FORMAT;\n      } else if (format == \"DATE\") {\n        format = dateFormat.DATETIME_FORMAT;\n      }\n    }\n    // Format the date\n    return dateFormat.asString(format, loggingEvent.startTime);\n  }\n  \n  function hostname() {\n    return os.hostname().toString();\n  }\n\n  function formatMessage(loggingEvent) {\n    return formatLogData(loggingEvent.data);\n  }\n  \n  function endOfLine() {\n    return eol;\n  }\n\n  function logLevel(loggingEvent) {\n    return loggingEvent.level.toString();\n  }\n\n  function startTime(loggingEvent) {\n    return \"\" + loggingEvent.startTime.toLocaleTimeString();\n  }\n\n  function startColour(loggingEvent) {\n    return colorizeStart(colours[loggingEvent.level.toString()]);\n  }\n\n  function endColour(loggingEvent) {\n    return colorizeEnd(colours[loggingEvent.level.toString()]);\n  }\n\n  function percent() {\n    return '%';\n  }\n\n  function pid() {\n    return process.pid;\n  }\n\n  function userDefined(loggingEvent, specifier) {\n    if (typeof(tokens[specifier]) !== 'undefined') {\n      if (typeof(tokens[specifier]) === 'function') {\n        return tokens[specifier](loggingEvent);\n      } else {\n        return tokens[specifier];\n      }\n    }\n    return null;\n  }\n\n  var replacers = {\n    'c': categoryName,\n    'd': formatAsDate,\n    'h': hostname,\n    'm': formatMessage,\n    'n': endOfLine,\n    'p': logLevel,\n    'r': startTime,\n    '[': startColour,\n    ']': endColour,\n    'z': pid,\n    '%': percent,\n    'x': userDefined\n  };\n\n  function replaceToken(conversionCharacter, loggingEvent, specifier) {\n    return replacers[conversionCharacter](loggingEvent, specifier);\n  }\n\n  function truncate(truncation, toTruncate) {\n    var len;\n    if (truncation) {\n      len = parseInt(truncation.substr(1), 10);\n      return toTruncate.substring(0, len);\n    }\n\n    return toTruncate;\n  }\n\n  function pad(padding, toPad) {\n    var len;\n    if (padding) {\n      if (padding.charAt(0) == \"-\") {\n        len = parseInt(padding.substr(1), 10);\n        // Right pad with spaces\n        while (toPad.length < len) {\n          toPad += \" \";\n        }\n      } else {\n        len = parseInt(padding, 10);\n        // Left pad with spaces\n        while (toPad.length < len) {\n          toPad = \" \" + toPad;\n        }\n      }\n    }\n    return toPad;\n  }\n  \n  return function(loggingEvent) {\n    var formattedString = \"\";\n    var result;\n    var searchString = pattern;\n    \n    while ((result = regex.exec(searchString))) {\n      var matchedString = result[0];\n      var padding = result[1];\n      var truncation = result[2];\n      var conversionCharacter = result[3];\n      var specifier = result[5];\n      var text = result[6];\n      \n      // Check if the pattern matched was just normal text\n      if (text) {\n        formattedString += \"\" + text;\n      } else {\n        // Create a raw replacement string based on the conversion\n        // character and specifier\n        var replacement = \n          replaceToken(conversionCharacter, loggingEvent, specifier) || \n          matchedString;\n\n        // Format the replacement according to any padding or\n        // truncation specified\n        replacement = truncate(truncation, replacement);\n        replacement = pad(padding, replacement);\n        formattedString += replacement;\n      }\n      searchString = searchString.substr(result.index + result[0].length);\n    }\n    return formattedString;\n  };\n\n}\n\nmodule.exports = {\n  basicLayout: basicLayout, \n  messagePassThroughLayout: messagePassThroughLayout, \n  patternLayout: patternLayout, \n  colouredLayout: colouredLayout, \n  coloredLayout: colouredLayout, \n  layout: function(name, config) {\n    return layoutMakers[name] && layoutMakers[name](config);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-logger/node_modules/log4js/lib/date_format.js":"\"use strict\";\nexports.ISO8601_FORMAT = \"yyyy-MM-dd hh:mm:ss.SSS\";\nexports.ISO8601_WITH_TZ_OFFSET_FORMAT = \"yyyy-MM-ddThh:mm:ssO\";\nexports.DATETIME_FORMAT = \"dd MM yyyy hh:mm:ss.SSS\";\nexports.ABSOLUTETIME_FORMAT = \"hh:mm:ss.SSS\";\n\nfunction padWithZeros(vNumber, width) {\n  var numAsString = vNumber + \"\";\n  while (numAsString.length < width) {\n    numAsString = \"0\" + numAsString;\n  }\n  return numAsString;\n}\n  \nfunction addZero(vNumber) {\n  return padWithZeros(vNumber, 2);\n}\n\n/**\n * Formats the TimeOffest\n * Thanks to http://www.svendtofte.com/code/date_format/\n * @private\n */\nfunction offset(date) {\n  // Difference to Greenwich time (GMT) in hours\n  var os = Math.abs(date.getTimezoneOffset());\n  var h = String(Math.floor(os/60));\n  var m = String(os%60);\n  if (h.length == 1) {\n    h = \"0\" + h;\n  }\n  if (m.length == 1) {\n    m = \"0\" + m;\n  }\n  return date.getTimezoneOffset() < 0 ? \"+\"+h+m : \"-\"+h+m;\n}\n\nexports.asString = function(/*format,*/ date) {\n  var format = exports.ISO8601_FORMAT;\n  if (typeof(date) === \"string\") {\n    format = arguments[0];\n    date = arguments[1];\n  }\n\n  var vDay = addZero(date.getDate());\n  var vMonth = addZero(date.getMonth()+1);\n  var vYearLong = addZero(date.getFullYear());\n  var vYearShort = addZero(date.getFullYear().toString().substring(2,4));\n  var vYear = (format.indexOf(\"yyyy\") > -1 ? vYearLong : vYearShort);\n  var vHour  = addZero(date.getHours());\n  var vMinute = addZero(date.getMinutes());\n  var vSecond = addZero(date.getSeconds());\n  var vMillisecond = padWithZeros(date.getMilliseconds(), 3);\n  var vTimeZone = offset(date);\n  var formatted = format\n    .replace(/dd/g, vDay)\n    .replace(/MM/g, vMonth)\n    .replace(/y{1,4}/g, vYear)\n    .replace(/hh/g, vHour)\n    .replace(/mm/g, vMinute)\n    .replace(/ss/g, vSecond)\n    .replace(/SSS/g, vMillisecond)\n    .replace(/O/g, vTimeZone);\n  return formatted;\n\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-logger/node_modules/log4js/lib/levels.js":"\"use strict\";\n\nfunction Level(level, levelStr) {\n  this.level = level;\n  this.levelStr = levelStr;\n}\n\n/**\n * converts given String to corresponding Level\n * @param {String} sArg String value of Level OR Log4js.Level\n * @param {Log4js.Level} defaultLevel default Level, if no String representation\n * @return Level object\n * @type Log4js.Level\n */\nfunction toLevel(sArg, defaultLevel) {\n\n  if (!sArg) {\n    return defaultLevel;\n  }\n\n  if (typeof sArg == \"string\") {\n    var s = sArg.toUpperCase();\n    if (module.exports[s]) {\n      return module.exports[s];\n    } else {\n      return defaultLevel;\n    }\n  }\n\n  return toLevel(sArg.toString());\n}\n\nLevel.prototype.toString = function() {\n  return this.levelStr;\n};\n\nLevel.prototype.isLessThanOrEqualTo = function(otherLevel) {\n  if (typeof otherLevel === \"string\") {\n    otherLevel = toLevel(otherLevel);\n  }\n  return this.level <= otherLevel.level;\n};\n\nLevel.prototype.isGreaterThanOrEqualTo = function(otherLevel) {\n  if (typeof otherLevel === \"string\") {\n    otherLevel = toLevel(otherLevel);\n  }\n  return this.level >= otherLevel.level;\n};\n\nLevel.prototype.isEqualTo = function(otherLevel) {\n  if (typeof otherLevel == \"string\") {\n    otherLevel = toLevel(otherLevel);\n  }\n  return this.level === otherLevel.level;\n};\n\nmodule.exports = {\n  ALL: new Level(Number.MIN_VALUE, \"ALL\"), \n  TRACE: new Level(5000, \"TRACE\"), \n  DEBUG: new Level(10000, \"DEBUG\"), \n  INFO: new Level(20000, \"INFO\"), \n  WARN: new Level(30000, \"WARN\"), \n  ERROR: new Level(40000, \"ERROR\"), \n  FATAL: new Level(50000, \"FATAL\"), \n  OFF: new Level(Number.MAX_VALUE, \"OFF\"), \n  toLevel: toLevel\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-logger/node_modules/log4js/lib/logger.js":"\"use strict\";\nvar levels = require('./levels')\n, util = require('util')\n, events = require('events')\n, DEFAULT_CATEGORY = '[default]';\n\nvar logWritesEnabled = true;\n\n/**\n * Models a logging event.\n * @constructor\n * @param {String} categoryName name of category\n * @param {Log4js.Level} level level of message\n * @param {Array} data objects to log\n * @param {Log4js.Logger} logger the associated logger\n * @author Seth Chisamore\n */\nfunction LoggingEvent (categoryName, level, data, logger) {\n  this.startTime = new Date();\n  this.categoryName = categoryName;\n  this.data = data;\n  this.level = level;\n  this.logger = logger;\n}\n\n/**\n * Logger to log messages.\n * use {@see Log4js#getLogger(String)} to get an instance.\n * @constructor\n * @param name name of category to log to\n * @author Stephan Strittmatter\n */\nfunction Logger (name, level) {\n  this.category = name || DEFAULT_CATEGORY;\n  \n  if (level) {\n    this.setLevel(level);\n  }\n}\nutil.inherits(Logger, events.EventEmitter);\nLogger.DEFAULT_CATEGORY = DEFAULT_CATEGORY;\nLogger.prototype.level = levels.TRACE;\n\nLogger.prototype.setLevel = function(level) {\n  this.level = levels.toLevel(level, this.level || levels.TRACE);\n};\n\nLogger.prototype.removeLevel = function() {\n  delete this.level;\n};\n\nLogger.prototype.log = function() {\n  var args = Array.prototype.slice.call(arguments)\n  , logLevel = levels.toLevel(args.shift())\n  , loggingEvent;\n  if (this.isLevelEnabled(logLevel)) {\n    loggingEvent = new LoggingEvent(this.category, logLevel, args, this);\n    this.emit(\"log\", loggingEvent);\n  }\n};\n\nLogger.prototype.isLevelEnabled = function(otherLevel) {\n  return this.level.isLessThanOrEqualTo(otherLevel);\n};\n\n['Trace','Debug','Info','Warn','Error','Fatal'].forEach(\n  function(levelString) {\n    var level = levels.toLevel(levelString);\n    Logger.prototype['is'+levelString+'Enabled'] = function() {\n      return this.isLevelEnabled(level);\n    };\n    \n    Logger.prototype[levelString.toLowerCase()] = function () {\n      if (logWritesEnabled && this.isLevelEnabled(level)) {\n        var args = Array.prototype.slice.call(arguments);\n        args.unshift(level);\n        Logger.prototype.log.apply(this, args);\n      }\n    };\n  }\n);\n\n/**\n * Disable all log writes.\n * @returns {void}\n */\nfunction disableAllLogWrites() {\n  logWritesEnabled = false;\n}\n\n/**\n * Enable log writes.\n * @returns {void}\n */\nfunction enableAllLogWrites() {\n  logWritesEnabled = true;\n}\n\nexports.LoggingEvent = LoggingEvent;\nexports.Logger = Logger;\nexports.disableAllLogWrites = disableAllLogWrites;\nexports.enableAllLogWrites = enableAllLogWrites;\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-logger/node_modules/log4js/lib/connect-logger.js":"\"use strict\";\nvar levels = require(\"./levels\");\nvar DEFAULT_FORMAT = ':remote-addr - -' + \n  ' \":method :url HTTP/:http-version\"' + \n  ' :status :content-length \":referrer\"' + \n  ' \":user-agent\"';\n/**\n * Log requests with the given `options` or a `format` string.\n *\n * Options:\n *\n *   - `format`        Format string, see below for tokens\n *   - `level`         A log4js levels instance. Supports also 'auto'\n *\n * Tokens:\n *\n *   - `:req[header]` ex: `:req[Accept]`\n *   - `:res[header]` ex: `:res[Content-Length]`\n *   - `:http-version`\n *   - `:response-time`\n *   - `:remote-addr`\n *   - `:date`\n *   - `:method`\n *   - `:url`\n *   - `:referrer`\n *   - `:user-agent`\n *   - `:status`\n *\n * @param {String|Function|Object} format or options\n * @return {Function}\n * @api public\n */\n\nfunction getLogger(logger4js, options) {\n\tif ('object' == typeof options) {\n\t\toptions = options || {};\n\t} else if (options) {\n\t\toptions = { format: options };\n\t} else {\n\t\toptions = {};\n\t}\n\n\tvar thislogger = logger4js\n  , level = levels.toLevel(options.level, levels.INFO)\n  , fmt = options.format || DEFAULT_FORMAT\n  , nolog = options.nolog ? createNoLogCondition(options.nolog) : null;\n\n  return function (req, res, next) {\n    // mount safety\n    if (req._logging) return next();\n\n\t\t// nologs\n\t\tif (nolog && nolog.test(req.originalUrl)) return next();\n\t\tif (thislogger.isLevelEnabled(level) || options.level === 'auto') {\n      \n\t\t\tvar start = new Date()\n\t\t\t, statusCode\n\t\t\t, writeHead = res.writeHead\n\t\t\t, end = res.end\n\t\t\t, url = req.originalUrl;\n\n\t\t\t// flag as logging\n\t\t\treq._logging = true;\n      \n\t\t\t// proxy for statusCode.\n\t\t\tres.writeHead = function(code, headers){\n\t\t\t\tres.writeHead = writeHead;\n\t\t\t\tres.writeHead(code, headers);\n\t\t\t\tres.__statusCode = statusCode = code;\n\t\t\t\tres.__headers = headers || {};\n\n\t\t\t\t//status code response level handling\n\t\t\t\tif(options.level === 'auto'){\n\t\t\t\t\tlevel = levels.INFO;\n\t\t\t\t\tif(code >= 300) level = levels.WARN;\n\t\t\t\t\tif(code >= 400) level = levels.ERROR;\n\t\t\t\t} else {\n\t\t\t\t\tlevel = levels.toLevel(options.level, levels.INFO);\n\t\t\t\t}\n\t\t\t};\n      \n\t\t\t// proxy end to output a line to the provided logger.\n\t\t\tres.end = function(chunk, encoding) {\n\t\t\t\tres.end = end;\n\t\t\t\tres.end(chunk, encoding);\n\t\t\t\tres.responseTime = new Date() - start;\n\t\t\t\t//status code response level handling\n\t\t\t\tif(res.statusCode && options.level === 'auto'){\n\t\t\t\t\tlevel = levels.INFO;\n\t\t\t\t\tif(res.statusCode >= 300) level = levels.WARN;\n\t\t\t\t\tif(res.statusCode >= 400) level = levels.ERROR;\n\t\t\t\t}\n\t\t\t\tif (thislogger.isLevelEnabled(level)) {\n\t\t\t\t\tif (typeof fmt === 'function') {\n\t\t\t\t\t\tvar line = fmt(req, res, function(str){ return format(str, req, res); });\n\t\t\t\t\t\tif (line) thislogger.log(level, line);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthislogger.log(level, format(fmt, req, res));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n    \n    //ensure next gets always called\n    next();\n  };\n}\n\n/**\n * Return formatted log line.\n *\n * @param  {String} str\n * @param  {IncomingMessage} req\n * @param  {ServerResponse} res\n * @return {String}\n * @api private\n */\n\nfunction format(str, req, res) {\n\treturn str\n    .replace(':url', req.originalUrl)\n    .replace(':method', req.method)\n    .replace(':status', res.__statusCode || res.statusCode)\n    .replace(':response-time', res.responseTime)\n    .replace(':date', new Date().toUTCString())\n    .replace(':referrer', req.headers.referer || req.headers.referrer || '')\n    .replace(':http-version', req.httpVersionMajor + '.' + req.httpVersionMinor)\n    .replace(\n      ':remote-addr', req.ip || req._remoteAddress || ( \n      req.socket && \n        (req.socket.remoteAddress || (req.socket.socket && req.socket.socket.remoteAddress))\n    ))\n    .replace(':user-agent', req.headers['user-agent'] || '')\n    .replace(\n      ':content-length', \n      (res._headers && res._headers['content-length']) || \n        (res.__headers && res.__headers['Content-Length']) || \n        '-'\n    )\n    .replace(/:req\\[([^\\]]+)\\]/g, function(_, field){ return req.headers[field.toLowerCase()]; })\n    .replace(/:res\\[([^\\]]+)\\]/g, function(_, field){\n      return res._headers ? \n        (res._headers[field.toLowerCase()] || res.__headers[field])\n        : (res.__headers && res.__headers[field]);\n    });\n}\n\n/**\n * Return RegExp Object about nolog\n *\n * @param  {String} nolog\n * @return {RegExp}\n * @api private\n *\n * syntax\n *  1. String\n *   1.1 \"\\\\.gif\"\n *         NOT LOGGING http://example.com/hoge.gif and http://example.com/hoge.gif?fuga\n *         LOGGING http://example.com/hoge.agif\n *   1.2 in \"\\\\.gif|\\\\.jpg$\"\n *         NOT LOGGING http://example.com/hoge.gif and \n *           http://example.com/hoge.gif?fuga and http://example.com/hoge.jpg?fuga\n *         LOGGING http://example.com/hoge.agif, \n *           http://example.com/hoge.ajpg and http://example.com/hoge.jpg?hoge\n *   1.3 in \"\\\\.(gif|jpe?g|png)$\"\n *         NOT LOGGING http://example.com/hoge.gif and http://example.com/hoge.jpeg\n *         LOGGING http://example.com/hoge.gif?uid=2 and http://example.com/hoge.jpg?pid=3\n *  2. RegExp\n *   2.1 in /\\.(gif|jpe?g|png)$/\n *         SAME AS 1.3\n *  3. Array\n *   3.1 [\"\\\\.jpg$\", \"\\\\.png\", \"\\\\.gif\"]\n *         SAME AS \"\\\\.jpg|\\\\.png|\\\\.gif\"\n */\nfunction createNoLogCondition(nolog) {\n  var regexp = null;\n\n\tif (nolog) {\n    if (nolog instanceof RegExp) {\n      regexp = nolog;\n    } \n    \n    if (typeof nolog === 'string') {\n      regexp = new RegExp(nolog);\n    }\n    \n    if (Array.isArray(nolog)) {\n      var regexpsAsStrings = nolog.map(\n        function convertToStrings(o) { \n          return o.source ? o.source : o;\n        }\n      );\n      regexp = new RegExp(regexpsAsStrings.join('|'));\n    }\n  }\n\n  return regexp;\n}\n\nexports.connectLogger = getLogger;\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-logger/node_modules/log4js/lib/appenders/console.js":"\"use strict\";\nvar layouts = require('../layouts')\n, consoleLog = console.log.bind(console);\n\nfunction consoleAppender (layout) {\n  layout = layout || layouts.colouredLayout;\n  return function(loggingEvent) {\n    consoleLog(layout(loggingEvent));\n  };\n}\n\nfunction configure(config) {\n  var layout;\n  if (config.layout) {\n    layout = layouts.layout(config.layout.type, config.layout);\n  }\n  return consoleAppender(layout);\n}\n\nexports.appender = consoleAppender;\nexports.configure = configure;\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/util/constants.js":"module.exports = {\n  KEYWORDS: {\n    BEFORE_FILTER: '__befores__',\n    AFTER_FILTER: '__afters__',\n    GLOBAL_BEFORE_FILTER: '__globalBefores__',\n    GLOBAL_AFTER_FILTER: '__globalAfters__',\n    ROUTE: '__routes__',\n    BEFORE_STOP_HOOK: '__beforeStopHook__',\n    MODULE: '__modules__',\n    SERVER_MAP: '__serverMap__',\n    RPC_BEFORE_FILTER: '__rpcBefores__',\n    RPC_AFTER_FILTER: '__rpcAfters__',\n    MASTER_WATCHER: '__masterwatcher__',\n    MONITOR_WATCHER: '__monitorwatcher__'\n },\n\n  FILEPATH: {\n    MASTER: '/config/master.json',\n    SERVER: '/config/servers.json',\n    CRON: '/config/crons.json',\n    LOG: '/config/log4js.json',\n    SERVER_PROTOS: '/config/serverProtos.json',\n    CLIENT_PROTOS: '/config/clientProtos.json',\n    MASTER_HA: '/config/masterha.json',\n    LIFECYCLE: '/lifecycle.js',\n    SERVER_DIR: '/app/servers/',\n    CONFIG_DIR: '/config'\n  },\n\n  DIR: {\n    HANDLER: 'handler',\n    REMOTE: 'remote',\n    CRON: 'cron',\n    LOG: 'logs',\n    SCRIPT: 'scripts',\n    EVENT: 'events',\n    COMPONENT: 'components'\n  },\n\n  RESERVED: {\n    BASE: 'base',\n    MAIN: 'main',\n    MASTER: 'master',\n    SERVERS: 'servers',\n    ENV: 'env',\n    CPU: 'cpu',\n    ENV_DEV: 'development',\n    ENV_PRO: 'production',\n    ALL: 'all',\n    SERVER_TYPE: 'serverType',\n    SERVER_ID: 'serverId',\n    CURRENT_SERVER: 'curServer',\n    MODE: 'mode',\n    TYPE: 'type',\n    CLUSTER: 'clusters',\n    STAND_ALONE: 'stand-alone',\n    START: 'start',\n    AFTER_START: 'afterStart',\n    CRONS: 'crons',\n    ERROR_HANDLER: 'errorHandler',\n    GLOBAL_ERROR_HANDLER: 'globalErrorHandler',\n    AUTO_RESTART: 'auto-restart',\n    RESTART_FORCE: 'restart-force',\n    CLUSTER_COUNT: 'clusterCount',\n    CLUSTER_PREFIX: 'cluster-server-',\n    CLUSTER_SIGNAL: '++',\n    RPC_ERROR_HANDLER: 'rpcErrorHandler',\n    SERVER: 'server',\n    CLIENT: 'client',\n    STARTID: 'startId',\n    STOP_SERVERS: 'stop_servers',\n    SSH_CONFIG_PARAMS: 'ssh_config_params'\n  },\n\n  COMMAND: {\n    TASKSET: 'taskset',\n    KILL: 'kill',\n    TASKKILL: 'taskkill',\n    SSH: 'ssh'\n  },\n\n  PLATFORM: {\n    WIN: 'win32',\n    LINUX: 'linux'\n  },\n\n  LIFECYCLE: {\n    BEFORE_STARTUP: 'beforeStartup',\n    BEFORE_SHUTDOWN: 'beforeShutdown',\n    AFTER_STARTUP: 'afterStartup',\n    AFTER_STARTALL: 'afterStartAll'\n  },\n\n  SIGNAL: {\n    FAIL: 0,\n    OK: 1\n  },\n\n TIME: {\n   TIME_WAIT_STOP: 3 * 1000,\n   TIME_WAIT_KILL: 5 * 1000,\n   TIME_WAIT_RESTART: 5 * 1000,\n   TIME_WAIT_COUNTDOWN: 10 * 1000,\n   TIME_WAIT_MASTER_KILL: 2 * 60 * 1000,\n   TIME_WAIT_MONITOR_KILL: 2 * 1000,\n   TIME_WAIT_PING: 30 * 1000,\n   TIME_WAIT_MAX_PING: 5 * 60 * 1000,\n   DEFAULT_UDP_HEARTBEAT_TIME: 20 * 1000,\n   DEFAULT_UDP_HEARTBEAT_TIMEOUT: 100 * 1000,\n   DEFAULT_MQTT_HEARTBEAT_TIMEOUT: 90 * 1000\n }\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/util/events.js":"module.exports = {\n\tADD_SERVERS: 'add_servers',\n\tREMOVE_SERVERS: 'remove_servers',\n  REPLACE_SERVERS: 'replace_servers',\n  BIND_SESSION: 'bind_session',\n  UNBIND_SESSION:'unbind_session',\n\tCLOSE_SESSION: 'close_session',\n\tADD_CRONS: 'add_crons',\n\tREMOVE_CRONS: 'remove_crons',\n\tSTART_SERVER: 'start_server',\n\tSTART_ALL: 'start_all'\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/util/appUtil.js":"var async = require('async');\nvar log = require('./log');\nvar utils = require('./utils');\nvar path = require('path');\nvar fs = require('fs');\nvar Constants = require('./constants');\nvar starter = require('../master/starter');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\n\n/**\n * Initialize application configuration.\n */\nmodule.exports.defaultConfiguration = function(app) {\n  var args = parseArgs(process.argv);\n  setupEnv(app, args);\n  loadMaster(app);\n  loadServers(app);\n  processArgs(app, args);\n  configLogger(app);\n  loadLifecycle(app);\n};\n\n/**\n * Start servers by type.\n */\nmodule.exports.startByType = function(app, cb) {\n  if(!!app.startId) {\n    if(app.startId === Constants.RESERVED.MASTER) {\n      utils.invokeCallback(cb);\n    } else {\n      starter.runServers(app);\n    }\n  } else {\n    if(!!app.type && app.type !== Constants.RESERVED.ALL && app.type !== Constants.RESERVED.MASTER) {\n      starter.runServers(app);\n    } else {\n      utils.invokeCallback(cb);\n    }\n  }\n};\n\n/**\n * Load default components for application.\n */\nmodule.exports.loadDefaultComponents = function(app) {\n  var pomelo = require('../pomelo');\n  // load system default components\n  if (app.serverType === Constants.RESERVED.MASTER) {\n    app.load(pomelo.master, app.get('masterConfig'));\n  } else {\n    app.load(pomelo.proxy, app.get('proxyConfig'));\n    if (app.getCurServer().port) {\n      app.load(pomelo.remote, app.get('remoteConfig'));\n    }\n    if (app.isFrontend()) {\n      app.load(pomelo.connection, app.get('connectionConfig'));\n      app.load(pomelo.connector, app.get('connectorConfig'));\n      app.load(pomelo.session, app.get('sessionConfig'));\n      // compatible for schedulerConfig\n      if(app.get('schedulerConfig')) {\n        app.load(pomelo.pushScheduler, app.get('schedulerConfig'));\n      } else {\n        app.load(pomelo.pushScheduler, app.get('pushSchedulerConfig'));\n      }\n    }\n    app.load(pomelo.backendSession, app.get('backendSessionConfig'));\n    app.load(pomelo.channel, app.get('channelConfig'));\n    app.load(pomelo.server, app.get('serverConfig'));\n  }\n  app.load(pomelo.monitor, app.get('monitorConfig'));\n};\n\n/**\n * Stop components.\n *\n * @param  {Array}  comps component list\n * @param  {Number}   index current component index\n * @param  {Boolean}  force whether stop component immediately\n * @param  {Function} cb\n */\nmodule.exports.stopComps = function(comps, index, force, cb) {\n  if (index >= comps.length) {\n    utils.invokeCallback(cb);\n    return;\n  }\n  var comp = comps[index];\n  if (typeof comp.stop === 'function') {\n    comp.stop(force, function() {\n      // ignore any error\n      module.exports.stopComps(comps, index + 1, force, cb);\n    });\n  } else {\n    module.exports.stopComps(comps, index + 1, force, cb);\n  }\n};\n\n/**\n * Apply command to loaded components.\n * This method would invoke the component {method} in series.\n * Any component {method} return err, it would return err directly.\n *\n * @param {Array} comps loaded component list\n * @param {String} method component lifecycle method name, such as: start, stop\n * @param {Function} cb\n */\nmodule.exports.optComponents = function(comps, method, cb) {\n  var i = 0;\n  async.forEachSeries(comps, function(comp, done) {\n    i++;\n    if (typeof comp[method] === 'function') {\n      comp[method](done);\n    } else {\n      done();\n    }\n  }, function(err) {\n    if (err) {\n      if(typeof err === 'string') {\n        logger.error('fail to operate component, method: %s, err: %j', method, err);\n      } else {\n        logger.error('fail to operate component, method: %s, err: %j',  method, err.stack);\n      }\n    }\n    utils.invokeCallback(cb, err);\n  });\n};\n\n/**\n * Load server info from config/servers.json.\n */\nvar loadServers = function(app) {\n  app.loadConfigBaseApp(Constants.RESERVED.SERVERS, Constants.FILEPATH.SERVER);\n  var servers = app.get(Constants.RESERVED.SERVERS);\n  var serverMap = {}, slist, i, l, server;\n  for (var serverType in servers) {\n    slist = servers[serverType];\n    for (i = 0, l = slist.length; i < l; i++) {\n      server = slist[i];\n      server.serverType = serverType;\n      if(server[Constants.RESERVED.CLUSTER_COUNT]) {\n        utils.loadCluster(app, server, serverMap);\n        continue;\n      }\n      serverMap[server.id] = server;\n      if (server.wsPort) {\n        logger.warn('wsPort is deprecated, use clientPort in frontend server instead, server: %j', server);\n      }\n    }\n  }\n  app.set(Constants.KEYWORDS.SERVER_MAP, serverMap);\n};\n\n/**\n * Load master info from config/master.json.\n */\nvar loadMaster = function(app) {\n  app.loadConfigBaseApp(Constants.RESERVED.MASTER, Constants.FILEPATH.MASTER);\n  app.master = app.get(Constants.RESERVED.MASTER);\n};\n\n/**\n * Process server start command\n */\nvar processArgs = function(app, args) {\n  var serverType = args.serverType || Constants.RESERVED.MASTER;\n  var serverId = args.id || app.getMaster().id;\n  var mode = args.mode || Constants.RESERVED.CLUSTER;\n  var masterha = args.masterha || 'false';\n  var type = args.type || Constants.RESERVED.ALL;\n  var startId = args.startId;\n\n  app.set(Constants.RESERVED.MAIN, args.main, true);\n  app.set(Constants.RESERVED.SERVER_TYPE, serverType, true);\n  app.set(Constants.RESERVED.SERVER_ID, serverId, true);\n  app.set(Constants.RESERVED.MODE, mode, true);\n  app.set(Constants.RESERVED.TYPE, type, true);\n  if(!!startId) {\n    app.set(Constants.RESERVED.STARTID, startId, true);\n  }\n\n  if (masterha === 'true') {\n    app.master = args;\n    app.set(Constants.RESERVED.CURRENT_SERVER, args, true);\n  } else if (serverType !== Constants.RESERVED.MASTER) {\n    app.set(Constants.RESERVED.CURRENT_SERVER, args, true);\n  } else {\n    app.set(Constants.RESERVED.CURRENT_SERVER, app.getMaster(), true);\n  }\n};\n\n/**\n * Setup enviroment.\n */\nvar setupEnv = function(app, args) {\n  app.set(Constants.RESERVED.ENV, args.env || process.env.NODE_ENV || Constants.RESERVED.ENV_DEV, true);\n};\n\n/**\n * Configure custom logger.\n */\nvar configLogger = function(app) {\n  if (process.env.POMELO_LOGGER !== 'off') {\n    var env = app.get(Constants.RESERVED.ENV);\n    var originPath = path.join(app.getBase(), Constants.FILEPATH.LOG);\n    var presentPath = path.join(app.getBase(), Constants.FILEPATH.CONFIG_DIR, env, path.basename(Constants.FILEPATH.LOG));\n    if(fs.existsSync(originPath)) {\n      log.configure(app, originPath);\n    } else if(fs.existsSync(presentPath)) {\n      log.configure(app, presentPath);\n    } else {\n      logger.error('logger file path configuration is error.');\n    }\n  }\n};\n\n/**\n * Parse command line arguments.\n *\n * @param args command line arguments\n *\n * @return Object argsMap map of arguments\n */\nvar parseArgs = function(args) {\n  var argsMap = {};\n  var mainPos = 1;\n\n  while (args[mainPos].indexOf('--') > 0) {\n    mainPos++;\n  }\n  argsMap.main = args[mainPos];\n\n  for (var i = (mainPos + 1); i < args.length; i++) {\n    var arg = args[i];\n    var sep = arg.indexOf('=');\n    var key = arg.slice(0, sep);\n    var value = arg.slice(sep + 1);\n    if (!isNaN(Number(value)) && (value.indexOf('.') < 0)) {\n      value = Number(value);\n    }\n    argsMap[key] = value;\n  }\n\n  return argsMap;\n};\n\n/**\n * Load lifecycle file.\n *\n */\nvar loadLifecycle = function(app) {\n  var filePath = path.join(app.getBase(), Constants.FILEPATH.SERVER_DIR, app.serverType, Constants.FILEPATH.LIFECYCLE);\n  if(!fs.existsSync(filePath)) {\n    return;\n  }\n  var lifecycle = require(filePath);\n  for(var key in lifecycle) {\n    if(typeof lifecycle[key] === 'function') {\n      app.lifecycleCbs[key] = lifecycle[key];\n    } else {\n      logger.warn('lifecycle.js in %s is error format.', filePath);\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/util/log.js":"var logger = require('pomelo-logger');\n\n/**\n * Configure pomelo logger\n */\nmodule.exports.configure = function(app, filename) {\n  var serverId = app.getServerId();\n  var base = app.getBase();\n  logger.configure(filename, {serverId: serverId, base: base});\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/master/starter.js":"var cp = require('child_process');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar starter = module.exports;\nvar util = require('util');\nvar utils = require('../util/utils');\nvar Constants = require('../util/constants');\nvar env = Constants.RESERVED.ENV_DEV;\nvar os=require('os');\nvar cpus = {};\nvar pomelo = require('../pomelo');\n\n/**\n * Run all servers\n *\n * @param {Object} app current application  context\n * @return {Void}\n */\n starter.runServers = function(app) {\n  var server, servers;\n  var condition = app.startId || app.type;\n  switch(condition) {\n    case Constants.RESERVED.MASTER:\n    break;\n    case Constants.RESERVED.ALL:\n    servers = app.getServersFromConfig();\n    for (var serverId in servers) {\n      this.run(app, servers[serverId]);\n    }\n    break;\n    default:\n    server = app.getServerFromConfig(condition);\n    if(!!server) {\n      this.run(app, server);\n    } else {\n      servers = app.get(Constants.RESERVED.SERVERS)[condition];\n      for(var i=0; i<servers.length; i++) {\n        this.run(app, servers[i]);\n      }\n    }\n  }\n};\n\n/**\n * Run server\n *\n * @param {Object} app current application context\n * @param {Object} server\n * @return {Void}\n */\nstarter.run = function(app, server, cb) {\n  env = app.get(Constants.RESERVED.ENV);\n  var cmd, key;\n  if (utils.isLocal(server.host)) {\n    var options = [];\n    if (!!server.args) {\n      if(typeof server.args === 'string') {\n        options.push(server.args.trim());\n      } else {\n        options = options.concat(server.args);\n      }\n    }\n    cmd = app.get(Constants.RESERVED.MAIN);\n    options.push(cmd);\n    options.push(util.format('env=%s',  env));\n    for(key in server) {\n      if(key === Constants.RESERVED.CPU) {\n        cpus[server.id] = server[key];\n      }\n      options.push(util.format('%s=%s', key, server[key]));\n    }\n    starter.localrun(process.execPath, null, options, cb);\n  } else {\n    cmd = util.format('cd \"%s\" && \"%s\"', app.getBase(), process.execPath);\n    var arg = server.args;\n    if (arg !== undefined) {\n      cmd += arg;\n    }\n    cmd += util.format(' \"%s\" env=%s ', app.get(Constants.RESERVED.MAIN), env);\n    for(key in server) {\n      if(key === Constants.RESERVED.CPU) {\n        cpus[server.id] = server[key];\n      }\n      cmd += util.format(' %s=%s ', key, server[key]);\n    }\n    starter.sshrun(cmd, server.host, cb);\n  }\n};\n\n/**\n * Bind process with cpu\n *\n * @param {String} sid server id\n * @param {String} pid process id\n * @param {String} host server host\n * @return {Void}\n */\nstarter.bindCpu = function(sid, pid, host) {\n  if(os.platform() === Constants.PLATFORM.LINUX && cpus[sid] !== undefined) {\n    if (utils.isLocal(host)) {\n      var options = [];\n      options.push('-pc');\n      options.push(cpus[sid]);\n      options.push(pid);\n      starter.localrun(Constants.COMMAND.TASKSET, null, options);\n    }\n    else {\n      var cmd = util.format('taskset -pc \"%s\" \"%s\"', cpus[sid], pid);\n      starter.sshrun(cmd, host, null);\n    }\n  }\n};\n\n/**\n * Kill application in all servers\n *\n * @param {String} pids  array of server's pid\n * @param {String} serverIds array of serverId\n */\nstarter.kill = function(pids, servers) {\n  var cmd;\n  for(var i = 0; i < servers.length; i++) {\n    var server = servers[i];\n    if(utils.isLocal(server.host)) {\n      var options = [];\n      if(os.platform() === Constants.PLATFORM.WIN) {\n        cmd = Constants.COMMAND.TASKKILL;\n        options.push('/pid');\n        options.push('/f');\n      } else {\n        cmd = Constants.COMMAND.KILL;\n        options.push(-9);\n      }\n      options.push(pids[i]);\n      starter.localrun(cmd,null,options);\n    } else {\n      if(os.platform() === Constants.PLATFORM.WIN) {\n        cmd = util.format('taskkill /pid %s /f', pids[i]);\n      } else {\n        cmd = util.format('kill -9 %s', pids[i]);\n      }\n      starter.sshrun(cmd, server.host);\n    }\n  }\n};\n\n/**\n * Use ssh to run command.\n *\n * @param {String} cmd command that would be executed in the remote server\n * @param {String} host remote server host\n * @param {Function} cb callback function\n *\n */\nstarter.sshrun = function(cmd, host, cb) {\n  var args = [];\n  args.push(host);\n  var ssh_params = pomelo.app.get(Constants.RESERVED.SSH_CONFIG_PARAMS);\n  if(!!ssh_params && Array.isArray(ssh_params)) {\n    args = args.concat(ssh_params);\n  }\n  args.push(cmd);\n\n  logger.info('Executing ' + cmd + ' on ' + host + ':22');\n  spawnProcess(Constants.COMMAND.SSH, host, args, cb);\n  return;\n};\n\n/**\n * Run local command.\n *\n * @param {String} cmd\n * @param {Callback} callback\n *\n */\nstarter.localrun = function (cmd, host, options, callback) {\n  logger.info('Executing ' + cmd + ' ' + options + ' locally');\n  spawnProcess(cmd, host, options, callback);\n};\n\n/**\n * Fork child process to run command.\n *\n * @param {String} command\n * @param {Object} options\n * @param {Callback} callback\n *\n */\nvar spawnProcess = function(command, host, options, cb) {\n  var child = null;\n\n  if(env === Constants.RESERVED.ENV_DEV) {\n    child = cp.spawn(command, options);\n    var prefix = command === Constants.COMMAND.SSH ? '[' + host + '] ' : '';\n\n    child.stderr.on('data', function (chunk) {\n      var msg = chunk.toString();\n      process.stderr.write(msg);\n      if(!!cb) {\n        cb(msg);\n      }\n    });\n\n    child.stdout.on('data', function (chunk) {\n      var msg = prefix + chunk.toString();\n      process.stdout.write(msg);\n    });\n  } else {\n    child = cp.spawn(command, options, {detached: true, stdio: 'inherit'});\n    child.unref();\n  }\n\n  child.on('exit', function (code) {\n    if(code !== 0) {\n      logger.warn('child process exit with error, error code: %s, executed command: %s', code,  command);\n    }\n    if (typeof cb === 'function') {\n      cb(code === 0 ? null : code);\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/common/manager/appManager.js":"var async = require('async');\nvar utils = require('../../util/utils');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar transactionLogger = require('pomelo-logger').getLogger('transaction-log', __filename);\nvar transactionErrorLogger = require('pomelo-logger').getLogger('transaction-error-log', __filename);\n\nvar manager = module.exports;\n\nmanager.transaction = function(name, conditions, handlers, retry) {\n\tif(!retry) {\n    retry = 1;\n  }\n  if(typeof name !== 'string') {\n    logger.error('transaction name is error format, name: %s.', name);\n    return;\n  }\n  if(typeof conditions !== 'object' || typeof handlers !== 'object') {\n    logger.error('transaction conditions parameter is error format, conditions: %j, handlers: %j.', conditions, handlers);\n    return;\n  }\n\n  var cmethods=[] ,dmethods=[], cnames=[], dnames=[];\n  for(var key in conditions) {\n    if(typeof key !== 'string' || typeof conditions[key] !== 'function') {\n      logger.error('transaction conditions parameter is error format, condition name: %s, condition function: %j.', key, conditions[key]);\n      return;\n    }\n    cnames.push(key);\n    cmethods.push(conditions[key]);\n  }\n\n  var i = 0;\n  // execute conditions\n  async.forEachSeries(cmethods, function(method, cb) {\n    method(cb);\n    transactionLogger.info('[%s]:[%s] condition is executed.', name, cnames[i]);\n    i++;\n  }, function(err) {\n    if(err) {\n      process.nextTick(function() {\n        transactionLogger.error('[%s]:[%s] condition is executed with err: %j.', name, cnames[--i], err.stack);\n        var log = {\n          name: name,\n          method: cnames[i],\n          time: Date.now(),\n          type: 'condition',\n          description: err.stack\n        };\n        transactionErrorLogger.error(JSON.stringify(log));\n      });\n      return;\n    } else {\n      // execute handlers\n      process.nextTick(function() {\n        for(var key in handlers) {\n          if(typeof key !== 'string' || typeof handlers[key] !== 'function') {\n            logger.error('transcation handlers parameter is error format, handler name: %s, handler function: %j.', key, handlers[key]);\n            return;\n          }\n          dnames.push(key);\n          dmethods.push(handlers[key]);\n        }\n\n        var flag = true;\n        var times = retry;\n        \n        // do retry if failed util retry times\n        async.whilst(\n          function() {\n            return retry > 0 && flag;\n          },\n          function(callback) {\n            var j = 0;\n            retry--;\n            async.forEachSeries(dmethods, function(method, cb) {\n              method(cb);\n              transactionLogger.info('[%s]:[%s] handler is executed.', name, dnames[j]);\n              j++;\n            }, function(err) {\n              if(err) {\n                process.nextTick(function() {\n                  transactionLogger.error('[%s]:[%s]:[%s] handler is executed with err: %j.', name, dnames[--j], times-retry, err.stack);\n                  var log = {\n                    name: name,\n                    method: dnames[j],\n                    retry: times-retry,\n                    time: Date.now(),\n                    type: 'handler',\n                    description: err.stack\n                  };\n                  transactionErrorLogger.error(JSON.stringify(log));\n                  utils.invokeCallback(callback);\n                });\n                return;\n              }\n              flag = false;\n              utils.invokeCallback(callback);\n              process.nextTick(function() {\n                transactionLogger.info('[%s] all conditions and handlers are executed successfully.', name);\n              });\n            });\n          },\n          function(err) {\n            if(err) {\n              logger.error('transaction process is executed with error: %j', err);\n            }\n            // callback will not pass error\n          }\n        );\n      });\n    }\n  });\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/components/backendSession.js":"var BackendSessionService = require('../common/service/backendSessionService');\n\nmodule.exports = function(app) {\n  var service = new BackendSessionService(app);\n  service.name = '__backendSession__';\n  // export backend session service to the application context.\n  app.set('backendSessionService', service, true);\n\n  // for compatibility as `LocalSession` is renamed to `BackendSession` \n  app.set('localSessionService', service, true);\n\n  return service;\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/common/service/backendSessionService.js":"/**\n * backend session service for backend session\n */\nvar utils = require('../../util/utils');\n\nvar EXPORTED_FIELDS = ['id', 'frontendId', 'uid', 'settings'];\n\n/**\n * Service that maintains backend sessions and the communication with frontend\n * servers.\n *\n * BackendSessionService would be created in each server process and maintains\n * backend sessions for current process and communicates with the relative\n * frontend servers.\n *\n * BackendSessionService instance could be accessed by\n * `app.get('backendSessionService')` or app.backendSessionService.\n *\n * @class\n * @constructor\n */\nvar BackendSessionService = function(app) {\n  this.app = app;\n};\n\nmodule.exports = BackendSessionService;\n\nBackendSessionService.prototype.create = function(opts) {\n  if(!opts) {\n    throw new Error('opts should not be empty.');\n  }\n  return new BackendSession(opts, this);\n};\n\n/**\n * Get backend session by frontend server id and session id.\n *\n * @param  {String}   frontendId frontend server id that session attached\n * @param  {String}   sid        session id\n * @param  {Function} cb         callback function. args: cb(err, BackendSession)\n *\n * @memberOf BackendSessionService\n */\nBackendSessionService.prototype.get = function(frontendId, sid, cb) {\n  var namespace = 'sys';\n  var service = 'sessionRemote';\n  var method = 'getBackendSessionBySid';\n  var args = [sid];\n  rpcInvoke(this.app, frontendId, namespace, service, method,\n            args, BackendSessionCB.bind(null, this, cb));\n};\n\n/**\n * Get backend sessions by frontend server id and user id.\n *\n * @param  {String}   frontendId frontend server id that session attached\n * @param  {String}   uid        user id binded with the session\n * @param  {Function} cb         callback function. args: cb(err, BackendSessions)\n *\n * @memberOf BackendSessionService\n */\nBackendSessionService.prototype.getByUid = function(frontendId, uid, cb) {\n  var namespace = 'sys';\n  var service = 'sessionRemote';\n  var method = 'getBackendSessionsByUid';\n  var args = [uid];\n  rpcInvoke(this.app, frontendId, namespace, service, method,\n            args, BackendSessionCB.bind(null, this, cb));\n};\n\n/**\n * Kick a session by session id.\n *\n * @param  {String}   frontendId cooperating frontend server id\n * @param  {Number}   sid        session id\n * @param  {Function} cb         callback function\n *\n * @memberOf BackendSessionService\n */\nBackendSessionService.prototype.kickBySid = function(frontendId, sid, reason, cb) {\n  var namespace = 'sys';\n  var service = 'sessionRemote';\n  var method = 'kickBySid';\n  var args = [sid];\n  if(typeof reason === 'function') {\n    cb = reason;\n  }else{\n    args.push(reason);\n  }\n  rpcInvoke(this.app, frontendId, namespace, service, method, args, cb);\n};\n\n/**\n * Kick sessions by user id.\n *\n * @param  {String}          frontendId cooperating frontend server id\n * @param  {Number|String}   uid        user id\n * @param  {String}          reason     kick reason\n * @param  {Function}        cb         callback function\n *\n * @memberOf BackendSessionService\n */\nBackendSessionService.prototype.kickByUid = function(frontendId, uid, reason, cb) {\n  var namespace = 'sys';\n  var service = 'sessionRemote';\n  var method = 'kickByUid';\n  var args = [uid];\n  if(typeof reason === 'function') {\n    cb = reason;\n  }else{\n    args.push(reason);\n  }\n  rpcInvoke(this.app, frontendId, namespace, service, method, args, cb);\n};\n\n/**\n * Bind the session with the specified user id. It would finally invoke the\n * the sessionService.bind in the cooperating frontend server.\n *\n * @param  {String}   frontendId cooperating frontend server id\n * @param  {Number}   sid        session id\n * @param  {String}   uid        user id\n * @param  {Function} cb         callback function\n *\n * @memberOf BackendSessionService\n * @api private\n */\nBackendSessionService.prototype.bind = function(frontendId, sid, uid, cb) {\n  var namespace = 'sys';\n  var service = 'sessionRemote';\n  var method = 'bind';\n  var args = [sid, uid];\n  rpcInvoke(this.app, frontendId, namespace, service, method, args, cb);\n};\n\n/**\n * Unbind the session with the specified user id. It would finally invoke the\n * the sessionService.unbind in the cooperating frontend server.\n *\n * @param  {String}   frontendId cooperating frontend server id\n * @param  {Number}   sid        session id\n * @param  {String}   uid        user id\n * @param  {Function} cb         callback function\n *\n * @memberOf BackendSessionService\n * @api private\n */\nBackendSessionService.prototype.unbind = function(frontendId, sid, uid, cb) {\n  var namespace = 'sys';\n  var service = 'sessionRemote';\n  var method = 'unbind';\n  var args = [sid, uid];\n  rpcInvoke(this.app, frontendId, namespace, service, method, args, cb);\n};\n\n/**\n * Push the specified customized change to the frontend internal session.\n *\n * @param  {String}   frontendId cooperating frontend server id\n * @param  {Number}   sid        session id\n * @param  {String}   key        key in session that should be push\n * @param  {Object}   value      value in session, primitive js object\n * @param  {Function} cb         callback function\n *\n * @memberOf BackendSessionService\n * @api private\n */\nBackendSessionService.prototype.push = function(frontendId, sid, key, value, cb) {\n  var namespace = 'sys';\n  var service = 'sessionRemote';\n  var method = 'push';\n  var args = [sid, key, value];\n  rpcInvoke(this.app, frontendId, namespace, service, method, args, cb);\n};\n\n/**\n * Push all the customized changes to the frontend internal session.\n *\n * @param  {String}   frontendId cooperating frontend server id\n * @param  {Number}   sid        session id\n * @param  {Object}   settings   key/values in session that should be push\n * @param  {Function} cb         callback function\n *\n * @memberOf BackendSessionService\n * @api private\n */\nBackendSessionService.prototype.pushAll = function(frontendId, sid, settings, cb) {\n  var namespace = 'sys';\n  var service = 'sessionRemote';\n  var method = 'pushAll';\n  var args = [sid, settings];\n  rpcInvoke(this.app, frontendId, namespace, service, method, args, cb);\n};\n\nvar rpcInvoke = function(app, sid, namespace, service, method, args, cb) {\n  app.rpcInvoke(sid, {namespace: namespace, service: service, method: method, args: args}, cb);\n};\n\n/**\n * BackendSession is the proxy for the frontend internal session passed to handlers and\n * it helps to keep the key/value pairs for the server locally.\n * Internal session locates in frontend server and should not be accessed directly.\n *\n * The mainly operation on backend session should be read and any changes happen in backend\n * session is local and would be discarded in next request. You have to push the\n * changes to the frontend manually if necessary. Any push would overwrite the last push\n * of the same key silently and the changes would be saw in next request.\n * And you have to make sure the transaction outside if you would push the session\n * concurrently in different processes.\n *\n * See the api below for more details.\n *\n * @class\n * @constructor\n */\nvar BackendSession = function(opts, service) {\n  for(var f in opts) {\n    this[f] = opts[f];\n  }\n  this.__sessionService__ = service;\n};\n\n/**\n * Bind current session with the user id. It would push the uid to frontend\n * server and bind  uid to the frontend internal session.\n *\n * @param  {Number|String}   uid user id\n * @param  {Function} cb  callback function\n *\n * @memberOf BackendSession\n */\nBackendSession.prototype.bind = function(uid, cb) {\n  var self = this;\n  this.__sessionService__.bind(this.frontendId, this.id, uid, function(err) {\n    if(!err) {\n      self.uid = uid;\n    }\n    utils.invokeCallback(cb, err);\n  });\n};\n\n/**\n * Unbind current session with the user id. It would push the uid to frontend\n * server and unbind uid from the frontend internal session.\n *\n * @param  {Number|String}   uid user id\n * @param  {Function} cb  callback function\n *\n * @memberOf BackendSession\n */\nBackendSession.prototype.unbind = function(uid, cb) {\n  var self = this;\n  this.__sessionService__.unbind(this.frontendId, this.id, uid, function(err) {\n    if(!err) {\n      self.uid = null;\n    }\n    utils.invokeCallback(cb, err);\n  });\n};\n\n/**\n * Set the key/value into backend session.\n *\n * @param {String} key   key\n * @param {Object} value value\n */\nBackendSession.prototype.set = function(key, value) {\n  this.settings[key] = value;\n};\n\n/**\n * Get the value from backend session by key.\n *\n * @param  {String} key key\n * @return {Object}     value\n */\nBackendSession.prototype.get = function(key) {\n  return this.settings[key];\n};\n\n/**\n * Push the key/value in backend session to the front internal session.\n *\n * @param  {String}   key key\n * @param  {Function} cb  callback function\n */\nBackendSession.prototype.push = function(key, cb) {\n  this.__sessionService__.push(this.frontendId, this.id, key, this.get(key), cb);\n};\n\n/**\n * Push all the key/values in backend session to the frontend internal session.\n *\n * @param  {Function} cb callback function\n */\nBackendSession.prototype.pushAll = function(cb) {\n  this.__sessionService__.pushAll(this.frontendId, this.id, this.settings, cb);\n};\n\n/**\n * Export the key/values for serialization.\n *\n * @api private\n */\nBackendSession.prototype.export = function() {\n  var res = {};\n  EXPORTED_FIELDS.forEach(function(field) {\n    res[field] = this[field];\n  });\n  return res;\n};\n\nvar BackendSessionCB = function(service, cb, err, sinfo) {\n  if(err) {\n    utils.invokeCallback(cb, err);\n    return;\n  }\n\n  if(!sinfo) {\n    utils.invokeCallback(cb);\n    return;\n  }\n  var sessions = [];\n  if(Array.isArray(sinfo)){\n      // #getByUid\n      for(var i = 0,k = sinfo.length;i<k;i++){\n          sessions.push(service.create(sinfo[i]));\n      }\n  }\n  else{\n      // #get\n      sessions = service.create(sinfo);\n  }\n  utils.invokeCallback(cb, null, sessions);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/components/channel.js":"var ChannelService = require('../common/service/channelService');\n\nmodule.exports = function(app, opts) {\n  var service = new ChannelService(app, opts);\n  app.set('channelService', service, true);\n  service.name = '__channel__';\n  return service;\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/common/service/channelService.js":"var countDownLatch = require('../../util/countDownLatch');\nvar utils = require('../../util/utils');\nvar ChannelRemote = require('../remote/frontend/channelRemote');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\n\n/**\n * constant\n */\nvar ST_INITED = 0;\nvar ST_DESTROYED = 1;\n\n/**\n * Create and maintain channels for server local.\n *\n * ChannelService is created by channel component which is a default loaded\n * component of pomelo and channel service would be accessed by `app.get('channelService')`.\n *\n * @class\n * @constructor\n */\nvar ChannelService = function(app, opts) {\n  opts = opts || {};\n  this.app = app;\n  this.channels = {};\n  this.prefix = opts.prefix;\n  this.store = opts.store;\n  this.broadcastFilter = opts.broadcastFilter;\n  this.channelRemote = new ChannelRemote(app);\n};\n\nmodule.exports = ChannelService;\n\n\nChannelService.prototype.start = function(cb) {\n  restoreChannel(this, cb);\n};\n\n\n\n/**\n * Create channel with name.\n *\n * @param {String} name channel's name\n * @memberOf ChannelService\n */\nChannelService.prototype.createChannel = function(name) {\n  if(this.channels[name]) {\n    return this.channels[name];\n  }\n\n  var c = new Channel(name, this);\n  addToStore(this, genKey(this), genKey(this, name));\n  this.channels[name] = c;\n  return c;\n};\n\n/**\n * Get channel by name.\n *\n * @param {String} name channel's name\n * @param {Boolean} create if true, create channel\n * @return {Channel}\n * @memberOf ChannelService\n */\nChannelService.prototype.getChannel = function(name, create) {\n  var channel = this.channels[name];\n  if(!channel && !!create) {\n    channel = this.channels[name] = new Channel(name, this);\n    addToStore(this, genKey(this), genKey(this, name));\n  }\n  return channel;\n};\n\n/**\n * Destroy channel by name.\n *\n * @param {String} name channel name\n * @memberOf ChannelService\n */\nChannelService.prototype.destroyChannel = function(name) {\n  delete this.channels[name];\n  removeFromStore(this, genKey(this), genKey(this, name));\n  removeAllFromStore(this, genKey(this, name));\n};\n\n/**\n * Push message by uids.\n * Group the uids by group. ignore any uid if sid not specified.\n *\n * @param {String} route message route\n * @param {Object} msg message that would be sent to client\n * @param {Array} uids the receiver info list, [{uid: userId, sid: frontendServerId}]\n * @param {Object} opts user-defined push options, optional \n * @param {Function} cb cb(err)\n * @memberOf ChannelService\n */\nChannelService.prototype.pushMessageByUids = function(route, msg, uids, opts, cb) {\n  if(typeof route !== 'string') {\n    cb = opts;\n    opts = uids;\n    uids = msg;\n    msg = route;\n    route = msg.route;\n  }\n\n  if(!cb && typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  if(!uids || uids.length === 0) {\n    utils.invokeCallback(cb, new Error('uids should not be empty'));\n    return;\n  }\n  var groups = {}, record;\n  for(var i=0, l=uids.length; i<l; i++) {\n    record = uids[i];\n    add(record.uid, record.sid, groups);\n  }\n\n  sendMessageByGroup(this, route, msg, groups, opts, cb);\n};\n\n/**\n * Broadcast message to all the connected clients.\n *\n * @param  {String}   stype      frontend server type string\n * @param  {String}   route      route string\n * @param  {Object}   msg        message\n * @param  {Object}   opts       user-defined broadcast options, optional\n *                               opts.binded: push to binded sessions or all the sessions\n *                               opts.filterParam: parameters for broadcast filter.\n * @param  {Function} cb         callback\n * @memberOf ChannelService\n */\nChannelService.prototype.broadcast = function(stype, route, msg, opts, cb) {\n  var app = this.app;\n  var namespace = 'sys';\n  var service = 'channelRemote';\n  var method = 'broadcast';\n  var servers = app.getServersByType(stype);\n\n  if(!servers || servers.length === 0) {\n    // server list is empty\n    utils.invokeCallback(cb);\n    return;\n  }\n\n  var count = servers.length;\n  var successFlag = false;\n\n  var latch = countDownLatch.createCountDownLatch(count, function() {\n    if(!successFlag) {\n      utils.invokeCallback(cb, new Error('broadcast fails'));\n      return;\n    }\n    utils.invokeCallback(cb, null);\n  });\n\n  var genCB = function(serverId) {\n    return function(err) {\n      if(err) {\n        logger.error('[broadcast] fail to push message to serverId: ' + serverId + ', err:' + err.stack);\n        latch.done();\n        return;\n      }\n      successFlag = true;\n      latch.done();\n    };\n  };\n\n  var self = this;\n  var sendMessage = function(serverId) {\n    return (function() {\n      if(serverId === app.serverId) {\n        self.channelRemote[method](route, msg, opts, genCB());\n      } else {\n        app.rpcInvoke(serverId, {namespace: namespace, service: service,\n          method: method, args: [route, msg, opts]}, genCB(serverId));\n      }\n    }());\n  };\n\n  opts = {type: 'broadcast', userOptions: opts || {}};\n\n  // for compatiblity \n  opts.isBroadcast = true;\n  if(opts.userOptions) {\n    opts.binded = opts.userOptions.binded;\n    opts.filterParam = opts.userOptions.filterParam;\n  }\n\n  for(var i=0, l=count; i<l; i++) {\n    sendMessage(servers[i].id);\n  }\n};\n\n/**\n * Channel maintains the receiver collection for a subject. You can\n * add users into a channel and then broadcast message to them by channel.\n *\n * @class channel\n * @constructor\n */\nvar Channel = function(name, service) {\n  this.name = name;\n  this.groups = {};       // group map for uids. key: sid, value: [uid]\n  this.records = {};      // member records. key: uid\n  this.__channelService__ = service;\n  this.state = ST_INITED;\n  this.userAmount =0;\n};\n\n/**\n * Add user to channel.\n *\n * @param {Number} uid user id\n * @param {String} sid frontend server id which user has connected to\n */\nChannel.prototype.add = function(uid, sid) {\n  if(this.state > ST_INITED) {\n    return false;\n  } else {\n    var res = add(uid, sid, this.groups);\n    if(res) {\n      this.records[uid] = {sid: sid, uid: uid};\n      this.userAmount =this.userAmount+1;\n    }\n    addToStore(this.__channelService__, genKey(this.__channelService__, this.name), genValue(sid, uid));\n    return res;\n  }\n};\n\n/**\n * Remove user from channel.\n *\n * @param {Number} uid user id\n * @param {String} sid frontend server id which user has connected to.\n * @return [Boolean] true if success or false if fail\n */\nChannel.prototype.leave = function(uid, sid) {\n  if(!uid || !sid) {\n    return false;\n  }\n  var res = deleteFrom(uid, sid, this.groups[sid]);\n  if(res){\n    delete this.records[uid];\n    this.userAmount = this.userAmount-1;\n  }\n  if(this.userAmount<0) this.userAmount=0;//robust\n  removeFromStore(this.__channelService__, genKey(this.__channelService__, this.name), genValue(sid, uid));\n  if(this.groups[sid] && this.groups[sid].length === 0) {\n    delete this.groups[sid];\n  }\n  return res;\n};\n/**\n * Get channel UserAmount in a channel.\n\n *\n * @return {number } channel member amount\n */\nChannel.prototype.getUserAmount = function() {\n \n  return this.userAmount;\n};\n\n/**\n * Get channel members.\n *\n * <b>Notice:</b> Heavy operation.\n *\n * @return {Array} channel member uid list\n */\nChannel.prototype.getMembers = function() {\n  var res = [], groups = this.groups;\n  var group, i, l;\n  for(var sid in groups) {\n    group = groups[sid];\n    for(i=0, l=group.length; i<l; i++) {\n      res.push(group[i]);\n    }\n  }\n  return res;\n};\n\n/**\n * Get Member info.\n *\n * @param  {String} uid user id\n * @return {Object} member info\n */\nChannel.prototype.getMember = function(uid) {\n  return this.records[uid];\n};\n\n/**\n * Destroy channel.\n */\nChannel.prototype.destroy = function() {\n  this.state = ST_DESTROYED;\n  this.__channelService__.destroyChannel(this.name);\n};\n\n/**\n * Push message to all the members in the channel\n *\n * @param {String} route message route\n * @param {Object} msg message that would be sent to client\n * @param {Object} opts user-defined push options, optional\n * @param {Function} cb callback function\n */\nChannel.prototype.pushMessage = function(route, msg, opts, cb) {\n  if(this.state !== ST_INITED) {\n    utils.invokeCallback(new Error('channel is not running now'));\n    return;\n  }\n\n  if(typeof route !== 'string') {\n    cb = opts;\n    opts = msg;\n    msg = route;\n    route = msg.route;\n  }\n\n  if(!cb && typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  sendMessageByGroup(this.__channelService__, route, msg, this.groups, opts, cb);\n};\n\n/**\n * add uid and sid into group. ignore any uid that uid not specified.\n *\n * @param uid user id\n * @param sid server id\n * @param groups {Object} grouped uids, , key: sid, value: [uid]\n */\nvar add = function(uid, sid, groups) {\n  if(!sid) {\n    logger.warn('ignore uid %j for sid not specified.', uid);\n    return false;\n  }\n\n  var group = groups[sid];\n  if(!group) {\n    group = [];\n    groups[sid] = group;\n  }\n\n  group.push(uid);\n  return true;\n};\n\n/**\n * delete element from array\n */\nvar deleteFrom = function(uid, sid, group) {\n  if(!uid || !sid || !group) {\n    return false;\n  }\n\n  for(var i=0, l=group.length; i<l; i++) {\n    if(group[i] === uid) {\n      group.splice(i, 1);\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * push message by group\n *\n * @param route {String} route route message\n * @param msg {Object} message that would be sent to client\n * @param groups {Object} grouped uids, , key: sid, value: [uid]\n * @param opts {Object} push options\n * @param cb {Function} cb(err)\n *\n * @api private\n */\nvar sendMessageByGroup = function(channelService, route, msg, groups, opts, cb) {\n  var app = channelService.app;\n  var namespace = 'sys';\n  var service = 'channelRemote';\n  var method = 'pushMessage';\n  var count = utils.size(groups);\n  var successFlag = false;\n  var failIds = [];\n\n  logger.debug('[%s] channelService sendMessageByGroup route: %s, msg: %j, groups: %j, opts: %j', app.serverId, route, msg, groups, opts);\n  if(count === 0) {\n    // group is empty\n    utils.invokeCallback(cb);\n    return;\n  }\n\n  var latch = countDownLatch.createCountDownLatch(count, function() {\n    if(!successFlag) {\n      utils.invokeCallback(cb, new Error('all uids push message fail'));\n      return;\n    }\n    utils.invokeCallback(cb, null, failIds);\n  });\n\n  var rpcCB = function(serverId) {\n    return function(err, fails) {\n      if(err) {\n        logger.error('[pushMessage] fail to dispatch msg to serverId: ' + serverId + ', err:' + err.stack);\n        latch.done();\n        return;\n      }\n      if(fails) {\n        failIds = failIds.concat(fails);\n      }\n      successFlag = true;\n      latch.done();\n    };\n  };\n\n  opts = {type: 'push', userOptions: opts || {}};\n  // for compatiblity\n  opts.isPush = true;\n  \n  var sendMessage = function(sid) {\n    return (function() {\n      if(sid === app.serverId) {\n        channelService.channelRemote[method](route, msg, groups[sid], opts, rpcCB(sid));\n      } else {\n        app.rpcInvoke(sid, {namespace: namespace, service: service,\n          method: method, args: [route, msg, groups[sid], opts]}, rpcCB(sid));\n      }\n    })();\n  };\n\n  var group;\n  for(var sid in groups) {\n    group = groups[sid];\n    if(group && group.length > 0) {\n      sendMessage(sid);\n    } else {\n      // empty group\n      process.nextTick(rpcCB(sid));\n    }\n  }\n};\n\nvar restoreChannel = function(self, cb) {\n  if(!self.store) {\n    utils.invokeCallback(cb);\n    return;\n  } else {\n    loadAllFromStore(self, genKey(self), function(err, list) {\n      if(!!err) {\n        utils.invokeCallback(cb, err);\n        return;\n      } else {\n        if(!list.length || !Array.isArray(list)) {\n          utils.invokeCallback(cb);\n          return;\n        }\n        var load = function(key) {\n          return (function() {\n            loadAllFromStore(self, key, function(err, items) {\n              for(var j=0; j<items.length; j++) {\n                var array = items[j].split(':');\n                var sid = array[0];\n                var uid = array[1];\n                var channel = self.channels[name];\n                var res = add(uid, sid, channel.groups);\n                if(res) {\n                  channel.records[uid] = {sid: sid, uid: uid};\n                }\n              }\n            });\n          })();\n        };\n\n       for(var i=0; i<list.length; i++) {\n        var name = list[i].slice(genKey(self).length + 1);\n        self.channels[name] = new Channel(name, self);\n        load(list[i]);\n      }\n      utils.invokeCallback(cb);\n    }\n  });\n}\n};\n\nvar addToStore = function(self, key, value) {\n  if(!!self.store) {\n    self.store.add(key, value, function(err) {\n      if(!!err) {\n        logger.error('add key: %s value: %s to store, with err: %j', key, value, err.stack);\n      }\n    });\n  }\n};\n\nvar removeFromStore = function(self, key, value) {\n  if(!!self.store) {\n    self.store.remove(key, value, function(err) {\n      if(!!err) {\n        logger.error('remove key: %s value: %s from store, with err: %j', key, value, err.stack);\n      }\n    });\n  }\n};\n\nvar loadAllFromStore = function(self, key, cb) {\n  if(!!self.store) {\n    self.store.load(key, function(err, list) {\n      if(!!err) {\n        logger.error('load key: %s from store, with err: %j', key, err.stack);\n        utils.invokeCallback(cb, err);\n      } else {\n        utils.invokeCallback(cb, null, list);\n      }\n    });\n  }\n};\n\nvar removeAllFromStore = function(self, key) {\n  if(!!self.store) {\n    self.store.removeAll(key, function(err) {\n      if(!!err) {\n        logger.error('remove key: %s all members from store, with err: %j', key, err.stack);\n      }\n    });\n  }\n};\n\nvar genKey = function(self, name) {\n  if(!!name) {\n    return self.prefix + ':' + self.app.serverId + ':' + name;\n  } else {\n    return self.prefix + ':' + self.app.serverId;\n  }\n};\n\nvar genValue = function(sid, uid) {\n  return sid + ':' + uid;\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/util/countDownLatch.js":"var exp = module.exports;\n\n/**\n * Count down to zero or timeout and invoke cb finally.\n */\nvar CountDownLatch = function(count, opts, cb) {\n  this.count = count;\n  this.cb = cb;\n  var self = this;\n  if (opts.timeout) {\n    this.timerId = setTimeout(function() {\n      self.cb(true);\n    }, opts.timeout);\n  }\n};\n\n/**\n * Call when a task finish to count down.\n *\n * @api public\n */\nCountDownLatch.prototype.done = function() {\n  if(this.count <= 0) {\n    throw new Error('illegal state.');\n  }\n\n  this.count--;\n  if (this.count === 0) {\n    if (this.timerId) {\n      clearTimeout(this.timerId);\n    }\n    this.cb();\n  }\n};\n\n/**\n * Create a count down latch\n *\n * @param {Integer} count\n * @param {Object} opts, opts.timeout indicates timeout, optional param\n * @param {Function} cb, cb(isTimeout)\n *\n * @api public\n */\nexp.createCountDownLatch = function(count, opts, cb) {\n  if(!count || count <= 0) {\n    throw new Error('count should be positive.');\n  }\n\n  if (!cb && typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  if(typeof cb !== 'function') {\n    throw new Error('cb should be a function.');\n  }\n\n  return new CountDownLatch(count, opts, cb);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/common/remote/frontend/channelRemote.js":"/**\n * Remote channel service for frontend server.\n * Receive push request from backend servers and push it to clients.\n */\nvar utils = require('../../../util/utils');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\n\nmodule.exports = function(app) {\n  return new Remote(app);\n};\n\nvar Remote = function(app) {\n  this.app = app;\n};\n\n/**\n * Push message to client by uids.\n *\n * @param  {String}   route route string of message\n * @param  {Object}   msg   message\n * @param  {Array}    uids  user ids that would receive the message\n * @param  {Object}   opts  push options\n * @param  {Function} cb    callback function\n */\nRemote.prototype.pushMessage = function(route, msg, uids, opts, cb) {\n  if(!msg){\n    logger.error('Can not send empty message! route : %j, compressed msg : %j',\n        route, msg);\n    utils.invokeCallback(cb, new Error('can not send empty message.'));\n    return;\n  }\n  \n  var connector = this.app.components.__connector__;\n\n  var sessionService = this.app.get('sessionService');\n  var fails = [], sids = [], sessions, j, k;\n  for(var i=0, l=uids.length; i<l; i++) {\n    sessions = sessionService.getByUid(uids[i]);\n    if(!sessions) {\n      fails.push(uids[i]);\n    } else {\n      for(j=0, k=sessions.length; j<k; j++) {\n        sids.push(sessions[j].id);\n      }\n    }\n  }\n  logger.debug('[%s] pushMessage uids: %j, msg: %j, sids: %j', this.app.serverId, uids, msg, sids);\n  connector.send(null, route, msg, sids, opts, function(err) {\n    utils.invokeCallback(cb, err, fails);\n  });\n};\n\n/**\n * Broadcast to all the client connectd with current frontend server.\n *\n * @param  {String}    route  route string\n * @param  {Object}    msg    message\n * @param  {Boolean}   opts   broadcast options. \n * @param  {Function}  cb     callback function\n */\nRemote.prototype.broadcast = function(route, msg, opts, cb) {\n  var connector = this.app.components.__connector__;\n\n  connector.send(null, route, msg, null, opts, cb);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/components/connection.js":"var ConnectionService = require('../common/service/connectionService');\n\n/**\n * Connection component for statistics connection status of frontend servers\n */\nmodule.exports = function(app) {\n  return new Component(app);\n};\n\nvar Component = function(app) {\n  this.app = app;\n  this.service = new ConnectionService(app);\n\n  // proxy the service methods except the lifecycle interfaces of component\n  var method, self = this;\n\n  var getFun = function(m) {\n    return (function() {\n          return function() {\n            return self.service[m].apply(self.service, arguments);\n          };\n    })();\n  };\n\n  for(var m in this.service) {\n    if(m !== 'start' && m !== 'stop') {\n      method = this.service[m];\n      if(typeof method === 'function') {\n        this[m] = getFun(m);\n      }\n    }\n  }\n};\n\nComponent.prototype.name = '__connection__';\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/common/service/connectionService.js":"/**\n * connection statistics service\n * record connection, login count and list\n */\nvar Service = function(app) {\n  this.serverId = app.getServerId();\n  this.connCount = 0;\n  this.loginedCount = 0;\n  this.logined = {};\n};\n\nmodule.exports = Service;\n\nvar pro = Service.prototype;\n\n\n/**\n * Add logined user.\n *\n * @param uid {String} user id\n * @param info {Object} record for logined user\n */\npro.addLoginedUser = function(uid, info) {\n  if(!this.logined[uid]) {\n    this.loginedCount++;\n  }\n  info.uid = uid;\n  this.logined[uid] = info;\n};\n\n/**\n * Update user info.\n * @param uid {String} user id\n * @param info {Object} info for update.\n */\npro.updateUserInfo = function(uid, info) {\n    var user = this.logined[uid];\n    if (!user) {\n        return;\n    }\n\n    for (var p in info) {\n        if (info.hasOwnProperty(p) && typeof info[p] !== 'function') {\n            user[p] = info[p];\n        }\n    }\n};\n\n/**\n * Increase connection count\n */\npro.increaseConnectionCount = function() {\n  this.connCount++;\n};\n\n/**\n * Remote logined user\n *\n * @param uid {String} user id\n */\npro.removeLoginedUser = function(uid) {\n  if(!!this.logined[uid]) {\n    this.loginedCount--;\n  }\n  delete this.logined[uid];\n};\n\n/**\n * Decrease connection count\n *\n * @param uid {String} uid\n */\npro.decreaseConnectionCount = function(uid) {\n  if(this.connCount) {\n    this.connCount--;\n  }\n  if(!!uid) {\n    this.removeLoginedUser(uid);\n  }\n};\n\n/**\n * Get statistics info\n *\n * @return {Object} statistics info\n */\npro.getStatisticsInfo = function() {\n  var list = [];\n  for(var uid in this.logined) {\n    list.push(this.logined[uid]);\n  }\n\n  return {serverId: this.serverId, totalConnCount: this.connCount, loginedCount: this.loginedCount, loginedList: list};\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/components/connector.js":"var logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar taskManager = require('../common/manager/taskManager');\nvar pomelo = require('../pomelo');\nvar rsa = require(\"node-bignumber\");\nvar events = require('../util/events');\nvar utils = require('../util/utils');\n\nmodule.exports = function(app, opts) {\n  return new Component(app, opts);\n};\n\n/**\n * Connector component. Receive client requests and attach session with socket.\n *\n * @param {Object} app  current application context\n * @param {Object} opts attach parameters\n *                      opts.connector {Object} provides low level network and protocol details implementation between server and clients.\n */\nvar Component = function(app, opts) {\n  opts = opts || {};\n  this.app = app;\n  this.connector = getConnector(app, opts);\n  this.encode = opts.encode;\n  this.decode = opts.decode;\n  this.useCrypto = opts.useCrypto;\n  this.useHostFilter = opts.useHostFilter;\n  this.useAsyncCoder = opts.useAsyncCoder;\n  this.blacklistFun = opts.blacklistFun;\n  this.keys = {};\n  this.blacklist = [];\n\n  if (opts.useDict) {\n    app.load(pomelo.dictionary, app.get('dictionaryConfig'));\n  }\n\n  if (opts.useProtobuf) {\n    app.load(pomelo.protobuf, app.get('protobufConfig'));\n  }\n\n  // component dependencies\n  this.server = null;\n  this.session = null;\n  this.connection = null;\n};\n\nvar pro = Component.prototype;\n\npro.name = '__connector__';\n\npro.start = function(cb) {\n  this.server = this.app.components.__server__;\n  this.session = this.app.components.__session__;\n  this.connection = this.app.components.__connection__;\n\n  // check component dependencies\n  if (!this.server) {\n    process.nextTick(function() {\n      utils.invokeCallback(cb, new Error('fail to start connector component for no server component loaded'));\n    });\n    return;\n  }\n\n  if (!this.session) {\n    process.nextTick(function() {\n      utils.invokeCallback(cb, new Error('fail to start connector component for no session component loaded'));\n    });\n    return;\n  }\n\n  process.nextTick(cb);\n};\n\npro.afterStart = function(cb) {\n  this.connector.start(cb);\n  this.connector.on('connection', hostFilter.bind(this, bindEvents));\n};\n\npro.stop = function(force, cb) {\n  if (this.connector) {\n    this.connector.stop(force, cb);\n    this.connector = null;\n    return;\n  } else {\n    process.nextTick(cb);\n  }\n};\n\npro.send = function(reqId, route, msg, recvs, opts, cb) {\n  logger.debug('[%s] send message reqId: %s, route: %s, msg: %j, receivers: %j, opts: %j', this.app.serverId, reqId, route, msg, recvs, opts);\n  if (this.useAsyncCoder) {\n    return this.sendAsync(reqId, route, msg, recvs, opts, cb);\n  }\n\n  var emsg = msg;\n  if (this.encode) {\n    // use costumized encode\n    emsg = this.encode.call(this, reqId, route, msg);\n  } else if (this.connector.encode) {\n    // use connector default encode\n    emsg = this.connector.encode(reqId, route, msg);\n  }\n\n  this.doSend(reqId, route, emsg, recvs, opts, cb);\n};\n\npro.sendAsync = function(reqId, route, msg, recvs, opts, cb) {\n  var emsg = msg;\n  var self = this;\n\n  if (this.encode) {\n    // use costumized encode\n    this.encode(reqId, route, msg, function(err, encodeMsg) {\n      if (err) {\n        return cb(err);\n      }\n\n      emsg = encodeMsg;\n      self.doSend(reqId, route, emsg, recvs, opts, cb);\n    });\n  } else if (this.connector.encode) {\n    // use connector default encode\n    this.connector.encode(reqId, route, msg, function(err, encodeMsg) {\n      if (err) {\n        return cb(err);\n      }\n\n      emsg = encodeMsg;\n      self.doSend(reqId, route, emsg, recvs, opts, cb);\n    });\n  }\n}\n\npro.doSend = function(reqId, route, emsg, recvs, opts, cb) {\n  if (!emsg) {\n    process.nextTick(function() {\n      return cb && cb(new Error('fail to send message for encode result is empty.'));\n    });\n  }\n\n  this.app.components.__pushScheduler__.schedule(reqId, route, emsg,\n    recvs, opts, cb);\n}\n\npro.setPubKey = function(id, key) {\n  var pubKey = new rsa.Key();\n  pubKey.n = new rsa.BigInteger(key.rsa_n, 16);\n  pubKey.e = key.rsa_e;\n  this.keys[id] = pubKey;\n};\n\npro.getPubKey = function(id) {\n  return this.keys[id];\n};\n\nvar getConnector = function(app, opts) {\n  var connector = opts.connector;\n  if (!connector) {\n    return getDefaultConnector(app, opts);\n  }\n\n  if (typeof connector !== 'function') {\n    return connector;\n  }\n\n  var curServer = app.getCurServer();\n  return connector(curServer.clientPort, curServer.host, opts);\n};\n\nvar getDefaultConnector = function(app, opts) {\n  var DefaultConnector = require('../connectors/sioconnector');\n  var curServer = app.getCurServer();\n  return new DefaultConnector(curServer.clientPort, curServer.host, opts);\n};\n\nvar hostFilter = function(cb, socket) {\n  if(!this.useHostFilter) {\n    return cb(this, socket);\n  }\n\n  var ip = socket.remoteAddress.ip;\n  var check = function(list) {\n    for (var address in list) {\n      var exp = new RegExp(list[address]);\n      if (exp.test(ip)) {\n        socket.disconnect();\n        return true;\n      }\n    }\n    return false;\n  };\n  // dynamical check\n  if (this.blacklist.length !== 0 && !!check(this.blacklist)) {\n    return;\n  }\n  // static check\n  if (!!this.blacklistFun && typeof this.blacklistFun === 'function') {\n    var self = this;\n    self.blacklistFun(function(err, list) {\n      if (!!err) {\n        logger.error('connector blacklist error: %j', err.stack);\n        utils.invokeCallback(cb, self, socket);\n        return;\n      }\n      if (!Array.isArray(list)) {\n        logger.error('connector blacklist is not array: %j', list);\n        utils.invokeCallback(cb, self, socket);\n        return;\n      }\n      if (!!check(list)) {\n        return;\n      } else {\n        utils.invokeCallback(cb, self, socket);\n        return;\n      }\n    });\n  } else {\n    utils.invokeCallback(cb, this, socket);\n  }\n};\n\nvar bindEvents = function(self, socket) {\n  var curServer = self.app.getCurServer();\n  var maxConnections = curServer['max-connections'];\n  if (self.connection && maxConnections) {\n    self.connection.increaseConnectionCount();\n    var statisticInfo = self.connection.getStatisticsInfo();\n    if (statisticInfo.totalConnCount > maxConnections) {\n      logger.warn('the server %s has reached the max connections %s', curServer.id, maxConnections);\n      socket.disconnect();\n      return;\n    }\n  }\n\n  //create session for connection\n  var session = getSession(self, socket);\n  var closed = false;\n\n  socket.on('disconnect', function() {\n    if (closed) {\n      return;\n    }\n    closed = true;\n    if (self.connection) {\n      self.connection.decreaseConnectionCount(session.uid);\n    }\n  });\n\n  socket.on('error', function() {\n    if (closed) {\n      return;\n    }\n    closed = true;\n    if (self.connection) {\n      self.connection.decreaseConnectionCount(session.uid);\n    }\n  });\n\n  // new message\n  socket.on('message', function(msg) {\n    var dmsg = msg;\n    if (self.useAsyncCoder) {\n      return handleMessageAsync(self, msg, session, socket);\n    }\n\n    if (self.decode) {\n      dmsg = self.decode(msg, session);\n    } else if (self.connector.decode) {\n      dmsg = self.connector.decode(msg, socket);\n    }\n    if (!dmsg) {\n      // discard invalid message\n      return;\n    }\n\n    // use rsa crypto\n    if (self.useCrypto) {\n      var verified = verifyMessage(self, session, dmsg);\n      if (!verified) {\n        logger.error('fail to verify the data received from client.');\n        return;\n      }\n    }\n\n    handleMessage(self, session, dmsg);\n  }); //on message end\n};\n\nvar handleMessageAsync = function(self, msg, session, socket) {\n  if (self.decode) {\n    self.decode(msg, session, function(err, dmsg) {\n      if (err) {\n        logger.error('fail to decode message from client %s .', err.stack);\n        return;\n      }\n\n      doHandleMessage(self, dmsg, session);\n    });\n  } else if (self.connector.decode) {\n    self.connector.decode(msg, socket, function(err, dmsg) {\n      if (err) {\n        logger.error('fail to decode message from client %s .', err.stack);\n        return;\n      }\n\n      doHandleMessage(self, dmsg, session);\n    });\n  }\n}\n\nvar doHandleMessage = function(self, dmsg, session) {\n  if (!dmsg) {\n    // discard invalid message\n    return;\n  }\n\n  // use rsa crypto\n  if (self.useCrypto) {\n    var verified = verifyMessage(self, session, dmsg);\n    if (!verified) {\n      logger.error('fail to verify the data received from client.');\n      return;\n    }\n  }\n\n  handleMessage(self, session, dmsg);\n}\n\n/**\n * get session for current connection\n */\nvar getSession = function(self, socket) {\n  var app = self.app,\n    sid = socket.id;\n  var session = self.session.get(sid);\n  if (session) {\n    return session;\n  }\n\n  session = self.session.create(sid, app.getServerId(), socket);\n  logger.debug('[%s] getSession session is created with session id: %s', app.getServerId(), sid);\n\n  // bind events for session\n  socket.on('disconnect', session.closed.bind(session));\n  socket.on('error', session.closed.bind(session));\n  session.on('closed', onSessionClose.bind(null, app));\n  session.on('bind', function(uid) {\n    logger.debug('session on [%s] bind with uid: %s', self.app.serverId, uid);\n    // update connection statistics if necessary\n    if (self.connection) {\n      self.connection.addLoginedUser(uid, {\n        loginTime: Date.now(),\n        uid: uid,\n        address: socket.remoteAddress.ip + ':' + socket.remoteAddress.port\n      });\n    }\n    self.app.event.emit(events.BIND_SESSION, session);\n  });\n\n  session.on('unbind', function(uid) {\n    if (self.connection) {\n      self.connection.removeLoginedUser(uid);\n    }\n    self.app.event.emit(events.UNBIND_SESSION, session);\n  });\n\n  return session;\n};\n\nvar onSessionClose = function(app, session, reason) {\n  taskManager.closeQueue(session.id, true);\n  app.event.emit(events.CLOSE_SESSION, session);\n};\n\nvar handleMessage = function(self, session, msg) {\n  logger.debug('[%s] handleMessage session id: %s, msg: %j', self.app.serverId, session.id, msg);\n  var type = checkServerType(msg.route);\n  if (!type) {\n    logger.error('invalid route string. route : %j', msg.route);\n    return;\n  }\n  self.server.globalHandle(msg, session.toFrontendSession(), function(err, resp, opts) {\n    if (resp && !msg.id) {\n      logger.warn('try to response to a notify: %j', msg.route);\n      return;\n    }\n    if (!msg.id && !resp) return;\n    if (!resp) resp = {};\n    if (!!err && !resp.code) {\n      resp.code = 500;\n    }\n    opts = {\n      type: 'response',\n      userOptions: opts || {}\n    };\n    // for compatiablity\n    opts.isResponse = true;\n\n    self.send(msg.id, msg.route, resp, [session.id], opts,\n      function() {});\n  });\n};\n\n/**\n * Get server type form request message.\n */\nvar checkServerType = function(route) {\n  if (!route) {\n    return null;\n  }\n  var idx = route.indexOf('.');\n  if (idx < 0) {\n    return null;\n  }\n  return route.substring(0, idx);\n};\n\nvar verifyMessage = function(self, session, msg) {\n  var sig = msg.body.__crypto__;\n  if (!sig) {\n    logger.error('receive data from client has no signature [%s]', self.app.serverId);\n    return false;\n  }\n\n  var pubKey;\n\n  if (!session) {\n    logger.error('could not find session.');\n    return false;\n  }\n\n  if (!session.get('pubKey')) {\n    pubKey = self.getPubKey(session.id);\n    if (!!pubKey) {\n      delete self.keys[session.id];\n      session.set('pubKey', pubKey);\n    } else {\n      logger.error('could not get public key, session id is %s', session.id);\n      return false;\n    }\n  } else {\n    pubKey = session.get('pubKey');\n  }\n\n  if (!pubKey.n || !pubKey.e) {\n    logger.error('could not verify message without public key [%s]', self.app.serverId);\n    return false;\n  }\n\n  delete msg.body.__crypto__;\n\n  var message = JSON.stringify(msg.body);\n  if (utils.hasChineseChar(message))\n    message = utils.unicodeToUtf8(message);\n\n  return pubKey.verifyString(message, sig);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/common/manager/taskManager.js":"var sequeue = require('seq-queue');\n\nvar manager = module.exports;\n\nvar queues = {};\n\nmanager.timeout = 3000;\n\n/**\n * Add tasks into task group. Create the task group if it dose not exist.\n *\n * @param {String}   key       task key\n * @param {Function} fn        task callback\n * @param {Function} ontimeout task timeout callback\n * @param {Number}   timeout   timeout for task\n */\nmanager.addTask = function(key, fn, ontimeout, timeout) {\n  var queue = queues[key];\n  if(!queue) {\n    queue = sequeue.createQueue(manager.timeout);\n    queues[key] = queue;\n  }\n\n  return queue.push(fn, ontimeout, timeout);\n};\n\n/**\n * Destroy task group\n *\n * @param  {String} key   task key\n * @param  {Boolean} force whether close task group directly\n */\nmanager.closeQueue = function(key, force) {\n  if(!queues[key]) {\n    // ignore illeagle key\n    return;\n  }\n\n  queues[key].close(force);\n  delete queues[key];\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/components/dictionary.js":"var fs = require('fs');\nvar path = require('path');\nvar utils = require('../util/utils');\nvar Loader = require('pomelo-loader');\nvar pathUtil = require('../util/pathUtil');\nvar crypto = require('crypto');\n\nmodule.exports = function(app, opts) {\n  return new Component(app, opts);\n};\n\nvar Component = function(app, opts) {\n  this.app = app;\n  this.dict = {};\n  this.abbrs = {};\n  this.userDicPath = null;\n  this.version = \"\";\n\n  //Set user dictionary\n  var p = path.join(app.getBase(), '/config/dictionary.json');\n  if(!!opts && !!opts.dict) {\n    p = opts.dict;\n  }\n  if(fs.existsSync(p)) {\n    this.userDicPath = p;\n  }\n};\n\nvar pro = Component.prototype;\n\npro.name = '__dictionary__';\n\npro.start = function(cb) {\n  var servers = this.app.get('servers');\n  var routes = [];\n\n  //Load all the handler files\n  for(var serverType in servers) {\n    var p = pathUtil.getHandlerPath(this.app.getBase(), serverType);\n    if(!p) {\n      continue;\n    }\n\n    var handlers = Loader.load(p, this.app);\n\n    for(var name in handlers) {\n      var handler = handlers[name];\n      for(var key in handler) {\n        if(typeof(handler[key]) === 'function') {\n          routes.push(serverType + '.' + name + '.' + key);\n        }\n      }\n    }\n  }\n\n  //Sort the route to make sure all the routers abbr are the same in all the servers\n  routes.sort();\n  var abbr;\n  var i;\n  for(i = 0; i < routes.length; i++) {\n    abbr = i + 1;\n    this.abbrs[abbr] = routes[i];\n    this.dict[routes[i]] = abbr;\n  }\n\n  //Load user dictionary\n  if(!!this.userDicPath) {\n    var userDic = require(this.userDicPath);\n\n    abbr = routes.length + 1;\n    for(i = 0; i < userDic.length; i++) {\n      var route = userDic[i];\n\n      this.abbrs[abbr] = route;\n      this.dict[route] = abbr;\n      abbr++;\n    }\n  }\n  \n  this.version = crypto.createHash('md5').update(JSON.stringify(this.dict)).digest('base64');\n\n  utils.invokeCallback(cb);\n};\n\npro.getDict = function() {\n  return this.dict;\n};\n\npro.getAbbrs = function() {\n  return this.abbrs;\n};\n\npro.getVersion = function() {\n  return this.version;\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-loader/index.js":"module.exports = require('./lib/loader');","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-loader/lib/loader.js":"/**\n * Loader Module\n */\n\nvar fs = require('fs');\nvar path = require('path');\n\n/**\n * Load modules under the path.\n * If the module is a function, loader would treat it as a factory function \n * and invoke it with the context parameter to get a instance of the module.\n * Else loader would just require the module.\n * Module instance can specify a name property and it would use file name as \n * the default name if there is no name property. All loaded modules under the \n * path would be add to an empty root object with the name as the key.\n * \n * @param  {String} mpath    the path of modules. Load all the files under the \n *                           path, but *not* recursively if the path contain \n *                           any sub-directory. \n * @param  {Object} context  the context parameter that would be pass to the \n *                           module factory function.\n * @return {Object}          module that has loaded.\n */\nmodule.exports.load = function(mpath, context) {\n\tif(!mpath) {\n\t\tthrow new Error('opts or opts.path should not be empty.');\n\t}\n\n  try {\n    mpath = fs.realpathSync(mpath);\n  } catch(err) {\n    throw err;\n  }\n\n\tif(!isDir(mpath)) {\n\t\tthrow new Error('path should be directory.');\n\t}\n\n\treturn loadPath(mpath, context);\n};\n\nvar loadFile = function(fp, context) {\n\tvar m = requireUncached(fp);\n\n\tif(!m) {\n\t\treturn;\n\t}\n\n\tif(typeof m === 'function') {\n\t\t// if the module provides a factory function \n\t\t// then invoke it to get a instance\n\t\tm = m(context);\n\t}\n\n\treturn m;\n};\n\nvar loadPath = function(path, context) {\n\tvar files = fs.readdirSync(path);\n\tif(files.length === 0) {\n\t\tconsole.warn('path is empty, path:' + path);\n\t\treturn;\n\t}\n\n\tif(path.charAt(path.length - 1) !== '/') {\n\t\tpath += '/';\n\t}\n\t\t\n\tvar fp, fn, m, res = {};\n\tfor(var i=0, l=files.length; i<l; i++) {\n\t\tfn = files[i];\n\t\tfp = path + fn;\n\t\t\n\t\tif(!isFile(fp) || !checkFileType(fn, '.js')) {\n\t\t\t// only load js file type\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tm = loadFile(fp, context);\n\t\t\n\t\tif(!m) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar name = m.name || getFileName(fn, '.js'.length);\n\t\tres[name] = m;\n\t}\n\t\n\treturn res;\n};\n\n/**\n * Check file suffix\n\n * @param fn {String} file name\n * @param suffix {String} suffix string, such as .js, etc.\n */\nvar checkFileType = function(fn, suffix) {\n\tif(suffix.charAt(0) !== '.') {\n\t\tsuffix = '.' + suffix;\n\t}\n\t\n\tif(fn.length <= suffix.length) {\n\t\treturn false;\n\t}\n\t\n\tvar str = fn.substring(fn.length - suffix.length).toLowerCase();\n\tsuffix = suffix.toLowerCase();\n\treturn str === suffix;\n};\n\nvar isFile = function(path) {\n\treturn fs.statSync(path).isFile();\n};\n\nvar isDir = function(path) {\n\treturn fs.statSync(path).isDirectory();\n};\n\nvar getFileName = function(fp, suffixLength) {\n\tvar fn = path.basename(fp);\n\tif(fn.length > suffixLength) {\n\t\treturn fn.substring(0, fn.length - suffixLength);\n\t}\n\n\treturn fn;\n};\n\nvar requireUncached = function(module){\n    delete require.cache[require.resolve(module)]\n    return require(module)\n}","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/util/pathUtil.js":"var fs = require('fs');\nvar path = require('path');\nvar Constants = require('./constants');\nvar exp = module.exports;\n\n/**\n * Get system remote service path\n *\n * @param  {String} role server role: frontend, backend\n * @return {String}      path string if the path exist else null\n */\nexp.getSysRemotePath = function(role) {\n  var p = path.join(__dirname, '/../common/remote/', role);\n  return fs.existsSync(p) ? p : null;\n};\n\n/**\n * Get user remote service path\n *\n * @param  {String} appBase    application base path\n * @param  {String} serverType server type\n * @return {String}            path string if the path exist else null\n */\nexp.getUserRemotePath = function(appBase, serverType) {\n  var p = path.join(appBase, '/app/servers/', serverType, Constants.DIR.REMOTE);\n  return fs.existsSync(p) ? p : null;\n};\n\n/**\n * Get user remote cron path\n * \n * @param  {String} appBase    application base path\n * @param  {String} serverType server type\n * @return {String}            path string if the path exist else null\n */\nexp.getCronPath = function(appBase, serverType) {\n  var p = path.join(appBase, '/app/servers/', serverType, Constants.DIR.CRON);\n  return fs.existsSync(p) ? p : null;\n};\n\n/**\n * List all the subdirectory names of user remote directory\n * which hold the codes for all the server types.\n *\n * @param  {String} appBase application base path\n * @return {Array}         all the subdiretory name under servers/\n */\nexp.listUserRemoteDir = function(appBase) {\n  var base = path.join(appBase, '/app/servers/');\n  var files = fs.readdirSync(base);\n  return files.filter(function(fn) {\n    if(fn.charAt(0) === '.') {\n      return false;\n    }\n\n    return fs.statSync(path.join(base, fn)).isDirectory();\n  });\n};\n\n/**\n * Compose remote path record\n *\n * @param  {String} namespace  remote path namespace, such as: 'sys', 'user'\n * @param  {String} serverType\n * @param  {String} path       remote service source path\n * @return {Object}            remote path record\n */\nexp.remotePathRecord = function(namespace, serverType, path) {\n  return {namespace: namespace, serverType: serverType, path: path};\n};\n\n/**\n * Get handler path\n *\n * @param  {String} appBase    application base path\n * @param  {String} serverType server type\n * @return {String}            path string if the path exist else null\n */\nexp.getHandlerPath = function(appBase, serverType) {\n  var p = path.join(appBase, '/app/servers/', serverType, Constants.DIR.HANDLER);\n  return fs.existsSync(p) ? p : null;\n};\n\n/**\n * Get admin script root path.\n *\n * @param  {String} appBase application base path\n * @return {String}         script path string\n */\nexp.getScriptPath = function(appBase) {\n  return path.join(appBase, Constants.DIR.SCRIPT);\n};\n\n/**\n * Get logs path.\n *\n * @param  {String} appBase application base path\n * @return {String}         logs path string\n */\nexp.getLogPath = function(appBase) {\n  return path.join(appBase, Constants.DIR.LOG);\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/components/master.js":"/**\n * Component for master.\n */\nvar Master = require('../master/master');\n\n/**\n * Component factory function\n *\n * @param  {Object} app  current application context\n * @return {Object}      component instances\n */\nmodule.exports = function (app, opts) {\n\treturn new Component(app, opts);\n};\n\n/**\n* Master component class\n*\n* @param {Object} app  current application context\n*/\nvar Component = function (app, opts) {\n\tthis.master = new Master(app, opts);\n};\n\nvar pro = Component.prototype;\n\npro.name = '__master__';\n\n/**\n * Component lifecycle function\n *\n * @param  {Function} cb\n * @return {Void}\n */\npro.start = function (cb) {\n  this.master.start(cb);\n};\n\n/**\n * Component lifecycle function\n *\n * @param  {Boolean}   force whether stop the component immediately\n * @param  {Function}  cb\n * @return {Void}\n */\npro.stop = function (force, cb) {\n  this.master.stop(cb);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/master/master.js":"var starter = require('./starter');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar crashLogger = require('pomelo-logger').getLogger('crash-log', __filename);\nvar adminLogger = require('pomelo-logger').getLogger('admin-log', __filename);\nvar admin = require('pomelo-admin');\nvar util = require('util');\nvar utils = require('../util/utils');\nvar moduleUtil = require('../util/moduleUtil');\nvar Constants = require('../util/constants');\n\nvar Server = function(app, opts) {\n  this.app = app;\n  this.masterInfo = app.getMaster();\n  this.registered = {};\n  this.modules = [];\n  opts = opts || {};\n  \n  opts.port = this.masterInfo.port;\n  opts.env = this.app.get(Constants.RESERVED.ENV);\n  this.closeWatcher = opts.closeWatcher;\n  this.masterConsole = admin.createMasterConsole(opts);\n};\n\nmodule.exports = Server;\n\nServer.prototype.start = function(cb) {\n  moduleUtil.registerDefaultModules(true, this.app, this.closeWatcher);\n  moduleUtil.loadModules(this, this.masterConsole);\n\n  var self = this;\n  // start master console\n  this.masterConsole.start(function(err) {\n    if(err) {\n      process.exit(0);\n    }\n    moduleUtil.startModules(self.modules, function(err) {\n      if(err) {\n        utils.invokeCallback(cb, err);\n        return;\n      }\n\n      if(self.app.get(Constants.RESERVED.MODE) !== Constants.RESERVED.STAND_ALONE) {\n        starter.runServers(self.app);\n      }\n      utils.invokeCallback(cb);\n    });\n  });\n  \n  this.masterConsole.on('error', function(err) {\n    if(!!err) {\n      logger.error('masterConsole encounters with error: ' + err.stack);\n      return;\n    }\n  });\n  \n  this.masterConsole.on('reconnect', function(info){\n    self.app.addServers([info]);\n  });\n\n  // monitor servers disconnect event\n  this.masterConsole.on('disconnect', function(id, type, info, reason) {\n    crashLogger.info(util.format('[%s],[%s],[%s],[%s]', type, id, Date.now(), reason || 'disconnect'));\n    var count = 0;\n    var time = 0;\n    var pingTimer = null;\n    var server = self.app.getServerById(id);\n    var stopFlags = self.app.get(Constants.RESERVED.STOP_SERVERS) || [];\n    if(!!server && (server[Constants.RESERVED.AUTO_RESTART] === 'true' || server[Constants.RESERVED.RESTART_FORCE] === 'true') && stopFlags.indexOf(id) < 0) {\n      var setTimer = function(time) {\n        pingTimer = setTimeout(function() {\n          utils.ping(server.host, function(flag) {\n            if(flag)  {\n              handle();\n            } else {\n              count++;\n              if(count > 3) {\n                time = Constants.TIME.TIME_WAIT_MAX_PING;\n              } else {\n                time = Constants.TIME.TIME_WAIT_PING * count;\n              }\n              setTimer(time);\n            }\n          });\n        }, time);\n      };\n      setTimer(time);\n      var handle = function() {\n        clearTimeout(pingTimer);\n        utils.checkPort(server, function(status) {\n          if(status === 'error') {\n            utils.invokeCallback(cb, new Error('Check port command executed with error.'));\n            return;\n          } else if(status === 'busy') {\n            if(!!server[Constants.RESERVED.RESTART_FORCE]) {\n              starter.kill([info.pid], [server]);\n            } else {\n              utils.invokeCallback(cb, new Error('Port occupied already, check your server to add.'));\n              return;\n            }\n          }\n          setTimeout(function() {\n            starter.run(self.app, server, null);\n          }, Constants.TIME.TIME_WAIT_STOP);\n        });\n      };\n    }\n  });\n\n  // monitor servers register event\n  this.masterConsole.on('register', function(record) {\n    starter.bindCpu(record.id, record.pid, record.host);\n  });\n\n  this.masterConsole.on('admin-log', function(log, error) {\n    if(error) {\n      adminLogger.error(JSON.stringify(log));\n    } else {\n      adminLogger.info(JSON.stringify(log));\n    }\n  });\n};\n\nServer.prototype.stop = function(cb) {\n  this.masterConsole.stop();\n  process.nextTick(cb);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/index.js":"var fs = require('fs');\nvar consoleService = require('./lib/consoleService');\n\nmodule.exports.createMasterConsole = consoleService.createMasterConsole;\nmodule.exports.createMonitorConsole = consoleService.createMonitorConsole;\nmodule.exports.adminClient = require('./lib/client/client');\n\nexports.modules = {};\nfs.readdirSync(__dirname + '/lib/modules').forEach(function(filename) {\n\tif (/\\.js$/.test(filename)) {\n\t\tvar name = filename.substr(0, filename.lastIndexOf('.'));\n\t\tvar _module = require('./lib/modules/' + name);\n\t\tif (!_module.moduleError) {\n\t\t\texports.modules.__defineGetter__(name, function() {\n\t\t\t\treturn _module;\n\t\t\t});\n\t\t}\n\t}\n});","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/consoleService.js":"var logger = require('pomelo-logger').getLogger('pomelo-admin', 'ConsoleService');\nvar MonitorAgent = require('./monitor/monitorAgent');\nvar EventEmitter = require('events').EventEmitter;\nvar MasterAgent = require('./master/masterAgent');\nvar schedule = require('pomelo-scheduler');\nvar protocol = require('./util/protocol');\nvar utils = require('./util/utils');\nvar util = require('util');\n\nvar MS_OF_SECOND = 1000;\n\n/**\n * ConsoleService Constructor\n *\n * @class ConsoleService\n * @constructor\n * @param {Object} opts construct parameter\n *                 opts.type \t{String} server type, 'master', 'connector', etc.\n *                 opts.id \t\t{String} server id\n *                 opts.host \t{String} (monitor only) master server host\n *                 opts.port \t{String | Number} listen port for master or master port for monitor\n *                 opts.master  {Boolean} current service is master or monitor\n *                 opts.info \t{Object} more server info for current server, {id, serverType, host, port}\n * @api public\n */\nvar ConsoleService = function(opts) {\n\tEventEmitter.call(this);\n\tthis.port = opts.port;\n\tthis.env = opts.env;\n\tthis.values = {};\n\tthis.master = opts.master;\n\n\tthis.modules = {};\n\tthis.commands = {\n\t\t'list': listCommand,\n\t\t'enable': enableCommand,\n\t\t'disable': disableCommand\n\t};\n\n\tif (this.master) {\n\t\tthis.authUser = opts.authUser || utils.defaultAuthUser;\n\t\tthis.authServer = opts.authServer || utils.defaultAuthServerMaster;\n\t\tthis.agent = new MasterAgent(this, opts);\n\t} else {\n\t\tthis.type = opts.type;\n\t\tthis.id = opts.id;\n\t\tthis.host = opts.host;\n\t\tthis.authServer = opts.authServer || utils.defaultAuthServerMonitor;\n\t\tthis.agent = new MonitorAgent({\n\t\t\tconsoleService: this,\n\t\t\tid: this.id,\n\t\t\ttype: this.type,\n\t\t\tinfo: opts.info\n\t\t});\n\t}\n};\n\nutil.inherits(ConsoleService, EventEmitter);\n\n/**\n * start master or monitor\n *\n * @param {Function} cb callback function\n * @api public\n */\nConsoleService.prototype.start = function(cb) {\n\tif (this.master) {\n\t\tvar self = this;\n\t\tthis.agent.listen(this.port, function(err) {\n\t\t\tif (!!err) {\n\t\t\t\tutils.invokeCallback(cb, err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\texportEvent(self, self.agent, 'register');\n\t\t\texportEvent(self, self.agent, 'disconnect');\n\t\t\texportEvent(self, self.agent, 'reconnect');\n\t\t\tprocess.nextTick(function() {\n\t\t\t\tutils.invokeCallback(cb);\n\t\t\t});\n\t\t});\n\t} else {\n\t\tlogger.info('try to connect master: %j, %j, %j', this.type, this.host, this.port);\n\t\tthis.agent.connect(this.port, this.host, cb);\n\t\texportEvent(this, this.agent, 'close');\n\t}\n\n\texportEvent(this, this.agent, 'error');\n\n\tfor (var mid in this.modules) {\n\t\tthis.enable(mid);\n\t}\n};\n\n/**\n * stop console modules and stop master server\n *\n * @api public\n */\nConsoleService.prototype.stop = function() {\n\tfor (var mid in this.modules) {\n\t\tthis.disable(mid);\n\t}\n\tthis.agent.close();\n};\n\n/**\n * register a new adminConsole module\n *\n * @param {String} moduleId adminConsole id/name\n * @param {Object} module module object\n * @api public\n */\nConsoleService.prototype.register = function(moduleId, module) {\n\tthis.modules[moduleId] = registerRecord(this, moduleId, module);\n};\n\n/**\n * enable adminConsole module\n *\n * @param {String} moduleId adminConsole id/name\n * @api public\n */\nConsoleService.prototype.enable = function(moduleId) {\n\tvar record = this.modules[moduleId];\n\tif (record && !record.enable) {\n\t\trecord.enable = true;\n\t\taddToSchedule(this, record);\n\t\treturn true;\n\t}\n\treturn false;\n};\n\n/**\n * disable adminConsole module\n *\n * @param {String} moduleId adminConsole id/name\n * @api public\n */\nConsoleService.prototype.disable = function(moduleId) {\n\tvar record = this.modules[moduleId];\n\tif (record && record.enable) {\n\t\trecord.enable = false;\n\t\tif (record.schedule && record.jobId) {\n\t\t\tschedule.cancelJob(record.jobId);\n\t\t\tschedule.jobId = null;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n};\n\n/**\n * call concrete module and handler(monitorHandler,masterHandler,clientHandler)\n *\n * @param {String} moduleId adminConsole id/name\n * @param {String} method handler\n * @param {Object} msg message\n * @param {Function} cb callback function\n * @api public\n */\nConsoleService.prototype.execute = function(moduleId, method, msg, cb) {\n\tvar self = this;\n\tvar m = this.modules[moduleId];\n\tif (!m) {\n\t\tlogger.error('unknown module: %j.', moduleId);\n\t\tcb('unknown moduleId:' + moduleId);\n\t\treturn;\n\t}\n\n\tif (!m.enable) {\n\t\tlogger.error('module %j is disable.', moduleId);\n\t\tcb('module ' + moduleId + ' is disable');\n\t\treturn;\n\t}\n\n\tvar module = m.module;\n\tif (!module || typeof module[method] !== 'function') {\n\t\tlogger.error('module %j dose not have a method called %j.', moduleId, method);\n\t\tcb('module ' + moduleId + ' dose not have a method called ' + method);\n\t\treturn;\n\t}\n\n\tvar log = {\n\t\taction: 'execute',\n\t\tmoduleId: moduleId,\n\t\tmethod: method,\n\t\tmsg: msg\n\t}\n\n\tvar aclMsg = aclControl(self.agent, 'execute', method, moduleId, msg);\n\tif (aclMsg !== 0 && aclMsg !== 1) {\n\t\tlog['error'] = aclMsg;\n\t\tself.emit('admin-log', log, aclMsg);\n\t\tcb(new Error(aclMsg), null);\n\t\treturn;\n\t}\n\n\tif (method === 'clientHandler') {\n\t\tself.emit('admin-log', log);\n\t}\n\n\tmodule[method](this.agent, msg, cb);\n};\n\nConsoleService.prototype.command = function(command, moduleId, msg, cb) {\n\tvar self = this;\n\tvar fun = this.commands[command];\n\tif (!fun || typeof fun !== 'function') {\n\t\tcb('unknown command:' + command);\n\t\treturn;\n\t}\n\n\tvar log = {\n\t\taction: 'command',\n\t\tmoduleId: moduleId,\n\t\tmsg: msg\n\t}\n\n\tvar aclMsg = aclControl(self.agent, 'command', null, moduleId, msg);\n\tif (aclMsg !== 0 && aclMsg !== 1) {\n\t\tlog['error'] = aclMsg;\n\t\tself.emit('admin-log', log, aclMsg);\n\t\tcb(new Error(aclMsg), null);\n\t\treturn;\n\t}\n\n\tself.emit('admin-log', log);\n\tfun(this, moduleId, msg, cb);\n}\n\n/**\n * set module data to a map\n *\n * @param {String} moduleId adminConsole id/name\n * @param {Object} value module data\n * @api public\n */\n\nConsoleService.prototype.set = function(moduleId, value) {\n\tthis.values[moduleId] = value;\n};\n\n/**\n * get module data from map\n *\n * @param {String} moduleId adminConsole id/name\n * @api public\n */\nConsoleService.prototype.get = function(moduleId) {\n\treturn this.values[moduleId];\n};\n\n/**\n * register a module service\n *\n * @param {Object} service consoleService object\n * @param {String} moduleId adminConsole id/name\n * @param {Object} module module object\n * @api private\n */\nvar registerRecord = function(service, moduleId, module) {\n\tvar record = {\n\t\tmoduleId: moduleId,\n\t\tmodule: module,\n\t\tenable: false\n\t};\n\n\tif (module.type && module.interval) {\n\t\tif (!service.master && record.module.type === 'push' || service.master && record.module.type !== 'push') {\n\t\t\t// push for monitor or pull for master(default)\n\t\t\trecord.delay = module.delay || 0;\n\t\t\trecord.interval = module.interval || 1;\n\t\t\t// normalize the arguments\n\t\t\tif (record.delay < 0) {\n\t\t\t\trecord.delay = 0;\n\t\t\t}\n\t\t\tif (record.interval < 0) {\n\t\t\t\trecord.interval = 1;\n\t\t\t}\n\t\t\trecord.interval = Math.ceil(record.interval);\n\t\t\trecord.delay *= MS_OF_SECOND;\n\t\t\trecord.interval *= MS_OF_SECOND;\n\t\t\trecord.schedule = true;\n\t\t}\n\t}\n\n\treturn record;\n};\n\n/**\n * schedule console module\n *\n * @param {Object} service consoleService object\n * @param {Object} record  module object\n * @api private\n */\nvar addToSchedule = function(service, record) {\n\tif (record && record.schedule) {\n\t\trecord.jobId = schedule.scheduleJob({\n\t\t\t\tstart: Date.now() + record.delay,\n\t\t\t\tperiod: record.interval\n\t\t\t},\n\t\t\tdoScheduleJob, {\n\t\t\t\tservice: service,\n\t\t\t\trecord: record\n\t\t\t});\n\t}\n};\n\n/**\n * run schedule job\n *\n * @param {Object} args argments\n * @api private\n */\nvar doScheduleJob = function(args) {\n\tvar service = args.service;\n\tvar record = args.record;\n\tif (!service || !record || !record.module || !record.enable) {\n\t\treturn;\n\t}\n\n\tif (service.master) {\n\t\trecord.module.masterHandler(service.agent, null, function(err) {\n\t\t\tlogger.error('interval push should not have a callback.');\n\t\t});\n\t} else {\n\t\trecord.module.monitorHandler(service.agent, null, function(err) {\n\t\t\tlogger.error('interval push should not have a callback.');\n\t\t});\n\t}\n};\n\n/**\n * export closure function out\n *\n * @param {Function} outer outer function\n * @param {Function} inner inner function\n * @param {object} event\n * @api private\n */\nvar exportEvent = function(outer, inner, event) {\n\tinner.on(event, function() {\n\t\tvar args = Array.prototype.slice.call(arguments, 0);\n\t\targs.unshift(event);\n\t\touter.emit.apply(outer, args);\n\t});\n};\n\n/**\n * List current modules\n */\nvar listCommand = function(consoleService, moduleId, msg, cb) {\n\tvar modules = consoleService.modules;\n\n\tvar result = [];\n\tfor (var moduleId in modules) {\n\t\tif (/^__\\w+__$/.test(moduleId)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult.push(moduleId);\n\t}\n\n\tcb(null, {\n\t\tmodules: result\n\t});\n};\n\n/**\n * enable module in current server\n */\nvar enableCommand = function(consoleService, moduleId, msg, cb) {\n\tif (!moduleId) {\n\t\tlogger.error('fail to enable admin module for ' + moduleId);\n\t\tcb('empty moduleId');\n\t\treturn;\n\t}\n\n\tvar modules = consoleService.modules;\n\tif (!modules[moduleId]) {\n\t\tcb(null, protocol.PRO_FAIL);\n\t\treturn;\n\t}\n\n\tif (consoleService.master) {\n\t\tconsoleService.enable(moduleId);\n\t\tconsoleService.agent.notifyCommand(\"enable\", moduleId, msg);\n\t\tcb(null, protocol.PRO_OK);\n\t} else {\n\t\tconsoleService.enable(moduleId);\n\t\tcb(null, protocol.PRO_OK);\n\t}\n};\n\n/**\n * disable module in current server\n */\nvar disableCommand = function(consoleService, moduleId, msg, cb) {\n\tif (!moduleId) {\n\t\tlogger.error('fail to enable admin module for ' + moduleId);\n\t\tcb('empty moduleId');\n\t\treturn;\n\t}\n\n\tvar modules = consoleService.modules;\n\tif (!modules[moduleId]) {\n\t\tcb(null, protocol.PRO_FAIL);\n\t\treturn;\n\t}\n\n\tif (consoleService.master) {\n\t\tconsoleService.disable(moduleId);\n\t\tconsoleService.agent.notifyCommand(\"disable\", moduleId, msg);\n\t\tcb(null, protocol.PRO_OK);\n\t} else {\n\t\tconsoleService.disable(moduleId);\n\t\tcb(null, protocol.PRO_OK);\n\t}\n};\n\nvar aclControl = function(agent, action, method, moduleId, msg) {\n\tif (action === 'execute') {\n\t\tif (method !== 'clientHandler' || moduleId !== '__console__') {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar signal = msg.signal;\n\t\tif (!signal || !(signal === 'stop' || signal === 'add' || signal === 'kill')) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvar clientId = msg.clientId;\n\tif (!clientId) {\n\t\treturn 'Unknow clientId';\n\t}\n\n\tvar _client = agent.getClientById(clientId);\n\tif (_client && _client.info && _client.info.level) {\n\t\tvar level = _client.info.level;\n\t\tif (level > 1) {\n\t\t\treturn 'Command permission denied';\n\t\t}\n\t} else {\n\t\treturn 'Client info error';\n\t}\n\treturn 1;\n}\n\n/**\n * Create master ConsoleService\n *\n * @param {Object} opts construct parameter\n *                      opts.port {String | Number} listen port for master console\n */\nmodule.exports.createMasterConsole = function(opts) {\n\topts = opts || {};\n\topts.master = true;\n\treturn new ConsoleService(opts);\n};\n\n/**\n * Create monitor ConsoleService\n *\n * @param {Object} opts construct parameter\n *                      opts.type {String} server type, 'master', 'connector', etc.\n *                      opts.id {String} server id\n *                      opts.host {String} master server host\n *                      opts.port {String | Number} master port\n */\nmodule.exports.createMonitorConsole = function(opts) {\n\treturn new ConsoleService(opts);\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/monitor/monitorAgent.js":"var logger = require('pomelo-logger').getLogger('pomelo-admin', 'MonitorAgent');\nvar MqttClient = require('../protocol/mqtt/mqttClient');\nvar EventEmitter = require('events').EventEmitter;\nvar protocol = require('../util/protocol');\nvar utils = require('../util/utils');\nvar Util = require('util');\n\nvar ST_INITED = 1;\nvar ST_CONNECTED = 2;\nvar ST_REGISTERED = 3;\nvar ST_CLOSED = 4;\nvar STATUS_INTERVAL = 5 * 1000; // 60 seconds\n\n/**\n * MonitorAgent Constructor\n *\n * @class MasterAgent\n * @constructor\n * @param {Object} opts construct parameter\n *                 opts.consoleService {Object} consoleService\n *                 opts.id             {String} server id\n *                 opts.type           {String} server type, 'master', 'connector', etc.\n *                 opts.info           {Object} more server info for current server, {id, serverType, host, port}\n * @api public\n */\nvar MonitorAgent = function(opts) {\n  EventEmitter.call(this);\n  this.reqId = 1;\n  this.opts = opts;\n  this.id = opts.id;\n  this.socket = null;\n  this.callbacks = {};\n  this.type = opts.type;\n  this.info = opts.info;\n  this.state = ST_INITED;\n  this.consoleService = opts.consoleService;\n};\n\nUtil.inherits(MonitorAgent, EventEmitter);\n\n/**\n * register and connect to master server\n *\n * @param {String} port\n * @param {String} host\n * @param {Function} cb callback function\n * @api public\n */\nMonitorAgent.prototype.connect = function(port, host, cb) {\n  if (this.state > ST_INITED) {\n    logger.error('monitor client has connected or closed.');\n    return;\n  }\n\n  cb = cb || function() {}\n\n  this.socket = new MqttClient(this.opts);\n  this.socket.connect(host, port);\n\n  // this.socket = sclient.connect(host + ':' + port, {\n  //   'force new connection': true,\n  //   'reconnect': true,\n  //   'max reconnection attempts': 20\n  // });\n  var self = this;\n  this.socket.on('register', function(msg) {\n    if (msg && msg.code === protocol.PRO_OK) {\n      self.state = ST_REGISTERED;\n      cb();\n    } else {\n      self.emit('close');\n      logger.error('server %j %j register master failed', self.id, self.type);\n    }\n  });\n\n  this.socket.on('monitor', function(msg) {\n    if (self.state !== ST_REGISTERED) {\n      return;\n    }\n\n    msg = protocol.parse(msg);\n\n    if (msg.command) {\n      // a command from master\n      self.consoleService.command(msg.command, msg.moduleId, msg.body, function(err, res) {\n        //notify should not have a callback\n      });\n    } else {\n      var respId = msg.respId;\n      if (respId) {\n        // a response from monitor\n        var respCb = self.callbacks[respId];\n        if (!respCb) {\n          logger.warn('unknown resp id:' + respId);\n          return;\n        }\n        delete self.callbacks[respId];\n        respCb(msg.error, msg.body);\n        return;\n      }\n\n      // request from master\n      self.consoleService.execute(msg.moduleId, 'monitorHandler', msg.body, function(err, res) {\n        if (protocol.isRequest(msg)) {\n          var resp = protocol.composeResponse(msg, err, res);\n          if (resp) {\n            self.doSend('monitor', resp);\n          }\n        } else {\n          //notify should not have a callback\n          logger.error('notify should not have a callback.');\n        }\n      });\n    }\n  });\n\n  this.socket.on('connect', function() {\n    if (self.state > ST_INITED) {\n      //ignore reconnect\n      return;\n    }\n    self.state = ST_CONNECTED;\n    var req = {\n      id: self.id,\n      type: 'monitor',\n      serverType: self.type,\n      pid: process.pid,\n      info: self.info\n    };\n    var authServer = self.consoleService.authServer;\n    var env = self.consoleService.env;\n    authServer(req, env, function(token) {\n      req['token'] = token;\n      self.doSend('register', req);\n    });\n  });\n\n  this.socket.on('error', function(err) {\n    if (self.state < ST_CONNECTED) {\n      // error occurs during connecting stage\n      cb(err);\n    } else {\n      self.emit('error', err);\n    }\n  });\n\n  this.socket.on('disconnect', function(reason) {\n    self.state = ST_CLOSED;\n    self.emit('close');\n  });\n\n  this.socket.on('reconnect', function() {\n    self.state = ST_CONNECTED;\n    var req = {\n      id: self.id,\n      type: 'monitor',\n      info: self.info,\n      pid: process.pid,\n      serverType: self.type\n    };\n\n    self.doSend('reconnect', req);\n  });\n\n  this.socket.on('reconnect_ok', function(msg) {\n    if (msg && msg.code === protocol.PRO_OK) {\n      self.state = ST_REGISTERED;\n    }\n  });\n};\n\n/**\n * close monitor agent\n *\n * @api public\n */\nMonitorAgent.prototype.close = function() {\n  if (this.state >= ST_CLOSED) {\n    return;\n  }\n  this.state = ST_CLOSED;\n  this.socket.disconnect();\n};\n\n/**\n * set module\n *\n * @param {String} moduleId module id/name\n * @param {Object} value module object\n * @api public\n */\nMonitorAgent.prototype.set = function(moduleId, value) {\n  this.consoleService.set(moduleId, value);\n};\n\n/**\n * get module\n *\n * @param {String} moduleId module id/name\n * @api public\n */\nMonitorAgent.prototype.get = function(moduleId) {\n  return this.consoleService.get(moduleId);\n};\n\n/**\n * notify master server without callback\n *\n * @param {String} moduleId module id/name\n * @param {Object} msg message\n * @api public\n */\nMonitorAgent.prototype.notify = function(moduleId, msg) {\n  if (this.state !== ST_REGISTERED) {\n    logger.error('agent can not notify now, state:' + this.state);\n    return;\n  }\n  this.doSend('monitor', protocol.composeRequest(null, moduleId, msg));\n  // this.socket.emit('monitor', protocol.composeRequest(null, moduleId, msg));\n};\n\nMonitorAgent.prototype.request = function(moduleId, msg, cb) {\n  if (this.state !== ST_REGISTERED) {\n    logger.error('agent can not request now, state:' + this.state);\n    return;\n  }\n  var reqId = this.reqId++;\n  this.callbacks[reqId] = cb;\n  this.doSend('monitor', protocol.composeRequest(reqId, moduleId, msg));\n  // this.socket.emit('monitor', protocol.composeRequest(reqId, moduleId, msg));\n};\n\nMonitorAgent.prototype.doSend = function(topic, msg) {\n  this.socket.send(topic, msg);\n}\n\nmodule.exports = MonitorAgent;","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/protocol/mqtt/mqttClient.js":"var logger = require('pomelo-logger').getLogger('pomelo-admin', 'MqttClient');\nvar EventEmitter = require('events').EventEmitter;\nvar constants = require('../../util/constants');\nvar MqttCon = require('mqtt-connection');\nvar Util = require('util');\nvar net = require('net');\n\nvar MqttClient = function(opts) {\n\tEventEmitter.call(this);\n\tthis.clientId = 'MQTT_ADMIN_' + Date.now();\n\tthis.id = opts.id;\n\tthis.requests = {};\n\tthis.connectedTimes = 1;\n\tthis.host = null;\n\tthis.port = null;\n\tthis.socket = null;\n\tthis.lastPing = -1;\n\tthis.lastPong = -1;\n\tthis.closed = false;\n\tthis.timeoutId = null;\n\tthis.connected = false;\n\tthis.reconnectId = null;\n\tthis.timeoutFlag = false;\n\tthis.keepaliveTimer = null;\n\tthis.reconnectDelay = 0;\n\tthis.reconnectDelayMax = opts.reconnectDelayMax || constants.DEFAULT_PARAM.RECONNECT_DELAY_MAX;\n\tthis.timeout = opts.timeout || constants.DEFAULT_PARAM.TIMEOUT;\n\tthis.keepalive = opts.keepalive || constants.DEFAULT_PARAM.KEEPALIVE;\n}\n\nUtil.inherits(MqttClient, EventEmitter);\n\nMqttClient.prototype.connect = function(host, port, cb) {\n\tcb = cb || function() {}\n\tif (this.connected) {\n\t\treturn cb(new Error('MqttClient has already connected.'));\n\t}\n\n\tif (host) {\n\t\tthis.host = host;\n\t} else {\n\t\thost = this.host;\n\t}\n\n\tif (port) {\n\t\tthis.port = port;\n\t} else {\n\t\tport = this.port;\n\t}\n\n\tvar self = this;\n\tthis.closed = false;\n\n\tvar stream = net.createConnection(this.port, this.host);\n\tthis.socket = MqttCon(stream);\n\n\t// logger.info('try to connect %s %s', this.host, this.port);\n\tthis.socket.connect({\n\t\tclientId: this.clientId\n\t});\n\n\tthis.addTimeout();\n\n\tthis.socket.on('connack', function() {\n\t\tif (self.connected) {\n\t\t\treturn;\n\t\t}\n\n\t\tself.connected = true;\n\n\t\tself.setupKeepAlive();\n\n\t\tif (self.connectedTimes++ == 1) {\n\t\t\tself.emit('connect');\n\t\t\tcb();\n\t\t} else {\n\t\t\tself.emit('reconnect');\n\t\t}\n\t});\n\n\tthis.socket.on('publish', function(pkg) {\n\t\tvar topic = pkg.topic;\n\t\tvar msg = pkg.payload.toString();\n\t\tmsg = JSON.parse(msg);\n\n\t\t// logger.debug('[MqttClient] publish %s %j', topic, msg);\n\t\tself.emit(topic, msg);\n\t});\n\n\tthis.socket.on('close', function() {\n\t\tlogger.error('mqtt socket is close, remote server host: %s, port: %s', host, port);\n\t\tself.onSocketClose();\n\t});\n\n\tthis.socket.on('error', function(err) {\n\t\tlogger.error('mqtt socket is error, remote server host: %s, port: %s', host, port);\n\t\t// self.emit('error', new Error('[MqttClient] socket is error, remote server ' + host + ':' + port));\n\t\tself.onSocketClose();\n\t});\n\n\tthis.socket.on('pingresp', function() {\n\t\tself.lastPong = Date.now();\n\t});\n\n\tthis.socket.on('disconnect', function() {\n\t\tlogger.error('mqtt socket is disconnect, remote server host: %s, port: %s', host, port);\n\t\tself.emit('disconnect', self.id);\n\t\tself.onSocketClose();\n\t});\n\n\tthis.socket.on('timeout', function(reconnectFlag) {\n\t\tif (reconnectFlag) {\n\t\t\tself.reconnect();\n\t\t} else {\n\t\t\tself.exit();\n\t\t}\n\t})\n}\n\nMqttClient.prototype.send = function(topic, msg) {\n\t// console.log('MqttClient send %s %j ~~~', topic, msg);\n\tthis.socket.publish({\n\t\ttopic: topic,\n\t\tpayload: JSON.stringify(msg)\n\t})\n}\n\nMqttClient.prototype.onSocketClose = function() {\n\t// console.log('onSocketClose ' + this.closed);\n\tif (this.closed) {\n\t\treturn;\n\t}\n\n\tclearInterval(this.keepaliveTimer);\n\tclearTimeout(this.timeoutId);\n\tthis.keepaliveTimer = null;\n\tthis.lastPing = -1;\n\tthis.lastPong = -1;\n\tthis.connected = false;\n\tthis.closed = true;\n\tdelete this.socket;\n\tthis.socket = null;\n\n\tif (this.connectedTimes > 1) {\n\t\tthis.reconnect();\n\t} else {\n\t\tthis.exit();\n\t}\n}\n\nMqttClient.prototype.addTimeout = function(reconnectFlag) {\n\tvar self = this;\n\tif (this.timeoutFlag) {\n\t\treturn;\n\t}\n\n\tthis.timeoutFlag = true;\n\n\tthis.timeoutId = setTimeout(function() {\n\t\tself.timeoutFlag = false;\n\t\tlogger.error('mqtt client connect %s:%d timeout %d s', self.host, self.port, self.timeout / 1000);\n\t\tself.socket.emit('timeout', reconnectFlag);\n\t}, self.timeout);\n}\n\nMqttClient.prototype.reconnect = function() {\n\tvar delay = this.reconnectDelay * 2 || constants.DEFAULT_PARAM.RECONNECT_DELAY;\n\tif (delay > this.reconnectDelayMax) {\n\t\tdelay = this.reconnectDelayMax;\n\t}\n\n\tthis.reconnectDelay = delay;\n\n\tvar self = this;\n\n\t// logger.debug('[MqttClient] reconnect %d ...', delay);\n\tthis.reconnectId = setTimeout(function() {\n\t\tlogger.info('reconnect delay %d s', delay / 1000);\n\t\tself.addTimeout(true);\n\t\tself.connect();\n\t}, delay);\n}\n\nMqttClient.prototype.setupKeepAlive = function() {\n\tclearTimeout(this.reconnectId);\n\tclearTimeout(this.timeoutId);\n\n\tvar self = this;\n\tthis.keepaliveTimer = setInterval(function() {\n\t\tself.checkKeepAlive();\n\t}, this.keepalive);\n}\n\nMqttClient.prototype.checkKeepAlive = function() {\n\tif (this.closed) {\n\t\treturn;\n\t}\n\n\tvar now = Date.now();\n\tvar KEEP_ALIVE_TIMEOUT = this.keepalive * 2;\n\tif (this.lastPing > 0) {\n\t\tif (this.lastPong < this.lastPing) {\n\t\t\tif (now - this.lastPing > KEEP_ALIVE_TIMEOUT) {\n\t\t\t\tlogger.error('mqtt rpc client checkKeepAlive error timeout for %d', KEEP_ALIVE_TIMEOUT);\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t} else {\n\t\t\tthis.socket.pingreq();\n\t\t\tthis.lastPing = Date.now();\n\t\t}\n\t} else {\n\t\tthis.socket.pingreq();\n\t\tthis.lastPing = Date.now();\n\t}\n}\n\nMqttClient.prototype.disconnect = function() {\n\tthis.close();\n}\n\nMqttClient.prototype.close = function() {\n\tthis.connected = false;\n\tthis.closed = true;\n\tthis.socket.disconnect();\n}\n\nMqttClient.prototype.exit = function() {\n\tlogger.info('exit ...');\n\tprocess.exit(0);\n}\n\nmodule.exports = MqttClient;","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/util/constants.js":"module.exports = {\n\tDEFAULT_PARAM: {\n\t\tKEEPALIVE: 60 * 1000,\n\t\tTIMEOUT: 5 * 1000,\n\t\tRECONNECT_DELAY: 1 * 1000,\n\t\tRECONNECT_DELAY_MAX: 60 * 1000\n\t},\n\tTYPE_CLIENT: 'client',\n\tTYPE_MONITOR: 'monitor'\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/util/protocol.js":"exports.composeRequest = function(id, moduleId, body) {\n\tif (id) {\n\t\t// request message\n\t\treturn JSON.stringify({\n\t\t\treqId: id,\n\t\t\tmoduleId: moduleId,\n\t\t\tbody: body\n\t\t});\n\t} else {\n\t\t// notify message\n\t\treturn {\n\t\t\tmoduleId: moduleId,\n\t\t\tbody: body\n\t\t};\n\t}\n};\n\nexports.composeResponse = function(req, err, res) {\n\tif (req.reqId) {\n\t\t// request only\n\t\treturn JSON.stringify({\n\t\t\trespId: req.reqId,\n\t\t\terror: cloneError(err),\n\t\t\tbody: res\n\t\t});\n\t}\n\t// invalid message(notify dose not need response)\n\treturn null;\n};\n\nexports.composeCommand = function(id, command, moduleId, body) {\n\tif (id) {\n\t\t// command message\n\t\treturn JSON.stringify({\n\t\t\treqId: id,\n\t\t\tcommand: command,\n\t\t\tmoduleId: moduleId,\n\t\t\tbody: body\n\t\t});\n\t} else {\n\t\treturn JSON.stringify({\n\t\t\tcommand: command,\n\t\t\tmoduleId: moduleId,\n\t\t\tbody: body\n\t\t});\n\t}\n}\n\nexports.parse = function(msg) {\n\tif (typeof msg === 'string') {\n\t\treturn JSON.parse(msg);\n\t}\n\treturn msg;\n};\n\nexports.isRequest = function(msg) {\n\treturn (msg && msg.reqId);\n};\n\nvar cloneError = function(origin) {\n\t// copy the stack infos for Error instance json result is empty\n\tif (!(origin instanceof Error)) {\n\t\treturn origin;\n\t}\n\tvar res = {\n\t\tmessage: origin.message,\n\t\tstack: origin.stack\n\t};\n\treturn res;\n};\n\nexports.PRO_OK = 1;\nexports.PRO_FAIL = -1;","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/util/utils.js":"var crypto = require('crypto');\nvar util = require('util');\nvar path = require('path');\nvar fs = require('fs');\n\nvar utils = module.exports;\n\n/**\n * Check and invoke callback\n */\nutils.invokeCallback = function(cb) {\n    if (!!cb && typeof cb === 'function') {\n        cb.apply(null, Array.prototype.slice.call(arguments, 1));\n    }\n};\n\n/*\n * Date format\n */\nutils.format = function(date, format) {\n    format = format || 'MM-dd-hhmm';\n    var o = {\n        \"M+\": date.getMonth() + 1, //month\n        \"d+\": date.getDate(), //day\n        \"h+\": date.getHours(), //hour\n        \"m+\": date.getMinutes(), //minute\n        \"s+\": date.getSeconds(), //second\n        \"q+\": Math.floor((date.getMonth() + 3) / 3), //quarter\n        \"S\": date.getMilliseconds() //millisecond\n    };\n\n    if (/(y+)/.test(format)) {\n        format = format.replace(RegExp.$1, (date.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n    }\n    for (var k in o) {\n        if (new RegExp(\"(\" + k + \")\").test(format)) {\n            format = format.replace(RegExp.$1,\n                RegExp.$1.length === 1 ? o[k] :\n                (\"00\" + o[k]).substr((\"\" + o[k]).length));\n        }\n    }\n\n    return format;\n};\n\nutils.compareServer = function(server1, server2) {\n    return (server1['host'] === server2['host']) &&\n        (server1['port'] === server2['port']);\n}\n\n/**\n * Get the count of elements of object\n */\nutils.size = function(obj, type) {\n    var count = 0;\n    for (var i in obj) {\n        if (obj.hasOwnProperty(i) && typeof obj[i] !== 'function') {\n            if (!type) {\n                count++;\n                continue;\n            }\n\n            if (type && type === obj[i]['type']) {\n                count++;\n            }\n        }\n    }\n    return count;\n};\n\nutils.md5 = function(str) {\n    var md5sum = crypto.createHash('md5');\n    md5sum.update(str);\n    str = md5sum.digest('hex');\n    return str;\n}\n\nutils.defaultAuthUser = function(msg, env, cb) {\n    var adminUser = null;\n    var appBase = path.dirname(require.main.filename);\n    var adminUserPath = path.join(appBase, '/config/adminUser.json');\n    var presentPath = path.join(appBase, 'config', env, 'adminUser.json');\n    if (fs.existsSync(adminUserPath)) {\n        adminUser = require(adminUserPath);\n    } else if (fs.existsSync(presentPath)) {\n        adminUser = require(presentPath);\n    } else {\n        cb(null);\n        return;\n    }\n    var username = msg['username'];\n    var password = msg['password'];\n    var md5 = msg['md5'];\n\n    var len = adminUser.length;\n    if (md5) {\n        for (var i = 0; i < len; i++) {\n            var user = adminUser[i];\n            var p = \"\";\n            if (user['username'] === username) {\n                p = utils.md5(user['password']);\n                if (password === p) {\n                    cb(user);\n                    return;\n                }\n            }\n        }\n    } else {\n        for (var i = 0; i < len; i++) {\n            var user = adminUser[i];\n            if (user['username'] === username && user['password'] === password) {\n                cb(user);\n                return;\n            }\n        }\n    }\n    cb(null);\n}\n\nutils.defaultAuthServerMaster = function(msg, env, cb) {\n    var id = msg['id'];\n    var type = msg['serverType'];\n    var token = msg['token'];\n    if (type === 'master') {\n        cb('ok');\n        return;\n    }\n\n    var servers = null;\n    var appBase = path.dirname(require.main.filename);\n    var serverPath = path.join(appBase, '/config/adminServer.json');\n    var presentPath = null;\n    if (env) {\n        presentPath = path.join(appBase, 'config', env, 'adminServer.json');\n    }\n\n    if (fs.existsSync(serverPath)) {\n        servers = require(serverPath);\n    } else if (fs.existsSync(presentPath)) {\n        servers = require(presentPath);\n    } else {\n        cb('ok');\n        return;\n    }\n\n    var len = servers.length;\n    for (var i = 0; i < len; i++) {\n        var server = servers[i];\n        if (server['type'] === type && server['token'] === token) {\n            cb('ok');\n            return;\n        }\n    }\n    cb('bad');\n    return;\n}\n\nutils.defaultAuthServerMonitor = function(msg, env, cb) {\n    var id = msg['id'];\n    var type = msg['serverType'];\n\n    var servers = null;\n    var appBase = path.dirname(require.main.filename);\n    var serverPath = path.join(appBase, '/config/adminServer.json');\n    var presentPath = null;\n    if (env) {\n        presentPath = path.join(appBase, 'config', env, 'adminServer.json');\n    }\n\n    if (fs.existsSync(serverPath)) {\n        servers = require(serverPath);\n    } else if (fs.existsSync(presentPath)) {\n        servers = require(presentPath);\n    } else {\n        cb('ok');\n        return;\n    }\n\n    var len = servers.length;\n    for (var i = 0; i < len; i++) {\n        var server = servers[i];\n        if (server['type'] === type) {\n            cb(server['token']);\n            return;\n        }\n    }\n    cb(null);\n    return;\n}","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/master/masterAgent.js":"var logger = require('pomelo-logger').getLogger('pomelo-admin', 'MasterAgent');\nvar MqttServer = require('../protocol/mqtt/mqttServer');\nvar EventEmitter = require('events').EventEmitter;\nvar MasterSocket = require('./masterSocket');\nvar protocol = require('../util/protocol');\nvar utils = require('../util/utils');\nvar Util = require('util');\n\nvar ST_INITED = 1;\nvar ST_STARTED = 2;\nvar ST_CLOSED = 3;\n\n/**\n * MasterAgent Constructor\n *\n * @class MasterAgent\n * @constructor\n * @param {Object} opts construct parameter\n *                 opts.consoleService {Object} consoleService\n *                 opts.id             {String} server id\n *                 opts.type           {String} server type, 'master', 'connector', etc.\n *                 opts.socket         {Object} socket-io object\n *                 opts.reqId          {Number} reqId add by 1\n *                 opts.callbacks      {Object} callbacks\n *                 opts.state          {Number} MasterAgent state\n * @api public\n */\nvar MasterAgent = function(consoleService, opts) {\n  EventEmitter.call(this);\n  this.reqId = 1;\n  this.idMap = {};\n  this.msgMap = {};\n  this.typeMap = {};\n  this.clients = {};\n  this.sockets = {};\n  this.slaveMap = {};\n  this.server = null;\n  this.callbacks = {};\n  this.state = ST_INITED;\n  this.whitelist = opts.whitelist;\n  this.consoleService = consoleService;\n};\n\nUtil.inherits(MasterAgent, EventEmitter);\n\n/**\n * master listen to a port and handle register and request\n *\n * @param {String} port\n * @api public\n */\nMasterAgent.prototype.listen = function(port, cb) {\n  if (this.state > ST_INITED) {\n    logger.error('master agent has started or closed.');\n    return;\n  }\n\n  this.state = ST_STARTED;\n  this.server = new MqttServer();\n  this.server.listen(port);\n  // this.server = sio.listen(port);\n  // this.server.set('log level', 0);\n\n  cb = cb || function() {}\n\n  var self = this;\n  this.server.on('error', function(err) {\n    self.emit('error', err);\n    cb(err);\n  });\n\n  this.server.once('listening', function() {\n    setImmediate(function() {\n      cb();\n    });\n  });\n\n  this.server.on('connection', function(socket) {\n    // var id, type, info, registered, username;\n    var masterSocket = new MasterSocket();\n    masterSocket['agent'] = self;\n    masterSocket['socket'] = socket;\n\n    self.sockets[socket.id] = socket;\n\n    socket.on('register', function(msg) {\n      // register a new connection\n      masterSocket.onRegister(msg);\n    }); // end of on 'register'\n\n    // message from monitor\n    socket.on('monitor', function(msg) {\n      masterSocket.onMonitor(msg);\n    }); // end of on 'monitor'\n\n    // message from client\n    socket.on('client', function(msg) {\n      masterSocket.onClient(msg);\n    }); // end of on 'client'\n\n    socket.on('reconnect', function(msg) {\n      masterSocket.onReconnect(msg);\n    });\n\n    socket.on('disconnect', function() {\n      masterSocket.onDisconnect();\n    });\n\n    socket.on('close', function() {\n      masterSocket.onDisconnect();\n    });\n\n    socket.on('error', function(err) {\n      masterSocket.onError(err);\n    });\n  }); // end of on 'connection'\n}; // end of listen\n\n/**\n * close master agent\n *\n * @api public\n */\nMasterAgent.prototype.close = function() {\n  if (this.state > ST_STARTED) {\n    return;\n  }\n  this.state = ST_CLOSED;\n  this.server.close();\n};\n\n/**\n * set module\n *\n * @param {String} moduleId module id/name\n * @param {Object} value module object\n * @api public\n */\nMasterAgent.prototype.set = function(moduleId, value) {\n  this.consoleService.set(moduleId, value);\n};\n\n/**\n * get module\n *\n * @param {String} moduleId module id/name\n * @api public\n */\nMasterAgent.prototype.get = function(moduleId) {\n  return this.consoleService.get(moduleId);\n};\n\n/**\n * getClientById\n *\n * @param {String} clientId\n * @api public\n */\nMasterAgent.prototype.getClientById = function(clientId) {\n  return this.clients[clientId];\n};\n\n/**\n * request monitor{master node} data from monitor\n *\n * @param {String} serverId\n * @param {String} moduleId module id/name\n * @param {Object} msg\n * @param {Function} callback function\n * @api public\n */\nMasterAgent.prototype.request = function(serverId, moduleId, msg, cb) {\n  if (this.state > ST_STARTED) {\n    return false;\n  }\n\n  cb = cb || function() {}\n\n  var curId = this.reqId++;\n  this.callbacks[curId] = cb;\n\n  if (!this.msgMap[serverId]) {\n    this.msgMap[serverId] = {};\n  }\n\n  this.msgMap[serverId][curId] = {\n    moduleId: moduleId,\n    msg: msg\n  }\n\n  var record = this.idMap[serverId];\n  if (!record) {\n    cb(new Error('unknown server id:' + serverId));\n    return false;\n  }\n\n  sendToMonitor(record.socket, curId, moduleId, msg);\n\n  return true;\n};\n\n/**\n * request server data from monitor by serverInfo{host:port}\n *\n * @param {String} serverId\n * @param {Object} serverInfo\n * @param {String} moduleId module id/name\n * @param {Object} msg\n * @param {Function} callback function\n * @api public\n */\nMasterAgent.prototype.requestServer = function(serverId, serverInfo, moduleId, msg, cb) {\n  if (this.state > ST_STARTED) {\n    return false;\n  }\n\n  var record = this.idMap[serverId];\n  if (!record) {\n    utils.invokeCallback(cb, new Error('unknown server id:' + serverId));\n    return false;\n  }\n\n  var curId = this.reqId++;\n  this.callbacks[curId] = cb;\n\n  if (utils.compareServer(record, serverInfo)) {\n    sendToMonitor(record.socket, curId, moduleId, msg);\n  } else {\n    var slaves = this.slaveMap[serverId];\n    for (var i = 0, l = slaves.length; i < l; i++) {\n      if (utils.compareServer(slaves[i], serverInfo)) {\n        sendToMonitor(slaves[i].socket, curId, moduleId, msg);\n        break;\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * notify a monitor{master node} by id without callback\n *\n * @param {String} serverId\n * @param {String} moduleId module id/name\n * @param {Object} msg\n * @api public\n */\nMasterAgent.prototype.notifyById = function(serverId, moduleId, msg) {\n  if (this.state > ST_STARTED) {\n    return false;\n  }\n\n  var record = this.idMap[serverId];\n  if (!record) {\n    logger.error('fail to notifyById for unknown server id:' + serverId);\n    return false;\n  }\n\n  sendToMonitor(record.socket, null, moduleId, msg);\n\n  return true;\n};\n\n/**\n * notify a monitor by server{host:port} without callback\n *\n * @param {String} serverId\n * @param {Object} serverInfo{host:port}\n * @param {String} moduleId module id/name\n * @param {Object} msg\n * @api public\n */\nMasterAgent.prototype.notifyByServer = function(serverId, serverInfo, moduleId, msg) {\n  if (this.state > ST_STARTED) {\n    return false;\n  }\n\n  var record = this.idMap[serverId];\n  if (!record) {\n    logger.error('fail to notifyByServer for unknown server id:' + serverId);\n    return false;\n  }\n\n  if (utils.compareServer(record, serverInfo)) {\n    sendToMonitor(record.socket, null, moduleId, msg);\n  } else {\n    var slaves = this.slaveMap[serverId];\n    for (var i = 0, l = slaves.length; i < l; i++) {\n      if (utils.compareServer(slaves[i], serverInfo)) {\n        sendToMonitor(slaves[i].socket, null, moduleId, msg);\n        break;\n      }\n    }\n  }\n  return true;\n};\n\n/**\n * notify slaves by id without callback\n *\n * @param {String} serverId\n * @param {String} moduleId module id/name\n * @param {Object} msg\n * @api public\n */\nMasterAgent.prototype.notifySlavesById = function(serverId, moduleId, msg) {\n  if (this.state > ST_STARTED) {\n    return false;\n  }\n\n  var slaves = this.slaveMap[serverId];\n  if (!slaves || slaves.length === 0) {\n    logger.error('fail to notifySlavesById for unknown server id:' + serverId);\n    return false;\n  }\n\n  broadcastMonitors(slaves, moduleId, msg);\n  return true;\n};\n\n/**\n * notify monitors by type without callback\n *\n * @param {String} type serverType\n * @param {String} moduleId module id/name\n * @param {Object} msg\n * @api public\n */\nMasterAgent.prototype.notifyByType = function(type, moduleId, msg) {\n  if (this.state > ST_STARTED) {\n    return false;\n  }\n\n  var list = this.typeMap[type];\n  if (!list || list.length === 0) {\n    logger.error('fail to notifyByType for unknown server type:' + type);\n    return false;\n  }\n  broadcastMonitors(list, moduleId, msg);\n  return true;\n};\n\n/**\n * notify all the monitors without callback\n *\n * @param {String} moduleId module id/name\n * @param {Object} msg\n * @api public\n */\nMasterAgent.prototype.notifyAll = function(moduleId, msg) {\n  if (this.state > ST_STARTED) {\n    return false;\n  }\n  broadcastMonitors(this.idMap, moduleId, msg);\n  return true;\n};\n\n/**\n * notify a client by id without callback\n *\n * @param {String} clientId\n * @param {String} moduleId module id/name\n * @param {Object} msg\n * @api public\n */\nMasterAgent.prototype.notifyClient = function(clientId, moduleId, msg) {\n  if (this.state > ST_STARTED) {\n    return false;\n  }\n\n  var record = this.clients[clientId];\n  if (!record) {\n    logger.error('fail to notifyClient for unknown client id:' + clientId);\n    return false;\n  }\n  sendToClient(record.socket, null, moduleId, msg);\n};\n\nMasterAgent.prototype.notifyCommand = function(command, moduleId, msg) {\n  if (this.state > ST_STARTED) {\n    return false;\n  }\n  broadcastCommand(this.idMap, command, moduleId, msg);\n  return true;\n};\n\n/**\n * add monitor,client to connection -- idMap\n *\n * @param {Object} agent agent object\n * @param {String} id\n * @param {String} type serverType\n * @param {Object} socket socket-io object\n * @api private\n */\nvar addConnection = function(agent, id, type, pid, info, socket) {\n  var record = {\n    id: id,\n    type: type,\n    pid: pid,\n    info: info,\n    socket: socket\n  };\n  if (type === 'client') {\n    agent.clients[id] = record;\n  } else {\n    if (!agent.idMap[id]) {\n      agent.idMap[id] = record;\n      var list = agent.typeMap[type] = agent.typeMap[type] || [];\n      list.push(record);\n    } else {\n      var slaves = agent.slaveMap[id] = agent.slaveMap[id] || [];\n      slaves.push(record);\n    }\n  }\n  return record;\n};\n\n/**\n * remove monitor,client connection -- idMap\n *\n * @param {Object} agent agent object\n * @param {String} id\n * @param {String} type serverType\n * @api private\n */\nvar removeConnection = function(agent, id, type, info) {\n  if (type === 'client') {\n    delete agent.clients[id];\n  } else {\n    // remove master node in idMap and typeMap\n    var record = agent.idMap[id];\n    if (!record) {\n      return;\n    }\n    var _info = record['info']; // info {host, port}\n    if (utils.compareServer(_info, info)) {\n      delete agent.idMap[id];\n      var list = agent.typeMap[type];\n      if (list) {\n        for (var i = 0, l = list.length; i < l; i++) {\n          if (list[i].id === id) {\n            list.splice(i, 1);\n            break;\n          }\n        }\n        if (list.length === 0) {\n          delete agent.typeMap[type];\n        }\n      }\n    } else {\n      // remove slave node in slaveMap\n      var slaves = agent.slaveMap[id];\n      if (slaves) {\n        for (var i = 0, l = slaves.length; i < l; i++) {\n          if (utils.compareServer(slaves[i]['info'], info)) {\n            slaves.splice(i, 1);\n            break;\n          }\n        }\n        if (slaves.length === 0) {\n          delete agent.slaveMap[id];\n        }\n      }\n    }\n  }\n};\n\n/**\n * send msg to monitor\n *\n * @param {Object} socket socket-io object\n * @param {Number} reqId request id\n * @param {String} moduleId module id/name\n * @param {Object} msg message\n * @api private\n */\nvar sendToMonitor = function(socket, reqId, moduleId, msg) {\n  doSend(socket, 'monitor', protocol.composeRequest(reqId, moduleId, msg));\n};\n\n/**\n * send msg to client\n *\n * @param {Object} socket socket-io object\n * @param {Number} reqId request id\n * @param {String} moduleId module id/name\n * @param {Object} msg message\n * @api private\n */\nvar sendToClient = function(socket, reqId, moduleId, msg) {\n  doSend(socket, 'client', protocol.composeRequest(reqId, moduleId, msg));\n};\n\nvar doSend = function(socket, topic, msg) {\n  socket.send(topic, msg);\n}\n\n/**\n * broadcast msg to monitor\n *\n * @param {Object} record registered modules\n * @param {String} moduleId module id/name\n * @param {Object} msg message\n * @api private\n */\nvar broadcastMonitors = function(records, moduleId, msg) {\n  msg = protocol.composeRequest(null, moduleId, msg);\n\n  if (records instanceof Array) {\n    for (var i = 0, l = records.length; i < l; i++) {\n      var socket = records[i].socket;\n      doSend(socket, 'monitor', msg);\n    }\n  } else {\n    for (var id in records) {\n      var socket = records[id].socket;\n      doSend(socket, 'monitor', msg);\n    }\n  }\n};\n\nvar broadcastCommand = function(records, command, moduleId, msg) {\n  msg = protocol.composeCommand(null, command, moduleId, msg);\n\n  if (records instanceof Array) {\n    for (var i = 0, l = records.length; i < l; i++) {\n      var socket = records[i].socket;\n      doSend(socket, 'monitor', msg);\n    }\n  } else {\n    for (var id in records) {\n      var socket = records[id].socket;\n      doSend(socket, 'monitor', msg);\n    }\n  }\n};\n\nMasterAgent.prototype.doAuthUser = function(msg, socket, cb) {\n  if (!msg.id) {\n    // client should has a client id\n    return cb(new Error('client should has a client id'));\n  }\n\n  var self = this;\n  var username = msg.username;\n  if (!username) {\n    // client should auth with username\n    doSend(socket, 'register', {\n      code: protocol.PRO_FAIL,\n      msg: 'client should auth with username'\n    });\n    return cb(new Error('client should auth with username'));\n  }\n\n  var authUser = self.consoleService.authUser;\n  var env = self.consoleService.env;\n  authUser(msg, env, function(user) {\n    if (!user) {\n      // client should auth with username\n      doSend(socket, 'register', {\n        code: protocol.PRO_FAIL,\n        msg: 'client auth failed with username or password error'\n      });\n      return cb(new Error('client auth failed with username or password error'));\n    }\n\n    if (self.clients[msg.id]) {\n      doSend(socket, 'register', {\n        code: protocol.PRO_FAIL,\n        msg: 'id has been registered. id:' + msg.id\n      });\n      return cb(new Error('id has been registered. id:' + msg.id));\n    }\n\n    logger.info('client user : ' + username + ' login to master');\n    addConnection(self, msg.id, msg.type, null, user, socket);\n    doSend(socket, 'register', {\n      code: protocol.PRO_OK,\n      msg: 'ok'\n    });\n\n    cb();\n  });\n};\n\nMasterAgent.prototype.doAuthServer = function(msg, socket, cb) {\n  var self = this;\n  var authServer = self.consoleService.authServer;\n  var env = self.consoleService.env;\n  authServer(msg, env, function(status) {\n    if (status !== 'ok') {\n      doSend(socket, 'register', {\n        code: protocol.PRO_FAIL,\n        msg: 'server auth failed'\n      });\n      cb(new Error('server auth failed'));\n      return;\n    }\n\n    var record = addConnection(self, msg.id, msg.serverType, msg.pid, msg.info, socket);\n\n    doSend(socket, 'register', {\n      code: protocol.PRO_OK,\n      msg: 'ok'\n    });\n    msg.info = msg.info || {}\n    msg.info.pid = msg.pid;\n    self.emit('register', msg.info);\n    cb(null);\n  });\n};\n\nMasterAgent.prototype.doSend = doSend;\n\nMasterAgent.prototype.sendToMonitor = sendToMonitor;\n\nMasterAgent.prototype.addConnection = addConnection;\n\nMasterAgent.prototype.removeConnection = removeConnection;\n\nmodule.exports = MasterAgent;","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/protocol/mqtt/mqttServer.js":"var logger = require('pomelo-logger').getLogger('pomelo-admin', 'MqttServer');\nvar EventEmitter = require('events').EventEmitter;\nvar MqttCon = require('mqtt-connection');\nvar Util = require('util');\nvar net = require('net');\n\nvar curId = 1;\n\nvar MqttServer = function(opts, cb) {\n\tEventEmitter.call(this);\n\tthis.inited = false;\n\tthis.closed = true;\n};\n\nUtil.inherits(MqttServer, EventEmitter);\n\nMqttServer.prototype.listen = function(port) {\n\t//check status\n\tif (this.inited) {\n\t\tthis.cb(new Error('already inited.'));\n\t\treturn;\n\t}\n\n\tthis.inited = true;\n\n\tvar self = this;\n\n\tthis.server = new net.Server();\n\tthis.server.listen(port);\n\n\tlogger.info('[MqttServer] listen on %d', port);\n\n\tthis.server.on('listening', this.emit.bind(this, 'listening'));\n\n\tthis.server.on('error', function(err) {\n\t\t// logger.error('mqtt server is error: %j', err.stack);\n\t\tself.emit('error', err);\n\t});\n\n\tthis.server.on('connection', function(stream) {\n\t\tvar socket = MqttCon(stream);\n\t\tsocket['id'] = curId++;\n\n\t\tsocket.on('connect', function(pkg) {\n\t\t\tsocket.connack({\n\t\t\t\treturnCode: 0\n\t\t\t});\n\t\t});\n\n\t\tsocket.on('publish', function(pkg) {\n\t\t\tvar topic = pkg.topic;\n\t\t\tvar msg = pkg.payload.toString();\n\t\t\tmsg = JSON.parse(msg);\n\n\t\t\t// logger.debug('[MqttServer] publish %s %j', topic, msg);\n\t\t\tsocket.emit(topic, msg);\n\t\t});\n\n\t\tsocket.on('pingreq', function() {\n\t\t\tsocket.pingresp();\n\t\t});\n\n\t\tsocket.send = function(topic, msg) {\n\t\t\tsocket.publish({\n\t\t\t\ttopic: topic,\n\t\t\t\tpayload: JSON.stringify(msg)\n\t\t\t});\n\t\t};\n\n\t\tself.emit('connection', socket);\n\t});\n};\n\nMqttServer.prototype.send = function(topic, msg) {\n\tthis.socket.publish({\n\t\ttopic: topic,\n\t\tpayload: msg\n\t});\n}\n\nMqttServer.prototype.close = function() {\n\tif (this.closed) {\n\t\treturn;\n\t}\n\n\tthis.closed = true;\n\tthis.server.close();\n\tthis.emit('closed');\n};\n\nmodule.exports = MqttServer;","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/master/masterSocket.js":"var logger = require('pomelo-logger').getLogger('pomelo-admin', 'MasterSocket');\nvar Constants = require('../util/constants');\nvar protocol = require('../util/protocol');\n\nvar MasterSocket = function() {\n\tthis.id = null;\n\tthis.type = null;\n\tthis.info = null;\n\tthis.agent = null;\n\tthis.socket = null;\n\tthis.username = null;\n\tthis.registered = false;\n}\n\nMasterSocket.prototype.onRegister = function(msg) {\n\tif (!msg || !msg.type) {\n\t\treturn;\n\t}\n\n\tvar self = this;\n\tvar serverId = msg.id;\n\tvar serverType = msg.type;\n\tvar socket = this.socket;\n\n\tif (serverType == Constants.TYPE_CLIENT) {\n\t\t// client connection not join the map\n\t\tthis.id = serverId;\n\t\tthis.type = serverType;\n\t\tthis.info = 'client';\n\t\tthis.agent.doAuthUser(msg, socket, function(err) {\n\t\t\tif (err) {\n\t\t\t\treturn socket.disconnect();\n\t\t\t}\n\n\t\t\tself.username = msg.username;\n\t\t\tself.registered = true;\n\t\t});\n\t\treturn;\n\t} // end of if(serverType === 'client')\n\n\tif (serverType == Constants.TYPE_MONITOR) {\n\t\tif (!serverId) {\n\t\t\treturn;\n\t\t}\n\n\t\t// if is a normal server\n\t\tthis.id = serverId;\n\t\tthis.type = msg.serverType;\n\t\tthis.info = msg.info;\n\t\tthis.agent.doAuthServer(msg, socket, function(err) {\n\t\t\tif (err) {\n\t\t\t\treturn socket.disconnect();\n\t\t\t}\n\n\t\t\tself.registered = true;\n\t\t});\n\n\t\tthis.repushQosMessage(serverId);\n\t\treturn;\n\t} // end of if(serverType === 'monitor') \n\n\tthis.agent.doSend(socket, 'register', {\n\t\tcode: protocol.PRO_FAIL,\n\t\tmsg: 'unknown auth master type'\n\t});\n\n\tsocket.disconnect();\n}\n\nMasterSocket.prototype.onMonitor = function(msg) {\n\tvar socket = this.socket;\n\tif (!this.registered) {\n\t\t// not register yet, ignore any message\n\t\t// kick connections\n\t\tsocket.disconnect();\n\t\treturn;\n\t}\n\n\tvar self = this;\n\tvar type = this.type;\n\tif (type === Constants.TYPE_CLIENT) {\n\t\tlogger.error('invalid message from monitor, but current connect type is client.');\n\t\treturn;\n\t}\n\n\tmsg = protocol.parse(msg);\n\tvar respId = msg.respId;\n\tif (respId) {\n\t\t// a response from monitor\n\t\tvar cb = self.agent.callbacks[respId];\n\t\tif (!cb) {\n\t\t\tlogger.warn('unknown resp id:' + respId);\n\t\t\treturn;\n\t\t}\n\n\t\tvar id = this.id;\n\t\tif (self.agent.msgMap[id]) {\n\t\t\tdelete self.agent.msgMap[id][respId];\n\t\t}\n\t\tdelete self.agent.callbacks[respId];\n\t\treturn cb(msg.error, msg.body);\n\t}\n\n\t// a request or a notify from monitor\n\tself.agent.consoleService.execute(msg.moduleId, 'masterHandler', msg.body, function(err, res) {\n\t\tif (protocol.isRequest(msg)) {\n\t\t\tvar resp = protocol.composeResponse(msg, err, res);\n\t\t\tif (resp) {\n\t\t\t\tself.agent.doSend(socket, 'monitor', resp);\n\t\t\t}\n\t\t} else {\n\t\t\t//notify should not have a callback\n\t\t\tlogger.warn('notify should not have a callback.');\n\t\t}\n\t});\n}\n\nMasterSocket.prototype.onClient = function(msg) {\n\tvar socket = this.socket;\n\tif (!this.registered) {\n\t\t// not register yet, ignore any message\n\t\t// kick connections\n\t\treturn socket.disconnect();\n\t}\n\n\tvar type = this.type;\n\tif (type !== Constants.TYPE_CLIENT) {\n\t\tlogger.error('invalid message to client, but current connect type is ' + type);\n\t\treturn;\n\t}\n\n\tmsg = protocol.parse(msg);\n\n\tvar msgCommand = msg.command;\n\tvar msgModuleId = msg.moduleId;\n\tvar msgBody = msg.body;\n\n\tvar self = this;\n\n\tif (msgCommand) {\n\t\t// a command from client\n\t\tself.agent.consoleService.command(msgCommand, msgModuleId, msgBody, function(err, res) {\n\t\t\tif (protocol.isRequest(msg)) {\n\t\t\t\tvar resp = protocol.composeResponse(msg, err, res);\n\t\t\t\tif (resp) {\n\t\t\t\t\tself.agent.doSend(socket, 'client', resp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//notify should not have a callback\n\t\t\t\tlogger.warn('notify should not have a callback.');\n\t\t\t}\n\t\t});\n\t} else {\n\t\t// a request or a notify from client\n\t\t// and client should not have any response to master for master would not request anything from client\n\t\tself.agent.consoleService.execute(msgModuleId, 'clientHandler', msgBody, function(err, res) {\n\t\t\tif (protocol.isRequest(msg)) {\n\t\t\t\tvar resp = protocol.composeResponse(msg, err, res);\n\t\t\t\tif (resp) {\n\t\t\t\t\tself.agent.doSend(socket, 'client', resp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//notify should not have a callback\n\t\t\t\tlogger.warn('notify should not have a callback.');\n\t\t\t}\n\t\t});\n\t}\n}\n\nMasterSocket.prototype.onReconnect = function(msg, pid) {\n\t// reconnect a new connection\n\tif (!msg || !msg.type) {\n\t\treturn;\n\t}\n\n\tvar serverId = msg.id;\n\tif (!serverId) {\n\t\treturn;\n\t}\n\n\tvar socket = this.socket;\n\n\t// if is a normal server\n\tif (this.agent.idMap[serverId]) {\n\t\t// id has been registered\n\t\tthis.agent.doSend(socket, 'reconnect_ok', {\n\t\t\tcode: protocol.PRO_FAIL,\n\t\t\tmsg: 'id has been registered. id:' + serverId\n\t\t});\n\t\treturn;\n\t}\n\n\tvar msgServerType = msg.serverType;\n\tvar record = this.agent.addConnection(this.agent, serverId, msgServerType, msg.pid, msg.info, socket);\n\n\tthis.id = serverId;\n\tthis.type = msgServerType;\n\tthis.registered = true;\n\tmsg.info.pid = pid;\n\tthis.info = msg.info;\n\tthis.agent.doSend(socket, 'reconnect_ok', {\n\t\tcode: protocol.PRO_OK,\n\t\tmsg: 'ok'\n\t});\n\n\tthis.agent.emit('reconnect', msg.info);\n\n\tthis.repushQosMessage(serverId);\n}\n\nMasterSocket.prototype.onDisconnect = function() {\n\tvar socket = this.socket;\n\tif (socket) {\n\t\tdelete this.agent.sockets[socket.id];\n\t}\n\n\tvar registered = this.registered;\n\tif (!registered) {\n\t\treturn;\n\t}\n\n\tvar id = this.id;\n\tvar type = this.type;\n\tvar info = this.info;\n\tvar username = this.username;\n\n\tlogger.debug('disconnect %s %s %j', id, type, info);\n\tif (registered) {\n\t\tthis.agent.removeConnection(this.agent, id, type, info);\n\t\tthis.agent.emit('disconnect', id, type, info);\n\t}\n\n\tif (type === Constants.TYPE_CLIENT && registered) {\n\t\tlogger.info('client user ' + username + ' exit');\n\t}\n\n\tthis.registered = false;\n\tthis.id = null;\n\tthis.type = null;\n}\n\nMasterSocket.prototype.repushQosMessage = function(serverId) {\n\tvar socket = this.socket;\n\t// repush qos message\n\tvar qosMsgs = this.agent.msgMap[serverId];\n\n\tif (!qosMsgs) {\n\t\treturn;\n\t}\n\n\tlogger.debug('repush qos message %j', qosMsgs);\n\n\tfor (var reqId in qosMsgs) {\n\t\tvar qosMsg = qosMsgs[reqId];\n\t\tvar moduleId = qosMsg['moduleId'];\n\t\tvar tmsg = qosMsg['msg'];\n\n\t\tthis.agent.sendToMonitor(socket, reqId, moduleId, tmsg);\n\t}\n}\n\nMasterSocket.prototype.onError = function(err) {\n\t// logger.error('server %s error %s', this.id, err.stack);\n\t// this.onDisconnect();\n}\n\nmodule.exports = MasterSocket;","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/node_modules/pomelo-scheduler/lib/schedule.js":"/**\n * The main class and interface of the schedule module\n */\nvar PriorityQueue = require('./priorityQueue');\nvar Job = require('./job.js');\nvar timerCount = 0;\n\nvar logger = require('log4js').getLogger(__filename);\n\nvar map = {};\nvar queue = PriorityQueue.createPriorityQueue(comparator);\n\nvar jobId = 0;\nvar timer;\n\n//The accuracy of the scheduler, it will affect the performance when the schedule tasks are\n//crowded together\nvar accuracy = 10;\n\n/**\n * Schedule a new Job\n */\nfunction scheduleJob(trigger, jobFunc, jobData){\n  var job = Job.createJob(trigger, jobFunc, jobData);\n  var excuteTime = job.excuteTime();\n  var id = job.id;\n\n  map[id] = job;\n  var element = {\n    id : id,\n    time : excuteTime\n  };\n\n  var curJob = queue.peek();\n  if(!curJob || excuteTime < curJob.time){\n    queue.offer(element);\n    setTimer(job);\n\n    return job.id;\n  }\n\n  queue.offer(element);\n  return job.id;\n}\n\n/**\n * Cancel Job\n */\nfunction cancelJob(id){\n  var curJob = queue.peek();\n  if(curJob && id === curJob.id){ // to avoid queue.peek() is null\n    queue.pop();\n    delete map[id];\n\n    clearTimeout(timer);\n    excuteJob();\n  }\n  delete map[id];\n  return true;\n}\n\n/**\n * Clear last timeout and schedule the next job, it will automaticly run the job that\n * need to run now\n * @param job The job need to schedule\n * @return void\n */\nfunction setTimer(job){\n  clearTimeout(timer);\n\n  timer = setTimeout(excuteJob, job.excuteTime()-Date.now());\n}\n\n/**\n * The function used to ran the schedule job, and setTimeout for next running job\n */\nfunction excuteJob(){\n  var job = peekNextJob();\n  var nextJob;\n\n  while(!!job && (job.excuteTime()-Date.now())<accuracy){\n    job.run();\n    queue.pop();\n\n    var nextTime = job.nextTime();\n\n    if(nextTime === null){\n      delete map[job.id];\n    }else{\n      queue.offer({id:job.id, time: nextTime});\n    }\n    job = peekNextJob();\n  }\n\n  //If all the job have been canceled\n  if(!job)\n    return;\n\n  //Run next schedule\n  setTimer(job);\n}\n\n/**\n * Return, but not remove the next valid job\n * @return Next valid job\n */\nfunction peekNextJob(){\n  if(queue.size() <= 0)\n    return null;\n\n  var job = null;\n\n  do{\n    job = map[queue.peek().id];\n    if(!job) queue.pop();\n  }while(!job && queue.size() > 0);\n\n  return (!!job)?job:null;\n}\n\n/**\n * Return and remove the next valid job\n * @return Next valid job\n */\nfunction getNextJob(){\n  var job = null;\n\n  while(!job && queue.size() > 0){\n    var id = queue.pop().id;\n    job = map[id];\n  }\n\n  return (!!job)?job:null;\n}\n\nfunction comparator(e1, e2){\n  return e1.time > e2.time;\n}\n\nmodule.exports.scheduleJob = scheduleJob;\nmodule.exports.cancelJob = cancelJob;\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/node_modules/pomelo-scheduler/lib/priorityQueue.js":"/**\n * The PriorityQeueu class\n */\nvar PriorityQueue = function(comparator){\n  this.init(comparator);\n}\n\nvar pro = PriorityQueue.prototype;\n\npro.init = function(comparator){\n  this._comparator = typeof(comparator)=='function'?comparator:this._defaultComparator;\n  \n  this._queue = [];\n  this._tailPos = 0;\n}\n\n/**\n * Return the size of the pirority queue\n * @return PirorityQueue size\n */\npro.size = function(){\n  return this._tailPos;\n};\n  \n/**\n * Insert an element to the queue\n * @param element The element to insert\n */\npro.offer = function(element){\n  var queue = this._queue;\n  var compare = this._comparator;\n  \n  queue[this._tailPos++] = element;\n  \n  var pos = this._tailPos-1;\n  \n  while(pos > 0){\n    var parentPos = (pos%2==0)?(pos/2-1):(pos-1)/2;\n    if(compare(queue[parentPos], element)){\n      queue[pos] = queue[parentPos];\n      queue[parentPos] = element;\n      \n      pos = parentPos;\n    }else{\n      break;\n    }\n  }\n};\n          \n/**\n * Get and remove the first element in the queue\n * @return The first element\n */        \npro.pop = function(){\n  var queue = this._queue;\n  var compare = this._comparator;\n  \n  if(this._tailPos == 0)\n    return null;\n  \n  \n  var headNode = queue[0];\n  \n  var tail = queue[this._tailPos - 1];\n\n  var pos = 0;\n  var left = pos*2 + 1;\n  var right = left + 1;\n  queue[pos] = tail;\n  this._tailPos--;\n  \n  while(left < this._tailPos){    \n    if(right<this._tailPos && compare(queue[left], queue[right]) && compare(queue[pos], queue[right])){\n      queue[pos] = queue[right];\n      queue[right] = tail;\n      \n      pos = right;\n    }else if(compare(queue[pos],queue[left])){\n      queue[pos] = queue[left];\n      queue[left] = tail;\n      \n      pos = left;\n    }else{\n      break;\n    }\n    \n    left = pos*2 + 1;\n    right = left + 1;\n  }\n  \n  return headNode;\n};\n\n/**\n * Get but not remove the first element in the queue\n * @return The first element\n */\npro.peek = function(){\n  if(this._tailPos == 0)\n    return null;\n  return this._queue[0];\n}\n\npro._defaultComparator = function(a , b){\n  return a > b;\n}\n\nmodule.exports.createPriorityQueue = function(comparator){\n  return new PriorityQueue(comparator);\n}","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/node_modules/pomelo-scheduler/lib/job.js":"/**\n * This is the class of the job used in schedule module\n */\nvar cronTrigger = require('./cronTrigger');\nvar simpleTrigger = require('./simpleTrigger');\n\nvar jobId = 1;\n\nvar SIMPLE_JOB = 1;\nvar CRON_JOB  = 2;\nvar jobCount = 0;\n\nvar warnLimit = 500;\n\nvar logger = require('log4js').getLogger(__filename);\n\n\n//For test\nvar lateCount = 0;\n\nvar Job = function(trigger, jobFunc, jobData){\n  this.data = (!!jobData)?jobData:null;\n  this.func = jobFunc;\n\n  if(typeof(trigger) == 'string'){\n    this.type = CRON_JOB;\n    this.trigger = cronTrigger.createTrigger(trigger, this);\n  }else if(typeof(trigger) == 'object'){\n    this.type = SIMPLE_JOB;\n    this.trigger = simpleTrigger.createTrigger(trigger, this);\n  }\n\n  this.id = jobId++;\n  this.runTime = 0;\n};\n\nvar pro = Job.prototype;\n\n/**\n * Run the job code\n */\npro.run = function(){\n  try{\n    jobCount++;\n    this.runTime++;\n    var late = Date.now() - this.excuteTime();\n    if(late>warnLimit)\n      logger.warn('run Job count ' + jobCount + ' late :' + late + ' lateCount ' + (++lateCount));\n    this.func(this.data);\n  }catch(e){\n    logger.error(\"Job run error for exception ! \" + e.stack);\n  }\n};\n\n/**\n * Compute the next excution time\n */\npro.nextTime = function(){\n  return this.trigger.nextExcuteTime();\n};\n\npro.excuteTime = function(){\n    return this.trigger.excuteTime();\n};\n\n/**\n * The Interface to create Job\n * @param trigger The trigger to use\n * @param jobFunc The function the job to run\n * @param jobDate The date the job use\n * @return The new instance of the give job or null if fail\n */\nfunction createJob(trigger, jobFunc, jobData){\n  return new Job(trigger, jobFunc, jobData);\n}\n\nmodule.exports.createJob = createJob;","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/node_modules/pomelo-scheduler/lib/cronTrigger.js":"/**\n * This is the trigger used to decode the cronTimer and calculate the next excution time of the cron Trigger.\n */\nvar logger = require('log4js').getLogger(__filename);\n\nvar SECOND = 0;\nvar MIN = 1;\nvar HOUR = 2;\nvar DOM = 3;\nvar MONTH = 4;\nvar DOW = 5;\n\nvar Limit = [[0,59],[0,59],[0,24],[1,31],[0,11],[0,6]];\n\n/**\n * The constructor of the CronTrigger\n * @param trigger The trigger str used to build the cronTrigger instance\n */\nvar CronTrigger = function(trigger, job){\n  this.trigger = this.decodeTrigger(trigger);\n\n  this.nextTime = this.nextExcuteTime(Date.now());\n\n  this.job = job;\n};\n\nvar pro = CronTrigger.prototype;\n\n/**\n * Get the current excuteTime of trigger\n */\npro.excuteTime = function(){\n  return this.nextTime;\n};\n\n/**\n * Caculate the next valid cronTime after the given time\n * @param The given time point\n * @return The nearest valid time after the given time point\n */\npro.nextExcuteTime = function(time){\n  //add 1s to the time so it must be the next time\n  time = !!time?time:this.nextTime;\n  time += 1000;\n\n  var cronTrigger = this.trigger;\n  var date = new Date(time);\n  date.setMilliseconds(0);\n\n  outmost:\n  while(true){\n    if(date.getFullYear() > 2999){\n      logger.error(\"Can't compute the next time, exceed the limit\");\n      return null;\n    }\n    if(!timeMatch(date.getMonth(), cronTrigger[MONTH])){\n      var nextMonth = nextCronTime(date.getMonth(), cronTrigger[MONTH]);\n\n      if(nextMonth == null)\n        return null;\n\n      if(nextMonth <= date.getMonth()){\n        date.setYear(date.getFullYear() + 1);\n        date.setMonth(0);\n        date.setDate(1);\n        date.setHours(0);\n        date.setMinutes(0);\n        date.setSeconds(0);\n        continue;\n      }\n      date.setMonth(nextMonth);\n\n      date.setDate(1);\n      date.setHours(0);\n      date.setMinutes(0);\n      date.setSeconds(0);\n    }\n\n    if(!timeMatch(date.getDate(), cronTrigger[DOM]) || !timeMatch(date.getDay(), cronTrigger[DOW])){\n      var domLimit = getDomLimit(date.getFullYear(), date.getMonth());\n\n      do{\n        var nextDom = nextCronTime(date.getDate(), cronTrigger[DOM]);\n        if(nextDom == null)\n          return null;\n\n        //If the date is in the next month, add month\n        if(nextDom <= date.getDate() || nextDom > domLimit){\n          date.setMonth(date.getMonth() + 1);\n          date.setDate(1);\n          date.setHours(0);\n          date.setMinutes(0);\n          date.setSeconds(0);\n          continue outmost;\n        }\n\n         date.setDate(nextDom);\n      }while(!timeMatch(date.getDay(), cronTrigger[DOW]));\n\n      date.setHours(0);\n      date.setMinutes(0);\n      date.setSeconds(0);\n    }\n\n    if(!timeMatch(date.getHours(), cronTrigger[HOUR])){\n      var nextHour = nextCronTime(date.getHours(), cronTrigger[HOUR]);\n\n      if(nextHour <= date.getHours()){\n         date.setDate(date.getDate() + 1);\n         date.setHours(nextHour);\n         date.setMinutes(0);\n         date.setSeconds(0);\n         continue;\n      }\n\n      date.setHours(nextHour);\n      date.setMinutes(0);\n      date.setSeconds(0);\n    }\n\n    if(!timeMatch(date.getMinutes(), cronTrigger[MIN])){\n      var nextMinute = nextCronTime(date.getMinutes(), cronTrigger[MIN]);\n\n      if(nextMinute <= date.getMinutes()){\n         date.setHours(date.getHours() + 1);\n         date.setMinutes(nextMinute);\n         date.setSeconds(0);\n         continue;\n      }\n\n      date.setMinutes(nextMinute);\n      date.setSeconds(0);\n    }\n\n    if(!timeMatch(date.getSeconds(), cronTrigger[SECOND])){\n      var nextSecond = nextCronTime(date.getSeconds(), cronTrigger[SECOND]);\n\n      if(nextSecond <= date.getSeconds()){\n         date.setMinutes(date.getMinutes() + 1);\n         date.setSeconds(nextSecond);\n         continue;\n      }\n\n      date.setSeconds(nextSecond);\n    }\n    break;\n  }\n\n  this.nextTime = date.getTime();\n  return this.nextTime;\n};\n\n/**\n * return the next match time of the given value\n * @param value The time value\n * @param cronTime The cronTime need to match\n * @return The match value or null if unmatch(it offten means an error occur).\n */\nfunction nextCronTime(value, cronTime){\n  value += 1;\n\n  if(typeof(cronTime) == 'number'){\n    if(cronTime == -1)\n      return value;\n    else\n      return cronTime;\n  }else if(typeof(cronTime) == 'object' && cronTime instanceof Array){\n    if(value <= cronTime[0] || value > cronTime[cronTime.length -1])\n      return cronTime[0];\n\n    for(var i = 0; i < cronTime.length; i++)\n      if(value <= cronTime[i])\n        return cronTime[i];\n  }\n\n  logger.warn('Compute next Time error! value :' + value + ' cronTime : ' + cronTime);\n  return null;\n}\n\n/**\n * Match the given value to the cronTime\n * @param value The given value\n * @param cronTime The cronTime\n * @return The match result\n */\nfunction timeMatch(value, cronTime){\n  if(typeof(cronTime) == 'number'){\n    if(cronTime == -1)\n      return true;\n    if(value == cronTime)\n      return true;\n    return false;\n  }else if(typeof(cronTime) == 'object' && cronTime instanceof Array){\n    if(value < cronTime[0] || value > cronTime[cronTime.length -1])\n      return false;\n\n    for(var i = 0; i < cronTime.length; i++)\n      if(value == cronTime[i])\n        return true;\n\n    return false;\n  }\n\n  return null;\n}\n\n/**\n * Decude the cronTrigger string to arrays\n * @param cronTimeStr The cronTimeStr need to decode, like \"0 12 * * * 3\"\n * @return The array to represent the cronTimer\n */\npro.decodeTrigger = function(cronTimeStr){\n  var cronTimes = cronTimeStr.split(/\\s+/);\n\n  if(cronTimes.length != 6){\n    console.log('error');\n    return null;\n  }\n\n  for(var i = 0; i < cronTimes.length; i++){\n    cronTimes[i] = (this.decodeTimeStr(cronTimes[i], i));\n\n    if(!checkNum(cronTimes[i], Limit[i][0], Limit[i][1])){\n      logger.error('Decode crontime error, value exceed limit!' +\n        JSON.stringify({cronTime: cronTimes[i], limit:Limit[i]}));\n      return null;\n    }\n  }\n\n  return cronTimes;\n}\n\n/**\n * Decode the cron Time string\n * @param timeStr The cron time string, like: 1,2 or 1-3\n * @return A sorted array, like [1,2,3]\n */\npro.decodeTimeStr = function(timeStr, type){\n  var result = {};\n  var arr = [];\n\n  if(timeStr=='*'){\n    return -1;\n  }else if(timeStr.search(',')>0){\n    var timeArr = timeStr.split(',');\n    for(var i = 0; i < timeArr.length; i++){\n      var time = timeArr[i];\n      if(time.match(/^\\d+-\\d+$/)){\n        decodeRangeTime(result, time);\n      }else if(time.match(/^\\d+\\/\\d+/)){\n        decodePeriodTime(result, time, type);\n      }else if(!isNaN(time)){\n        var num = Number(time);\n        result[num] = num;\n      }else\n        return null;\n    }\n  }else if(timeStr.match(/^\\d+-\\d+$/)){\n    decodeRangeTime(result, timeStr);\n  }else if(timeStr.match(/^\\d+\\/\\d+/)){\n    decodePeriodTime(result, timeStr, type);\n  }else if(!isNaN(timeStr)){\n    var num = Number(timeStr);\n    result[num] = num;\n  }else{\n    return null;\n  }\n\n  for(var key in result){\n    arr.push(result[key]);\n  }\n\n  arr.sort(function(a, b){\n    return a - b;\n  });\n\n  return arr;\n}\n\n/**\n * Decode time range\n * @param map The decode map\n * @param timeStr The range string, like 2-5\n */\nfunction decodeRangeTime(map, timeStr){\n  var times = timeStr.split('-');\n\n  times[0] = Number(times[0]);\n  times[1] = Number(times[1]);\n  if(times[0] > times[1]){\n    console.log(\"Error time range\");\n    return null;\n  }\n\n  for(var i = times[0]; i <= times[1]; i++){\n    map[i] = i;\n  }\n}\n\n/**\n * Compute the period timer\n */\nfunction decodePeriodTime(map, timeStr, type){\n  var times = timeStr.split('/');\n  var min = Limit[type][0];\n  var max = Limit[type][1];\n\n  var remind = Number(times[0]);\n  var period = Number(times[1]);\n\n  if(period==0)\n    return;\n\n  for(var i = min; i <= max; i++){\n    if(i%period == remind)\n      map[i] = i;\n  }\n}\n\n/**\n * Check if the numbers are valid\n * @param nums The numbers array need to check\n * @param min Minimus value\n * @param max Maximam value\n * @return If all the numbers are in the data range\n */\nfunction checkNum(nums, min, max){\n  if(nums == null)\n    return false;\n\n  if(nums == -1)\n    return true;\n\n  for(var i = 0; i < nums.length; i++){\n    if(nums[i]<min || nums[i]>max)\n      return false;\n  }\n\n  return true;\n}\n\n/**\n * Get the date limit of given month\n * @param The given year\n * @month The given month\n * @return The date count of given month\n */\nfunction getDomLimit(year, month){\n  var date = new Date(year, month+1, 0);\n\n  return date.getDate();\n}\n\n/**\n * Create cronTrigger\n * @param trigger The Cron Trigger string\n * @return The Cron trigger\n */\nfunction createTrigger(trigger, job){\n  return new CronTrigger(trigger, job);\n}\n\nmodule.exports.createTrigger = createTrigger;\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/node_modules/pomelo-scheduler/lib/simpleTrigger.js":"/**\n * This is the tirgger that use an object as trigger.\n */\nvar SKIP_OLD_JOB = false;\n\n/**\n * The constructor of simple trigger\n */\nvar SimpleTrigger = function(trigger, job){\n  this.nextTime = (!!trigger.start)?trigger.start:Date.now();\n\n  //The rec\n  this.period = (!!trigger.period)?trigger.period:-1;\n\n  //The running count of the job, -1 means no limit\n  this.count = (!!trigger.count)?trigger.count:-1;\n\n  this.job = job;\n};\n\nvar pro = SimpleTrigger.prototype;\n\n/**\n * Get the current excuteTime of rigger\n */\npro.excuteTime = function(){\n  return this.nextTime;\n};\n\n/**\n * Get the next excuteTime of the trigger, and set the trigger's excuteTime\n * @return Next excute time\n */\npro.nextExcuteTime = function(){\n  var period = this.period;\n\n  if((this.count > 0 && this.count <= this.job.runTime) || period <= 0)\n    return null;\n\n  this.nextTime += period;\n\n  if(SKIP_OLD_JOB && this.nextTime < Date.now()){\n    this.nextTime += Math.floor((Date.now()-this.nextTime)/period) * period;\n  }\n\n  return this.nextTime;\n};\n\n/**\n * Create Simple trigger\n */\nfunction createTrigger(trigger, job){\n  return new SimpleTrigger(trigger, job);\n}\n\nmodule.exports.createTrigger = createTrigger;","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/client/client.js":"/*!\n * Pomelo -- commandLine Client\n * Copyright(c) 2015 fantasyni <fantasyni@163.com>\n * MIT Licensed\n */\n\nvar MqttClient = require('../protocol/mqtt/mqttClient');\nvar protocol = require('../util/protocol');\n// var io = require('socket.io-client');\nvar utils = require('../util/utils');\n\nvar Client = function(opt) {\n\tthis.id = \"\";\n\tthis.reqId = 1;\n\tthis.callbacks = {};\n\tthis.listeners = {};\n\tthis.state = Client.ST_INITED;\n\tthis.socket = null;\n\topt = opt || {};\n\tthis.username = opt['username'] || \"\";\n\tthis.password = opt['password'] || \"\";\n\tthis.md5 = opt['md5'] || false;\n};\n\nClient.prototype = {\n\tconnect: function(id, host, port, cb) {\n\t\tthis.id = id;\n\t\tvar self = this;\n\n\t\tconsole.log('try to connect ' + host + ':' + port);\n\t\tthis.socket = new MqttClient({\n\t\t\tid: id\n\t\t});\n\n\t\tthis.socket.connect(host, port);\n\n\t\t// this.socket = io.connect('http://' + host + ':' + port, {\n\t\t// \t'force new connection': true,\n\t\t// \t'reconnect': false\n\t\t// });\n\n\t\tthis.socket.on('connect', function() {\n\t\t\tself.state = Client.ST_CONNECTED;\n\t\t\tif (self.md5) {\n\t\t\t\tself.password = utils.md5(self.password);\n\t\t\t}\n\t\t\tself.doSend('register', {\n\t\t\t\ttype: \"client\",\n\t\t\t\tid: id,\n\t\t\t\tusername: self.username,\n\t\t\t\tpassword: self.password,\n\t\t\t\tmd5: self.md5\n\t\t\t});\n\t\t});\n\n\t\tthis.socket.on('register', function(res) {\n\t\t\tif (res.code !== protocol.PRO_OK) {\n\t\t\t\tcb(res.msg);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tself.state = Client.ST_REGISTERED;\n\t\t\tcb();\n\t\t});\n\n\t\tthis.socket.on('client', function(msg) {\n\t\t\tmsg = protocol.parse(msg);\n\t\t\tif (msg.respId) {\n\t\t\t\t// response for request\n\t\t\t\tvar cb = self.callbacks[msg.respId];\n\t\t\t\tdelete self.callbacks[msg.respId];\n\t\t\t\tif (cb && typeof cb === 'function') {\n\t\t\t\t\tcb(msg.error, msg.body);\n\t\t\t\t}\n\t\t\t} else if (msg.moduleId) {\n\t\t\t\t// notify\n\t\t\t\tself.emit(msg.moduleId, msg);\n\t\t\t}\n\t\t});\n\n\t\tthis.socket.on('error', function(err) {\n\t\t\tif (self.state < Client.ST_CONNECTED) {\n\t\t\t\tcb(err);\n\t\t\t}\n\n\t\t\tself.emit('error', err);\n\t\t});\n\n\t\tthis.socket.on('disconnect', function(reason) {\n\t\t\tthis.state = Client.ST_CLOSED;\n\t\t\tself.emit('close');\n\t\t});\n\t},\n\n\trequest: function(moduleId, msg, cb) {\n\t\tvar id = this.reqId++;\n\t\t// something dirty: attach current client id into msg\n\t\tmsg = msg || {};\n\t\tmsg.clientId = this.id;\n\t\tmsg.username = this.username;\n\t\tvar req = protocol.composeRequest(id, moduleId, msg);\n\t\tthis.callbacks[id] = cb;\n\t\tthis.doSend('client', req);\n\t\t// this.socket.emit('client', req);\n\t},\n\n\tnotify: function(moduleId, msg) {\n\t\t// something dirty: attach current client id into msg\n\t\tmsg = msg || {};\n\t\tmsg.clientId = this.id;\n\t\tmsg.username = this.username;\n\t\tvar req = protocol.composeRequest(null, moduleId, msg);\n\t\tthis.doSend('client', req);\n\t\t// this.socket.emit('client', req);\n\t},\n\n\tcommand: function(command, moduleId, msg, cb) {\n\t\tvar id = this.reqId++;\n\t\tmsg = msg || {};\n\t\tmsg.clientId = this.id;\n\t\tmsg.username = this.username;\n\t\tvar commandReq = protocol.composeCommand(id, command, moduleId, msg);\n\t\tthis.callbacks[id] = cb;\n\t\tthis.doSend('client', commandReq);\n\t\t// this.socket.emit('client', commandReq);\n\t},\n\n\tdoSend: function(topic, msg) {\n\t\tthis.socket.send(topic, msg);\n\t},\n\n\ton: function(event, listener) {\n\t\tthis.listeners[event] = this.listeners[event] || [];\n\t\tthis.listeners[event].push(listener);\n\t},\n\n\temit: function(event) {\n\t\tvar listeners = this.listeners[event];\n\t\tif (!listeners || !listeners.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\t\tvar listener;\n\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\n\t\t\tlistener = listeners[i];\n\t\t\tif (typeof listener === 'function') {\n\t\t\t\tlistener.apply(null, args);\n\t\t\t}\n\t\t}\n\t}\n};\n\nClient.ST_INITED = 1;\nClient.ST_CONNECTED = 2;\nClient.ST_REGISTERED = 3;\nClient.ST_CLOSED = 4;\n\nmodule.exports = Client;","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/modules/monitorLog.js":"/*!\n * Pomelo -- consoleModule monitorLog\n * Copyright(c) 2012 fantasyni <fantasyni@163.com>\n * MIT Licensed\n */\nvar logger = require('pomelo-logger').getLogger('pomelo-admin', __filename);\nvar exec = require('child_process').exec;\nvar path = require('path');\n\nvar DEFAULT_INTERVAL = 5 * 60;\t\t// in second\n\nmodule.exports = function(opts) {\n\treturn new Module(opts);\n};\n\nmodule.exports.moduleId = 'monitorLog';\n\n/**\n * Initialize a new 'Module' with the given 'opts'\n *\n * @class Module\n * @constructor\n * @param {object} opts\n * @api public\n */\nvar Module = function(opts) {\n\topts = opts || {};\n\tthis.root = opts.path;\n\tthis.interval = opts.interval || DEFAULT_INTERVAL;\n};\n\n /**\n * collect monitor data from monitor\n *\n * @param {Object} agent monitorAgent object\n * @param {Object} msg client message\n * @param {Function} cb callback function\n * @api public\n */\nModule.prototype.monitorHandler = function(agent, msg, cb) {\n\tif(!msg.logfile) {\n\t\tcb(new Error('logfile should not be empty'));\n\t\treturn;\n\t}\n\n\tvar serverId = agent.id;\n\tfetchLogs(this.root, msg, function (data) {\n\t\tcb(null, {serverId: serverId, body: data});\n\t});\n};\n\n/**\n * Handle client request\n *\n * @param {Object} agent masterAgent object\n * @param {Object} msg client message\n * @param {Function} cb callback function\n * @api public\n */\nModule.prototype.clientHandler = function(agent, msg, cb) {\n\tagent.request(msg.serverId, module.exports.moduleId, msg, function(err, res) {\n\t\tif(err) {\n\t\t\tlogger.error('fail to run log for ' + err.stack);\n\t\t\treturn;\n\t\t}\n\t\tcb(null, res);\n\t});\n};\n\n//get the latest logs\nvar fetchLogs = function(root, msg, callback) {\n\tvar number = msg.number;\n\tvar logfile = msg.logfile;\n\tvar serverId = msg.serverId;\n\tvar filePath = path.join(root, getLogFileName(logfile, serverId));\n\n\tvar endLogs = [];\n\texec('tail -n ' + number + ' ' + filePath, function(error, output) {\n\t\tvar endOut = [];\n\t\toutput = output.replace(/^\\s+|\\s+$/g, \"\").split(/\\s+/);\n\n\t\tfor(var i=5; i<output.length; i+=6) {\n\t\t\tendOut.push(output[i]);\n\t\t}\n\n\t\tvar endLength=endOut.length;\n\t\tfor(var j=0; j<endLength; j++) {\n\t\t\tvar map = {};\n\t\t\tvar json;\n\t\t\ttry{\n\t\t\t\tjson = JSON.parse(endOut[j]);\n\t\t\t} catch(e) {\n\t\t\t\tlogger.error('the log cannot parsed to json, '+e);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap.time = json.time;\n\t\t\tmap.route = json.route || json.service;\n\t\t\tmap.serverId = serverId;\n\t\t\tmap.timeUsed = json.timeUsed;\n\t\t\tmap.params = endOut[j];\n\t\t\tendLogs.push(map);\n\t\t}\n\n\t\tcallback({logfile:logfile,dataArray:endLogs});\n\t});\n};\n\nvar getLogFileName = function(logfile, serverId) {\n\treturn logfile + '-' + serverId + '.log';\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/modules/nodeInfo.js":"/*!\n * Pomelo -- consoleModule nodeInfo processInfo\n * Copyright(c) 2012 fantasyni <fantasyni@163.com>\n * MIT Licensed\n */\nvar monitor = require('pomelo-monitor');\nvar logger = require('pomelo-logger').getLogger('pomelo-admin', __filename);\n\nvar DEFAULT_INTERVAL = 5 * 60;\t\t// in second\nvar DEFAULT_DELAY = 10;\t\t\t\t\t\t// in second\n\nmodule.exports = function(opts) {\n\treturn new Module(opts);\n};\n\nmodule.exports.moduleId = 'nodeInfo';\n\nvar Module = function(opts) {\n\topts = opts || {};\n\tthis.type = opts.type || 'pull';\n\tthis.interval = opts.interval || DEFAULT_INTERVAL;\n\tthis.delay = opts.delay || DEFAULT_DELAY;\n};\n\nModule.prototype.monitorHandler = function(agent, msg, cb) {\n\tvar serverId = agent.id;\n\tvar pid = process.pid;\n\tvar params = {\n\t\tserverId: serverId,\n\t\tpid: pid\n\t};\n\tmonitor.psmonitor.getPsInfo(params, function (err, data) {\n\t\tagent.notify(module.exports.moduleId, {serverId: agent.id, body: data});\n\t});\n\n};\n\nModule.prototype.masterHandler = function(agent, msg, cb) {\n\tif(!msg) {\n\t\tagent.notifyAll(module.exports.moduleId);\n\t\treturn;\n\t}\n\n\tvar body=msg.body;\n\tvar data = agent.get(module.exports.moduleId);\n\tif(!data) {\n\t\tdata = {};\n\t\tagent.set(module.exports.moduleId, data);\n\t}\n\n\tdata[msg.serverId] = body;\n};\n\nModule.prototype.clientHandler = function(agent, msg, cb) {\n\tcb(null, agent.get(module.exports.moduleId) || {});\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-monitor/index.js":"module.exports.psmonitor=require('./lib/processMonitor');\nmodule.exports.sysmonitor=require('./lib/systemMonitor');\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-monitor/lib/processMonitor.js":"/**\r\n *Module dependencies\r\n */\r\n\r\nvar exec = require('child_process').exec\r\n\t, spawn = require('child_process').spawn\r\n\t, util = require('../utils/util');\r\n\r\n/**\r\n * Expose 'getPsInfo' constructor\r\n */\r\n\r\nmodule.exports.getPsInfo = getPsInfo;\r\n\r\n/**\r\n * get the process information by command 'ps auxw | grep serverId | grep pid'\r\n *\r\n * @param {Object} param\r\n * @param {Function} callback\r\n * @api public\r\n */\r\n\r\nfunction getPsInfo(param, callback) { \r\n\tif (process.platform === 'windows') return;\r\n\tvar pid = param.pid;\r\n\tvar cmd = \"ps auxw | grep \" + pid + \" | grep -v 'grep'\";\r\n\t//var cmd = \"ps auxw | grep -E '.+?\\\\s+\" + pid + \"\\\\s+'\"  ;\r\n\texec(cmd, function(err, output) {\r\n\t\tif (!!err) {\r\n\t\t\tif (err.code === 1) {\r\n\t\t\t\tconsole.log('the content is null!');\r\n\t\t\t} else {\r\n\t\t\t\tconsole.error('getPsInfo failed! ' + err.stack);\r\n\t\t\t}\r\n\t\t\tcallback(err, null);\r\n\t\t\treturn;\r\n\t\t} \r\n    format(param, output, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * convert serverInfo to required format, and the callback will handle the serverInfo \r\n *\r\n * @param {Object} param, contains serverId etc\r\n * @param {String} data, the output if the command 'ps'\r\n * @param {Function} cb\r\n * @api private\r\n */\r\n\r\nfunction format(param, data, cb) {\r\n\tvar time = util.formatTime(new Date());\r\n\tvar outArray = data.toString().replace(/^\\s+|\\s+$/g,\"\").split(/\\s+/);\r\n\tvar outValueArray = [];\r\n\tfor (var i = 0; i < outArray.length; i++) {\r\n\t\tif ((!isNaN(outArray[i]))) {\r\n\t\t\toutValueArray.push(outArray[i]);\r\n\t\t}\r\n\t}\r\n\tvar ps = {};\r\n\tps.time = time;\r\n\tps.serverId = param.serverId;\r\n\tps.serverType = ps.serverId.split('-')[0];\r\n\tvar pid = ps.pid = param.pid;\r\n\tps.cpuAvg = outValueArray[1];\r\n\tps.memAvg = outValueArray[2];\r\n\tps.vsz = outValueArray[3];\r\n\tps.rss = outValueArray[4];\r\n\toutValueArray = [];\r\n\tif (process.platform === 'darwin') {\r\n\t\tps.usr = 0;\r\n\t\tps.sys = 0;\r\n\t\tps.gue = 0;\r\n\t\tcb(null, ps);\r\n\t\treturn;\r\n\t}\r\n\texec('pidstat -p ' + pid, function(err, output) {\r\n\t\tif (!!err) {\r\n\t\t\tconsole.error('the command pidstat failed! ', err.stack);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar outArray = output.toString().replace(/^\\s+|\\s+$/g,\"\").split(/\\s+/);\r\n\t\tfor (var i = 0; i < outArray.length; i++) {\r\n\t\t  if ((!isNaN(outArray[i]))) {\r\n\t\t\t\toutValueArray.push(outArray[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tps.usr = outValueArray[1];\r\n\t\tps.sys = outValueArray[2];\r\n\t\tps.gue = outValueArray[3];\r\n\r\n\t\tcb(null, ps);\r\n\t});\r\n};\r\n\r\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-monitor/utils/util.js":"/**\n * convert Date as  yyyy-mm-dd hh:mm:ss\n */\nfunction formatTime(date) {\n\tvar n = date.getFullYear(); \n\tvar y = date.getMonth() + 1;\n\tvar r = date.getDate(); \n\tvar mytime = date.toLocaleTimeString(); \n\tvar mytimes = n+ \"-\" + y + \"-\" + r + \" \" + mytime;\n  return mytimes;\n}\nmodule.exports.formatTime = formatTime;\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-monitor/lib/systemMonitor.js":"/**\r\n * Module dependencies\r\n */\r\n\r\nvar os = require('os')\r\n\t, util = require('../utils/util')\r\n\t, exec = require('child_process').exec;\r\n\r\nvar info = {};\r\n\r\n/*\r\n * Expose 'getSysInfo' constructor\r\n */\r\n\r\nmodule.exports.getSysInfo = getSysInfo;\r\n\r\n/**\r\n * get information of operating-system\r\n *\r\n * @param {Function} callback\r\n * @api public\r\n */\r\n\r\nfunction getSysInfo(callback) {\r\n\tif (process.platform === 'windows') return;\r\n  var reData = getBasicInfo();\r\n  exec('iostat ', function(err, output) {\r\n\t\tif (!!err) {\r\n\t\t\tconsole.error('getSysInfo failed! ' + err.stack);\r\n\t\t\tcallback(err, reData);\r\n\t\t} else {\r\n\t\t\treData.iostat = format(output);\r\n\t\t\tcallback(null, reData);\r\n\t\t}\r\n  });\r\n};\r\n\r\n/**\r\n * analysis the disk i/o data,return a map contains kb_read,kb_wrtn ect.\r\n *\r\n * @param {String} data, the output of the command 'iostat'\r\n * @api private\r\n */\r\n\r\nfunction format(data) {\r\n\tvar time = util.formatTime(new Date());\r\n  var output_array = data.toString().replace(/^\\s+|\\s+$/g,\"\").split(/\\s+/);\r\n  var output_values = [];\r\n  for (var i = 0, counter = 0; i < output_array.length; i++) {\r\n    if(!isNaN(output_array[i])) {\r\n      output_values[counter] = parseFloat(output_array[i]);\r\n      counter++;\r\n    }\r\n  }\r\n  if (output_values.length > 0) {\r\n    output_hash = {\r\n      date: time,\r\n      disk: {\r\n        kb_read: output_values[9],\r\n        kb_wrtn: output_values[10],\r\n        kb_read_per: output_values[7],\r\n        kb_wrtn_per: output_values[8],\r\n        tps: output_values[6]\r\n      },\r\n      cpu: {\r\n        cpu_user: output_values[0],\r\n        cpu_nice: output_values[1],\r\n        cpu_system: output_values[2],\r\n        cpu_iowait: output_values[3],\r\n        cpu_steal: output_values[4],\r\n        cpu_idle: output_values[5]\r\n      }\r\n    }\r\n    return output_hash;\r\n  }\r\n};\r\n\r\n/**\r\n * get basic information of operating-system\r\n * \r\n * @return {Object} result\r\n * @api private\r\n */\r\n\r\nfunction getBasicInfo() {\r\n\tvar result = {};\r\n  for (var key in info) {\r\n    result[key] = info[key]();\r\n  }  \r\n\treturn result;\r\n};\r\n\r\ninfo.hostname = os.hostname;\r\n\r\ninfo.type = os.type;\r\n\r\ninfo.platform = os.platform;\r\n\r\ninfo.arch = os.arch;\r\n\r\ninfo.release = os.release;\r\n\r\ninfo.uptime = os.uptime;\r\n\r\ninfo.loadavg = os.loadavg;\r\n\r\ninfo.totalmem = os.totalmem;\r\n\r\ninfo.freemem = os.freemem;\r\n\r\ninfo.cpus = os.cpus;\r\n\r\ninfo.networkInterfaces = os.networkInterfaces;\r\n\r\ninfo.versions = function(){return process.versions};\r\n\r\ninfo.arch = function(){return process.arch};\r\n\r\ninfo.platform = function(){return process.platform};\r\n\r\ninfo.memoryUsage = process.memoryUsage;\r\n\r\ninfo.uptime = process.uptime;\r\n\r\n\r\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/modules/profiler.js":"var logger = require('pomelo-logger').getLogger('pomelo-admin', __filename);\nvar utils = require('../util/utils');\n\nvar profiler = null;\ntry {\n\tprofiler = require('v8-profiler');\n} catch(e) {\n}\n\nvar fs = require('fs');\nvar ProfileProxy = require('../util/profileProxy');\n\nmodule.exports = function(opts) {\n\tif (!profiler) {\n\t\treturn {};\n\t} else {\n\t\treturn new Module(opts);\n\t}\n};\n\nif (!profiler) {\n\tmodule.exports.moduleError = 1;\n}\n\nmodule.exports.moduleId = 'profiler';\n\nvar Module = function(opts) {\n\tif(opts && opts.isMaster) {\n\t\tthis.proxy = new ProfileProxy();\n\t}\n};\n\nModule.prototype.monitorHandler = function(agent, msg, cb) {\n\tvar type = msg.type, action = msg.action, uid = msg.uid, result = null;\n\tif (type === 'CPU') {\n\t\tif (action === 'start') {\n\t\t\tprofiler.startProfiling();\n\t\t} else {\n\t\t\tresult = profiler.stopProfiling();\n\t\t\tvar res = {};\n\t\t\tres.head = result.getTopDownRoot();\n\t\t\tres.bottomUpHead = result.getBottomUpRoot();\n\t\t\tres.msg = msg;\n\t\t\tagent.notify(module.exports.moduleId, {clientId: msg.clientId, type: type, body: res});\n\t\t}\n\t} else {\n\t\tvar snapshot = profiler.takeSnapshot();\n    var appBase = path.dirname(require.main.filename);\n\t\tvar name = appBase + '/logs/' + utils.format(new Date()) + '.log';\n\t\tvar log = fs.createWriteStream(name, {'flags': 'a'});\n\t\tvar data;\n\t\tsnapshot.serialize({\n\t\t\tonData: function (chunk, size) {\n\t\t\t\tchunk = chunk + '';\n\t\t\t\tdata = {\n\t\t\t\t\tmethod:'Profiler.addHeapSnapshotChunk',\n\t\t\t\t\tparams:{\n\t\t\t\t\t\tuid: uid,\n\t\t\t\t\t\tchunk: chunk\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tlog.write(chunk);\n\t\t\t\tagent.notify(module.exports.moduleId, {clientId: msg.clientId, type: type, body: data});\n\t\t\t},\n\t\t\tonEnd: function () {\n\t\t\t\tagent.notify(module.exports.moduleId, {clientId: msg.clientId, type: type, body: {params: {uid: uid}}});\n\t\t\t\tprofiler.deleteAllSnapshots();\n\t\t\t}\n\t\t});\n\t}\n};\n\nModule.prototype.masterHandler = function(agent, msg, cb) {\n\tif(msg.type === 'CPU') {\n\t\tthis.proxy.stopCallBack(msg.body, msg.clientId, agent);\n\t} else {\n\t\tthis.proxy.takeSnapCallBack(msg.body);\n\t}\n};\n\nModule.prototype.clientHandler = function(agent, msg, cb) {\n\tif(msg.action === 'list') {\n\t\tlist(agent, msg, cb);\n\t\treturn;\n\t}\n\n\tif(typeof msg === 'string') {\n\t\tmsg = JSON.parse(msg);\n\t}\n\tvar id = msg.id;\n\tvar command = msg.method.split('.');\n\tvar method = command[1];\n\tvar params = msg.params;\n\tvar clientId = msg.clientId;\n\n\tif (!this.proxy[method] || typeof this.proxy[method] !== 'function') {\n\t\treturn;\n\t}\n\n\tthis.proxy[method](id, params, clientId, agent);\n};\n\nvar list = function(agent, msg, cb) {\n\tvar servers = [];\n\tvar idMap = agent.idMap;\n\n\tfor(var sid in idMap){\n\t\tservers.push(sid);\n\t}\n\tcb(null, servers);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/util/profileProxy.js":"var fs = require('fs');\n\nvar HeapProfileType = 'HEAP';\nvar CPUProfileType = 'CPU';\n\nvar Proxy = function(){\n\tthis.profiles = {\n\t\tHEAP: {},\n\t\tCPU: {}\n\t};\n\n\tthis.isProfilingCPU = false;\n};\n\nmodule.exports = Proxy;\n\nvar pro = Proxy.prototype;\n\npro.enable = function(id, params, clientId, agent) {\n\tthis.sendResult(id,{\n\t\tresult : true\n\t}, clientId, agent);\n};\n\npro.causesRecompilation = function(id, params, clientId, agent) {\n\tthis.sendResult(id,{\n\t\tresult: false\n\t}, clientId, agent);\n};\n\npro.isSampling = function(id, params, clientId, agent) {\n\tthis.sendResult(id,{\n\t\tresult: true\n\t}, clientId, agent);\n};\n\npro.hasHeapProfiler = function(id, params, clientId, agent) {\n\tthis.sendResult(id,{\n\t\tresult: true\n\t}, clientId, agent);\n};\n\npro.getProfileHeaders = function(id, params, clientId, agent) {\n\tvar headers = [];\n\tfor (var type in this.profiles) {\n\t\tfor (var profileId in this.profiles[type]) {\n\t\t\tvar profile = this.profiles[type][profileId];\n\t\t\theaders.push({\n\t\t\t\ttitle: profile.title,\n\t\t\t\tuid: profile.uid,\n\t\t\t\ttypeId: type\n\t\t\t});\n\t\t}\n\t}\n\tthis.sendResult(id, {\n\t\theaders: headers\n\t}, clientId, agent);\n};\n\npro.takeHeapSnapshot = function(id, params, clientId, agent) {\n\tvar uid = params.uid;\n\n\tagent.notifyById(uid, 'profiler', {type: 'heap', action: 'start', uid: uid, clientId: clientId});\n\n\tthis.sendEvent({\n\t\tmethod: 'Profiler.addProfileHeader', \n\t\tparams: {header: {title: uid, uid: uid, typeId: HeapProfileType}}\n\t}, clientId, agent);\n\tthis.sendResult(id, {}, clientId, agent);\n};\n\npro.takeSnapCallBack = function (data) {\n\tvar uid = data.params.uid || 0;\n\tvar snapShot = this.profiles[HeapProfileType][uid];\n\tif (!snapShot || snapShot.finish) {\n\t\tsnapShot = {};\n\t\tsnapShot.data = [];\n\t\tsnapShot.finish = false;\n\t\tsnapShot.uid = uid;\n\t\tsnapShot.title = uid;\n\t}\n\tif (data.method === 'Profiler.addHeapSnapshotChunk') {\n\t\tvar chunk = data.params.chunk;\n\t\tsnapShot.data.push(chunk);\n\t} else {\n\t\tsnapShot.finish = true;\n\t}\n\tthis.profiles[HeapProfileType][uid] = snapShot;\n};\n\npro.getProfile = function(id, params, clientId, agent) {\n\tvar profile = this.profiles[params.type][params.uid];\n\tvar self = this;\n\tif (!profile || !profile.finish) {\n\t\tvar timerId = setInterval(function() {\n\t\t\tprofile = self.profiles[params.type][params.uid];\n\t\t\tif (!!profile) {\n\t\t\t\tclearInterval(timerId);\n\t\t\t\tself.asyncGet(id, params, profile, clientId, agent);\n\t\t\t}\n\t\t}, 5000);\n\t} else {\n\t\tthis.asyncGet(id,params, profile, clientId, agent);\n\t}\n};\n\npro.asyncGet = function(id, params, snapshot, clientId, agent) {\n\tvar uid = params.uid;\n\tif (params.type === HeapProfileType) {\n\t\tfor (var index in snapshot.data) {\n\t\t\tvar chunk = snapshot.data[index];\n\t\t\tthis.sendEvent({method: 'Profiler.addHeapSnapshotChunk', params: {uid: uid, chunk: chunk}}, clientId, agent);\n\t\t}\n\t\tthis.sendEvent({method: 'Profiler.finishHeapSnapshot', params: {uid: uid}}, clientId, agent);\n\t\tthis.sendResult(id, {profile: {title: snapshot.title, uid: uid, typeId: HeapProfileType}}, clientId, agent);\n\t} else if (params.type === CPUProfileType) {\n\t\tthis.sendResult(id,{\n\t\t\tprofile: {\n\t\t\t\ttitle: snapshot.title,\n\t\t\t\tuid: uid,\n\t\t\t\ttypeId: CPUProfileType,\n\t\t\t\thead: snapshot.data.head,\n\t\t\t\tbottomUpHead: snapshot.data.bottomUpHead\n\t\t\t}\n\t\t}, clientId, agent);\n\t}\n};\n\npro.clearProfiles = function(id, params) {\n\tthis.profiles.HEAP = {};\n\tthis.profiles.CPU = {};\n\t//profiler.deleteAllSnapshots();\n\t//profiler.deleteAllProfiles();\n};\n\npro.sendResult = function(id, res, clientId, agent){\n\tagent.notifyClient(clientId, 'profiler', JSON.stringify({id: id, result: res}));\n};\n\npro.sendEvent = function(res, clientId, agent){\n\tagent.notifyClient(clientId, 'profiler', JSON.stringify(res));\n};\n\npro.start = function(id, params, clientId, agent) {\n\tvar uid = params.uid;\n\n\tagent.notifyById(uid, 'profiler', {type: 'CPU', action: 'start', uid: uid, clientId: clientId});\n\tthis.sendEvent({method: 'Profiler.setRecordingProfile', params: {isProfiling: true}}, clientId, agent);\n\tthis.sendResult(id, {}, clientId, agent);\n};\n\npro.stop = function(id, params, clientId, agent) {\n\tvar uid = params.uid;\n\tagent.notifyById(uid, 'profiler', {type: 'CPU', action: 'stop', uid: uid, clientId: clientId});\n\tthis.sendResult(id, {}, clientId, agent);\n};\n\npro.stopCallBack = function(res, clientId, agent) {\n\tvar uid = res.msg.uid;\n\tvar profiler = this.profiles[CPUProfileType][uid];\n\tif (!profiler || profiler.finish){\n\t\tprofiler = {};\n\t\tprofiler.data = null;\n\t\tprofiler.finish = true;\n\t\tprofiler.typeId = CPUProfileType;\n\t\tprofiler.uid = uid;\n\t\tprofiler.title = uid;\n\t}\n\tprofiler.data = res;\n\tthis.profiles[CPUProfileType][uid] = profiler;\n\tthis.sendEvent({\n\t\tmethod: 'Profiler.addProfileHeader', \n\t\tparams: {header: {title: profiler.title, uid: uid, typeId: CPUProfileType}}\n\t}, clientId, agent);\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/modules/scripts.js":"/*!\n * Pomelo -- consoleModule runScript\n * Copyright(c) 2012 fantasyni <fantasyni@163.com>\n * MIT Licensed\n */\nvar monitor = require('pomelo-monitor');\nvar logger = require('pomelo-logger').getLogger('pomelo-admin', __filename);\nvar monitor = require('pomelo-monitor');\nvar vm = require('vm');\nvar fs = require('fs');\nvar util = require('util');\nvar path = require('path');\n\nmodule.exports = function(opts) {\n    return new Module(opts);\n};\n\nmodule.exports.moduleId = \"scripts\";\n\nvar Module = function(opts) {\n    this.app = opts.app;\n    this.root = opts.path;\n    this.commands = {\n        'list': list,\n        'get': get,\n        'save': save,\n        'run': run\n    };\n};\n\nModule.prototype.monitorHandler = function(agent, msg, cb) {\n    var context = {\n        app: this.app,\n        require: require,\n        os: require('os'),\n        fs: require('fs'),\n        process: process,\n        util: util\n    };\n    try {\n        vm.runInNewContext(msg.script, context);\n\n        var result = context.result;\n        if (!result) {\n            cb(null, \"script result should be assigned to result value to script module context\");\n        } else {\n            cb(null, result);\n        }\n    } catch (e) {\n        cb(null, e.toString());\n    }\n\n    //cb(null, vm.runInContext(msg.script, context));\n};\n\nModule.prototype.clientHandler = function(agent, msg, cb) {\n    var fun = this.commands[msg.command];\n    if (!fun || typeof fun !== 'function') {\n        cb('unknown command:' + msg.command);\n        return;\n    }\n\n    fun(this, agent, msg, cb);\n};\n\n/**\n * List server id and scripts file name\n */\nvar list = function(scriptModule, agent, msg, cb) {\n    var servers = [];\n    var scripts = [];\n    var idMap = agent.idMap;\n\n    for (var sid in idMap) {\n        servers.push(sid);\n    }\n\n    fs.readdir(scriptModule.root, function(err, filenames) {\n        if (err) {\n            filenames = [];\n        }\n        for (var i = 0, l = filenames.length; i < l; i++) {\n            scripts.push(filenames[i]);\n        }\n\n        cb(null, {\n            servers: servers,\n            scripts: scripts\n        });\n    });\n};\n\n/**\n * Get the content of the script file\n */\nvar get = function(scriptModule, agent, msg, cb) {\n    var filename = msg.filename;\n    if (!filename) {\n        cb('empty filename');\n        return;\n    }\n\n    fs.readFile(path.join(scriptModule.root, filename), 'utf-8', function(err, data) {\n        if (err) {\n            logger.error('fail to read script file:' + filename + ', ' + err.stack);\n            cb('fail to read script with name:' + filename);\n        }\n\n        cb(null, data);\n    });\n};\n\n/**\n * Save a script file that posted from admin console\n */\nvar save = function(scriptModule, agent, msg, cb) {\n    var filepath = path.join(scriptModule.root, msg.filename);\n\n    fs.writeFile(filepath, msg.body, function(err) {\n        if (err) {\n            logger.error('fail to write script file:' + msg.filename + ', ' + err.stack);\n            cb('fail to write script file:' + msg.filename);\n            return;\n        }\n\n        cb();\n    });\n};\n\n/**\n * Run the script on the specified server\n */\nvar run = function(scriptModule, agent, msg, cb) {\n    agent.request(msg.serverId, module.exports.moduleId, msg, function(err, res) {\n        if (err) {\n            logger.error('fail to run script for ' + err.stack);\n            return;\n        }\n        cb(null, res);\n    });\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/modules/systemInfo.js":"/*!\n * Pomelo -- consoleModule systemInfo\n * Copyright(c) 2012 fantasyni <fantasyni@163.com>\n * MIT Licensed\n */\nvar monitor = require('pomelo-monitor');\nvar logger = require('pomelo-logger').getLogger('pomelo-admin', __filename);\n\nvar DEFAULT_INTERVAL = 5 * 60;\t\t// in second\nvar DEFAULT_DELAY = 10;\t\t\t\t\t\t// in second\n\nmodule.exports = function(opts) {\n\treturn new Module(opts);\n};\n\nmodule.exports.moduleId = 'systemInfo';\n\nvar Module = function(opts) {\n\topts = opts || {};\n\tthis.type = opts.type || 'pull';\n\tthis.interval = opts.interval || DEFAULT_INTERVAL;\n\tthis.delay = opts.delay || DEFAULT_DELAY;\n};\n\nModule.prototype.monitorHandler = function(agent, msg, cb) {\n\t//collect data\n\tmonitor.sysmonitor.getSysInfo(function (err, data) {\n\t\tagent.notify(module.exports.moduleId, {serverId: agent.id, body: data});\n\t});\n};\n\nModule.prototype.masterHandler = function(agent, msg) {\n\tif(!msg) {\n\t\tagent.notifyAll(module.exports.moduleId);\n\t\treturn;\n\t}\n\n\tvar body = msg.body;\n\n\tvar oneData = {\n\t\tTime:body.iostat.date,hostname:body.hostname,serverId:msg.serverId,cpu_user:body.iostat.cpu.cpu_user,\n\t\tcpu_nice:body.iostat.cpu.cpu_nice,cpu_system:body.iostat.cpu.cpu_system,cpu_iowait:body.iostat.cpu.cpu_iowait,\n\t\tcpu_steal:body.iostat.cpu.cpu_steal,cpu_idle:body.iostat.cpu.cpu_idle,tps:body.iostat.disk.tps,\n\t\tkb_read:body.iostat.disk.kb_read,kb_wrtn:body.iostat.disk.kb_wrtn,kb_read_per:body.iostat.disk.kb_read_per,\n\t\tkb_wrtn_per:body.iostat.disk.kb_wrtn_per,totalmem:body.totalmem,freemem:body.freemem,'free/total':(body.freemem/body.totalmem),\n\t\tm_1:body.loadavg[0],m_5:body.loadavg[1],m_15:body.loadavg[2]\n\t};\n\n\tvar data = agent.get(module.exports.moduleId);\n\tif(!data) {\n\t\tdata = {};\n\t\tagent.set(module.exports.moduleId, data);\n\t}\n\n\tdata[msg.serverId] = oneData;\n};\n\nModule.prototype.clientHandler = function(agent, msg, cb) {\n\tcb(null, agent.get(module.exports.moduleId) || {});\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/modules/watchServer.js":"/*!\n * Pomelo -- consoleModule watchServer\n * Copyright(c) 2013 fantasyni <fantasyni@163.com>\n * MIT Licensed\n */\nvar logger = require('pomelo-logger').getLogger('pomelo-admin', __filename);\nvar countDownLatch = require('../util/countDownLatch');\nvar monitor = require('pomelo-monitor');\nvar utils = require('../util/utils');\nvar util = require('util');\nvar fs = require('fs');\nvar vm = require('vm');\n\nmodule.exports = function(opts) {\n\treturn new Module(opts);\n};\n\nmodule.exports.moduleId = 'watchServer';\n\nvar Module = function(opts) {\n\topts = opts || {};\n\tthis.app = opts.app;\n};\n\nModule.prototype.monitorHandler = function(agent, msg, cb) {\n\tvar comd = msg['comd'];\n\tvar context = msg['context'];\n\tvar param = msg['param'];\n\tvar app = this.app;\n\n\tvar handle = 'monitor';\n\n\tswitch (comd) {\n\t\tcase 'servers':\n\t\t\tshowServers(handle, agent, comd, context, cb);\n\t\t\tbreak;\n\t\tcase 'connections':\n\t\t\tshowConnections(handle, agent, app, comd, context, cb);\n\t\t\tbreak;\n\t\tcase 'logins':\n\t\t\tshowLogins(handle, agent, app, comd, context, cb);\n\t\t\tbreak;\n\t\tcase 'modules':\n\t\t\tshowModules(handle, agent, comd, context, cb);\n\t\t\tbreak;\n\t\tcase 'status':\n\t\t\tshowStatus(handle, agent, comd, context, cb);\n\t\t\tbreak;\n\t\tcase 'config':\n\t\t\tshowConfig(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'proxy':\n\t\t\tshowProxy(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'handler':\n\t\t\tshowHandler(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'components':\n\t\t\tshowComponents(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'settings':\n\t\t\tshowSettings(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'cpu':\n\t\t\tdumpCPU(handle, agent, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'memory':\n\t\t\tdumpMemory(handle, agent, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'get':\n\t\t\tgetApp(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'set':\n\t\t\tsetApp(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'enable':\n\t\t\tenableApp(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'disable':\n\t\t\tdisableApp(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'run':\n\t\t\trunScript(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tshowError(handle, agent, comd, context, cb);\n\t}\n};\n\nModule.prototype.clientHandler = function(agent, msg, cb) {\n\tvar comd = msg['comd'];\n\tvar context = msg['context'];\n\tvar param = msg['param'];\n\tvar app = this.app; // master app\n\n\tif (!comd || !context) {\n\t\tcb('lack of comd or context param');\n\t\treturn;\n\t}\n\n\tvar handle = 'client';\n\tswitch (comd) {\n\t\tcase 'servers':\n\t\t\tshowServers(handle, agent, comd, context, cb);\n\t\t\tbreak;\n\t\tcase 'connections':\n\t\t\tshowConnections(handle, agent, app, comd, context, cb);\n\t\t\tbreak;\n\t\tcase 'logins':\n\t\t\tshowLogins(handle, agent, app, comd, context, cb);\n\t\t\tbreak;\n\t\tcase 'modules':\n\t\t\tshowModules(handle, agent, comd, context, cb);\n\t\t\tbreak;\n\t\tcase 'status':\n\t\t\tshowStatus(handle, agent, comd, context, cb);\n\t\t\tbreak;\n\t\tcase 'config':\n\t\t\tshowConfig(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'proxy':\n\t\t\tshowProxy(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'handler':\n\t\t\tshowHandler(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'components':\n\t\t\tshowComponents(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'settings':\n\t\t\tshowSettings(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'cpu':\n\t\t\tdumpCPU(handle, agent, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'memory':\n\t\t\tdumpMemory(handle, agent, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'get':\n\t\t\tgetApp(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'set':\n\t\t\tsetApp(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'enable':\n\t\t\tenableApp(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'disable':\n\t\t\tdisableApp(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tcase 'run':\n\t\t\trunScript(handle, agent, app, comd, context, param, cb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tshowError(handle, agent, comd, context, cb);\n\t}\n};\n\nfunction showServers(handle, agent, comd, context, cb) {\n\tif (handle === 'client') {\n\t\tvar sid, record;\n\t\tvar serverInfo = {};\n\t\tvar count = utils.size(agent.idMap);\n\t\tvar latch = countDownLatch.createCountDownLatch(count, function() {\n\t\t\tcb(null, {\n\t\t\t\tmsg: serverInfo\n\t\t\t});\n\t\t});\n\n\t\tfor (sid in agent.idMap) {\n\t\t\trecord = agent.idMap[sid];\n\t\t\tagent.request(record.id, module.exports.moduleId, {\n\t\t\t\tcomd: comd,\n\t\t\t\tcontext: context\n\t\t\t}, function(msg) {\n\t\t\t\tserverInfo[msg.serverId] = msg.body;\n\t\t\t\tlatch.done();\n\t\t\t});\n\t\t}\n\t} else if (handle === 'monitor') {\n\t\tvar serverId = agent.id;\n\t\tvar serverType = agent.type;\n\t\tvar info = agent.info;\n\t\tvar pid = process.pid;\n\t\tvar heapUsed = (process.memoryUsage().heapUsed / (1000 * 1000)).toFixed(2);\n\t\tvar uptime = (process.uptime() / 60).toFixed(2);\n\t\tcb({\n\t\t\tserverId: serverId,\n\t\t\tbody: {\n\t\t\t\tserverId: serverId,\n\t\t\t\tserverType: serverType,\n\t\t\t\thost: info['host'],\n\t\t\t\tport: info['port'],\n\t\t\t\tpid: pid,\n\t\t\t\theapUsed: heapUsed,\n\t\t\t\tuptime: uptime\n\t\t\t}\n\t\t});\n\t}\n\n}\n\nfunction showConnections(handle, agent, app, comd, context, cb) {\n\tif (handle === 'client') {\n\t\tif (context === 'all') {\n\t\t\tvar sid, record;\n\t\t\tvar serverInfo = {};\n\t\t\tvar count = 0;\n\t\t\tfor (var key in agent.idMap) {\n\t\t\t\tif (agent.idMap[key].info.frontend === 'true') {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar latch = countDownLatch.createCountDownLatch(count, function() {\n\t\t\t\tcb(null, {\n\t\t\t\t\tmsg: serverInfo\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tfor (sid in agent.idMap) {\n\t\t\t\trecord = agent.idMap[sid];\n\t\t\t\tif (record.info.frontend === 'true') {\n\t\t\t\t\tagent.request(record.id, module.exports.moduleId, {\n\t\t\t\t\t\tcomd: comd,\n\t\t\t\t\t\tcontext: context\n\t\t\t\t\t}, function(msg) {\n\t\t\t\t\t\tserverInfo[msg.serverId] = msg.body;\n\t\t\t\t\t\tlatch.done();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar record = agent.idMap[context];\n\t\t\tif (!record) {\n\t\t\t\tcb(\"the server \" + context + \" not exist\");\n\t\t\t}\n\t\t\tif (record.info.frontend === 'true') {\n\t\t\t\tagent.request(record.id, module.exports.moduleId, {\n\t\t\t\t\tcomd: comd,\n\t\t\t\t\tcontext: context\n\t\t\t\t}, function(msg) {\n\t\t\t\t\tvar serverInfo = {};\n\t\t\t\t\tserverInfo[msg.serverId] = msg.body;\n\t\t\t\t\tcb(null, {\n\t\t\t\t\t\tmsg: serverInfo\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcb('\\nthis command should be applied to frontend server\\n');\n\t\t\t}\n\t\t}\n\t} else if (handle === 'monitor') {\n\t\tvar connection = app.components.__connection__;\n\t\tif (!connection) {\n\t\t\tcb({\n\t\t\t\tserverId: agent.id,\n\t\t\t\tbody: 'error'\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tcb({\n\t\t\tserverId: agent.id,\n\t\t\tbody: connection.getStatisticsInfo()\n\t\t});\n\t}\n}\n\n\nfunction showLogins(handle, agent, app, comd, context, cb) {\n\tshowConnections(handle, agent, app, comd, context, cb);\n}\n\nfunction showModules(handle, agent, comd, context, cb) {\n\tvar modules = agent.consoleService.modules;\n\tvar result = [];\n\tfor (var module in modules) {\n\t\tresult.push(module);\n\t}\n\tcb(null, {\n\t\tmsg: result\n\t});\n}\n\nfunction showStatus(handle, agent, comd, context, cb) {\n\tif (handle === 'client') {\n\t\tagent.request(context, module.exports.moduleId, {\n\t\t\tcomd: comd,\n\t\t\tcontext: context\n\t\t}, function(err, msg) {\n\t\t\tcb(null, {\n\t\t\t\tmsg: msg\n\t\t\t});\n\t\t});\n\t} else if (handle === 'monitor') {\n\t\tvar serverId = agent.id;\n\t\tvar pid = process.pid;\n\t\tvar params = {\n\t\t\tserverId: serverId,\n\t\t\tpid: pid\n\t\t};\n\t\tmonitor.psmonitor.getPsInfo(params, function(err, data) {\n\t\t\tcb(null, {\n\t\t\t\tserverId: agent.id,\n\t\t\t\tbody: data\n\t\t\t})\n\t\t});\n\t}\n}\n\nfunction showConfig(handle, agent, app, comd, context, param, cb) {\n\tif (handle === 'client') {\n\t\tif (param === 'master') {\n\t\t\tcb(null, {\n\t\t\t\tmasterConfig: app.get('masterConfig') || 'no config to master in app.js',\n\t\t\t\tmasterInfo: app.get('master')\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tagent.request(context, module.exports.moduleId, {\n\t\t\tcomd: comd,\n\t\t\tparam: param,\n\t\t\tcontext: context\n\t\t}, function(err, msg) {\n\t\t\tcb(null, msg);\n\t\t});\n\t} else if (handle === 'monitor') {\n\t\tvar key = param + 'Config';\n\t\tcb(null, clone(param, app.get(key)));\n\t}\n}\n\nfunction showProxy(handle, agent, app, comd, context, param, cb) {\n\tif (handle === 'client') {\n\t\tif (context === 'all') {\n\t\t\tcb('context error');\n\t\t\treturn;\n\t\t}\n\n\t\tagent.request(context, module.exports.moduleId, {\n\t\t\tcomd: comd,\n\t\t\tparam: param,\n\t\t\tcontext: context\n\t\t}, function(err, msg) {\n\t\t\tcb(null, msg);\n\t\t});\n\t} else if (handle === 'monitor') {\n\t\tproxyCb(app, context, cb);\n\t}\n}\n\nfunction showHandler(handle, agent, app, comd, context, param, cb) {\n\tif (handle === 'client') {\n\t\tif (context === 'all') {\n\t\t\tcb('context error');\n\t\t\treturn;\n\t\t}\n\n\t\tagent.request(context, module.exports.moduleId, {\n\t\t\tcomd: comd,\n\t\t\tparam: param,\n\t\t\tcontext: context\n\t\t}, function(err, msg) {\n\t\t\tcb(null, msg);\n\t\t});\n\t} else if (handle === 'monitor') {\n\t\thandlerCb(app, context, cb);\n\t}\n}\n\nfunction showComponents(handle, agent, app, comd, context, param, cb) {\n\tif (handle === 'client') {\n\t\tif (context === 'all') {\n\t\t\tcb('context error');\n\t\t\treturn;\n\t\t}\n\n\t\tagent.request(context, module.exports.moduleId, {\n\t\t\tcomd: comd,\n\t\t\tparam: param,\n\t\t\tcontext: context\n\t\t}, function(err, msg) {\n\t\t\tcb(null, msg);\n\t\t});\n\t} else if (handle === 'monitor') {\n\t\tvar _components = app.components;\n\t\tvar res = {};\n\t\tfor (var key in _components) {\n\t\t\tvar name = getComponentName(key);\n\t\t\tres[name] = clone(name, app.get(name + 'Config'))\n\t\t}\n\t\tcb(null, res);\n\t}\n}\n\nfunction showSettings(handle, agent, app, comd, context, param, cb) {\n\tif (handle === 'client') {\n\t\tif (context === 'all') {\n\t\t\tcb('context error');\n\t\t\treturn;\n\t\t}\n\n\t\tagent.request(context, module.exports.moduleId, {\n\t\t\tcomd: comd,\n\t\t\tparam: param,\n\t\t\tcontext: context\n\t\t}, function(err, msg) {\n\t\t\tcb(null, msg);\n\t\t});\n\t} else if (handle === 'monitor') {\n\t\tvar _settings = app.settings;\n\t\tvar res = {};\n\t\tfor (var key in _settings) {\n\t\t\tif (key.match(/^__\\w+__$/) || key.match(/\\w+Config$/)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!checkJSON(_settings[key])) {\n\t\t\t\tres[key] = 'Object';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres[key] = _settings[key];\n\t\t}\n\t\tcb(null, res);\n\t}\n}\n\nfunction dumpCPU(handle, agent, comd, context, param, cb) {\n\tif (handle === 'client') {\n\t\tif (context === 'all') {\n\t\t\tcb('context error');\n\t\t\treturn;\n\t\t}\n\n\t\tagent.request(context, module.exports.moduleId, {\n\t\t\tcomd: comd,\n\t\t\tparam: param,\n\t\t\tcontext: context\n\t\t}, function(err, msg) {\n\t\t\tcb(err, msg);\n\t\t});\n\t} else if (handle === 'monitor') {\n\t\tvar times = param['times'];\n\t\tvar filepath = param['filepath'];\n\t\tvar force = param['force'];\n\t\tcb(null, 'cpu dump is unused in 1.0 of pomelo');\n\t\t/**\n\t\tif (!/\\.cpuprofile$/.test(filepath)) {\n\t\t\tfilepath = filepath + '.cpuprofile';\n\t\t}\n\t\tif (!times || !/^[0-9]*[1-9][0-9]*$/.test(times)) {\n\t\t\tcb('no times or times invalid error');\n\t\t\treturn;\n\t\t}\n\t\tcheckFilePath(filepath, force, function(err) {\n\t\t\tif (err) {\n\t\t\t\tcb(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//ndump.cpu(filepath, times);\n\t\t\tcb(null, filepath + ' cpu dump ok');\n\t\t});\n\t\t*/\n\n\t}\n}\n\nfunction dumpMemory(handle, agent, comd, context, param, cb) {\n\tif (handle === 'client') {\n\t\tif (context === 'all') {\n\t\t\tcb('context error');\n\t\t\treturn;\n\t\t}\n\n\t\tagent.request(context, module.exports.moduleId, {\n\t\t\tcomd: comd,\n\t\t\tparam: param,\n\t\t\tcontext: context\n\t\t}, function(err, msg) {\n\t\t\tcb(err, msg);\n\t\t});\n\t} else if (handle === 'monitor') {\n\t\tvar filepath = param['filepath'];\n\t\tvar force = param['force'];\n\t\tif (!/\\.heapsnapshot$/.test(filepath)) {\n\t\t\tfilepath = filepath + '.heapsnapshot';\n\t\t}\n\t\tcheckFilePath(filepath, force, function(err) {\n\t\t\tif (err) {\n\t\t\t\tcb(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar heapdump = null;\n\t\t\ttry {\n\t\t\t\theapdump = require('heapdump');\n\t\t\t\theapdump.writeSnapshot(filepath);\n\t\t\t\tcb(null, filepath + ' memory dump ok')\n\t\t\t} catch (e) {\n\t\t\t\tcb('pomelo-admin require heapdump');\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction getApp(handle, agent, app, comd, context, param, cb) {\n\tif (handle === 'client') {\n\t\tif (context === 'all') {\n\t\t\tcb('context error');\n\t\t\treturn;\n\t\t}\n\n\t\tagent.request(context, module.exports.moduleId, {\n\t\t\tcomd: comd,\n\t\t\tparam: param,\n\t\t\tcontext: context\n\t\t}, function(err, msg) {\n\t\t\tcb(null, msg);\n\t\t});\n\t} else if (handle === 'monitor') {\n\t\tvar res = app.get(param);\n\t\tif (!checkJSON(res)) {\n\t\t\tres = 'object';\n\t\t}\n\t\tcb(null, res || null);\n\t}\n}\n\nfunction setApp(handle, agent, app, comd, context, param, cb) {\n\tif (handle === 'client') {\n\t\tif (context === 'all') {\n\t\t\tcb('context error');\n\t\t\treturn;\n\t\t}\n\n\t\tagent.request(context, module.exports.moduleId, {\n\t\t\tcomd: comd,\n\t\t\tparam: param,\n\t\t\tcontext: context\n\t\t}, function(err, msg) {\n\t\t\tcb(null, msg);\n\t\t});\n\t} else if (handle === 'monitor') {\n\t\tvar key = param['key'];\n\t\tvar value = param['value'];\n\t\tapp.set(key, value);\n\t\tcb(null, 'set ' + key + ':' + value + ' ok');\n\t}\n}\n\nfunction enableApp(handle, agent, app, comd, context, param, cb) {\n\tif (handle === 'client') {\n\t\tif (context === 'all') {\n\t\t\tcb('context error');\n\t\t\treturn;\n\t\t}\n\n\t\tagent.request(context, module.exports.moduleId, {\n\t\t\tcomd: comd,\n\t\t\tparam: param,\n\t\t\tcontext: context\n\t\t}, function(err, msg) {\n\t\t\tcb(null, msg);\n\t\t});\n\t} else if (handle === 'monitor') {\n\t\tapp.enable(param);\n\t\tcb(null, 'enable ' + param + ' ok');\n\t}\n}\n\nfunction disableApp(handle, agent, app, comd, context, param, cb) {\n\tif (handle === 'client') {\n\t\tif (context === 'all') {\n\t\t\tcb('context error');\n\t\t\treturn;\n\t\t}\n\n\t\tagent.request(context, module.exports.moduleId, {\n\t\t\tcomd: comd,\n\t\t\tparam: param,\n\t\t\tcontext: context\n\t\t}, function(err, msg) {\n\t\t\tcb(null, msg);\n\t\t});\n\t} else if (handle === 'monitor') {\n\t\tapp.disable(param);\n\t\tcb(null, 'disable ' + param + ' ok');\n\t}\n}\n\nfunction runScript(handle, agent, app, comd, context, param, cb) {\n\tif (handle === 'client') {\n\t\tif (context === 'all') {\n\t\t\tcb('context error');\n\t\t\treturn;\n\t\t}\n\n\t\tagent.request(context, module.exports.moduleId, {\n\t\t\tcomd: comd,\n\t\t\tparam: param,\n\t\t\tcontext: context\n\t\t}, function(err, msg) {\n\t\t\tcb(null, msg);\n\t\t});\n\t} else if (handle === 'monitor') {\n\t\tvar ctx = {\n\t\t\tapp: app,\n\t\t\tresult: null\n\t\t};\n\t\ttry {\n\t\t\tvm.runInNewContext('result = ' + param, ctx, 'myApp.vm');\n\t\t\tcb(null, util.inspect(ctx.result));\n\t\t} catch (e) {\n\t\t\tcb(null, e.stack);\n\t\t}\n\t}\n}\n\nfunction showError(handle, agent, comd, context, cb) {\n\n}\n\nfunction clone(param, obj) {\n\tvar result = {};\n\tvar flag = 1;\n\tfor (var key in obj) {\n\t\tif (typeof obj[key] === 'function' || typeof obj[key] === 'object') {\n\t\t\tcontinue;\n\t\t}\n\t\tflag = 0;\n\t\tresult[key] = obj[key];\n\t}\n\tif (flag) {\n\t\t// return 'no ' + param + 'Config info';\n\t}\n\treturn result;\n}\n\nfunction checkFilePath(filepath, force, cb) {\n\tif (!force && fs.existsSync(filepath)) {\n\t\tcb('filepath file exist');\n\t\treturn;\n\t}\n\tfs.writeFile(filepath, 'test', function(err) {\n\t\tif (err) {\n\t\t\tcb('filepath invalid error');\n\t\t\treturn;\n\t\t}\n\t\tfs.unlinkSync(filepath);\n\t\tcb(null);\n\t})\n}\n\nfunction proxyCb(app, context, cb) {\n\tvar msg = {};\n\tvar __proxy__ = app.components.__proxy__;\n\tif (__proxy__ && __proxy__.client && __proxy__.client.proxies.user) {\n\t\tvar proxies = __proxy__.client.proxies.user;\n\t\tvar server = app.getServerById(context);\n\t\tif (!server) {\n\t\t\tcb('no server with this id ' + context);\n\t\t} else {\n\t\t\tvar type = server['serverType'];\n\t\t\tvar tmp = proxies[type];\n\t\t\tmsg[type] = {};\n\t\t\tfor (var _proxy in tmp) {\n\t\t\t\tvar r = tmp[_proxy];\n\t\t\t\tmsg[type][_proxy] = {};\n\t\t\t\tfor (var _rpc in r) {\n\t\t\t\t\tif (typeof r[_rpc] === 'function') {\n\t\t\t\t\t\tmsg[type][_proxy][_rpc] = 'function';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcb(null, msg);\n\t\t}\n\t} else {\n\t\tcb('no proxy loaded');\n\t}\n}\n\nfunction handlerCb(app, context, cb) {\n\tvar msg = {};\n\tvar __server__ = app.components.__server__;\n\tif (__server__ && __server__.server && __server__.server.handlerService.handlers) {\n\t\tvar handles = __server__.server.handlerService.handlers;\n\t\tvar server = app.getServerById(context);\n\t\tif (!server) {\n\t\t\tcb('no server with this id ' + context);\n\t\t} else {\n\t\t\tvar type = server['serverType'];\n\t\t\tvar tmp = handles;\n\t\t\tmsg[type] = {};\n\t\t\tfor (var _p in tmp) {\n\t\t\t\tvar r = tmp[_p];\n\t\t\t\tmsg[type][_p] = {};\n\t\t\t\tfor (var _r in r) {\n\t\t\t\t\tif (typeof r[_r] === 'function') {\n\t\t\t\t\t\tmsg[type][_p][_r] = 'function';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcb(null, msg);\n\t\t}\n\t} else {\n\t\tcb('no handler loaded');\n\t}\n}\n\nfunction getComponentName(c) {\n\tvar t = c.match(/^__(\\w+)__$/);\n\tif (t) {\n\t\tt = t[1];\n\t}\n\treturn t;\n}\n\nfunction checkJSON(obj) {\n\tif (!obj) {\n\t\treturn true;\n\t}\n\ttry {\n\t\tJSON.stringify(obj);\n\t} catch (e) {\n\t\treturn false;\n\t}\n\treturn true;\n}","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-admin/lib/util/countDownLatch.js":"var exp = module.exports;\n\n/**\n * Count down to zero and invoke cb finally.\n */\nvar CountDownLatch = function(count, cb) {\n  this.count = count;\n  this.cb = cb;\n};\n\n/**\n * Call when a task finish to count down.\n *\n * @api public\n */\nCountDownLatch.prototype.done = function() {\n  if(this.count <= 0) {\n    throw new Error('illegal state.');\n  }\n\n  this.count--;\n  if (this.count === 0) {\n    this.cb();\n  }\n};\n\n/**\n * create a count down latch\n *\n * @api public\n */\nexp.createCountDownLatch = function(count, cb) {\n  if(!count || count <= 0) {\n    throw new Error('count should be positive.');\n  }\n  if(typeof cb !== 'function') {\n    throw new Error('cb should be a function.');\n  }\n\n  return new CountDownLatch(count, cb);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/util/moduleUtil.js":"var os = require('os');\nvar admin = require('pomelo-admin');\nvar utils = require('./utils');\nvar Constants = require('./constants');\nvar pathUtil = require('./pathUtil');\nvar starter = require('../master/starter');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar pro = module.exports;\n\n/**\n * Load admin modules\n */\npro.loadModules = function(self, consoleService) {\n  // load app register modules\n  var _modules = self.app.get(Constants.KEYWORDS.MODULE);\n\n  if(!_modules) {\n    return;\n  }\n\n  var modules = [];\n  for(var m in _modules){\n    modules.push(_modules[m]);\n  }\n  \n  var record, moduleId, module;\n  for(var i=0, l=modules.length; i<l; i++) {\n    record = modules[i];\n    if(typeof record.module === 'function') {\n      module = record.module(record.opts, consoleService);\n    } else {\n      module = record.module;\n    }\n\n    moduleId = record.moduleId || module.moduleId;\n\n    if(!moduleId) {\n      logger.warn('ignore an unknown module.');\n      continue;\n    }\n\n    consoleService.register(moduleId, module);\n    self.modules.push(module);\n  }\n};\n\npro.startModules = function(modules, cb) {\n  // invoke the start lifecycle method of modules\n\n  if(!modules) {\n    return;\n  }\n  startModule(null, modules, 0, cb);\n};\n\n/**\n * Append the default system admin modules\n */\npro.registerDefaultModules = function(isMaster, app, closeWatcher) {\n  if(!closeWatcher) {\n    if(isMaster) {\n      app.registerAdmin(require('../modules/masterwatcher'), {app: app});\n    } else {\n      app.registerAdmin(require('../modules/monitorwatcher'), {app: app});\n    }\n  }\n  app.registerAdmin(admin.modules.watchServer,{app:app});\n  app.registerAdmin(require('../modules/console'), {app: app, starter: starter});\n  if(app.enabled('systemMonitor')) {\n    if(os.platform() !== Constants.PLATFORM.WIN) {\n      app.registerAdmin(admin.modules.systemInfo);\n      app.registerAdmin(admin.modules.nodeInfo);\n    }\n    app.registerAdmin(admin.modules.monitorLog, {path: pathUtil.getLogPath(app.getBase())});\n    app.registerAdmin(admin.modules.scripts, {app:app, path: pathUtil.getScriptPath(app.getBase())});\n    if(os.platform() !== Constants.PLATFORM.WIN) {\n      app.registerAdmin(admin.modules.profiler);\n    }\n  }\n};\n\nvar startModule = function(err, modules, index, cb) {\n  if(err || index >= modules.length) {\n    utils.invokeCallback(cb, err);\n    return;\n  }\n\n  var module = modules[index];\n  if(module && typeof module.start === 'function') {\n    module.start(function(err) {\n      startModule(err, modules, index + 1, cb);\n    });\n  } else {\n    startModule(err, modules, index + 1, cb);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/components/monitor.js":"/**\n * Component for monitor.\n * Load and start monitor client.\n */\nvar Monitor = require('../monitor/monitor');\n\n\n\n/**\n * Component factory function\n *\n * @param  {Object} app  current application context\n * @return {Object}      component instances\n */\nmodule.exports = function(app, opts) {\n  return new Component(app, opts);\n};\n\nvar Component = function(app, opts) {\n  this.monitor = new Monitor(app, opts);\n};\n\nvar pro = Component.prototype;\n\npro.name = '__monitor__';\n\npro.start = function(cb) {\n  this.monitor.start(cb);\n};\n\npro.stop = function(force, cb) {\n  this.monitor.stop(cb);\n};\n\npro.reconnect = function(masterInfo) {\n  this.monitor.reconnect(masterInfo);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/monitor/monitor.js":"/**\n * Component for monitor.\n * Load and start monitor client.\n */\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar admin = require('pomelo-admin');\nvar moduleUtil = require('../util/moduleUtil');\nvar utils = require('../util/utils');\nvar Constants = require('../util/constants');\n\nvar Monitor = function(app, opts) {\n  opts = opts || {};\n  this.app = app;\n  this.serverInfo = app.getCurServer();\n  this.masterInfo = app.getMaster();\n  this.modules = [];\n  this.closeWatcher = opts.closeWatcher;\n\n  this.monitorConsole = admin.createMonitorConsole({\n    id: this.serverInfo.id,\n    type: this.app.getServerType(),\n    host: this.masterInfo.host,\n    port: this.masterInfo.port,\n    info: this.serverInfo,\n    env: this.app.get(Constants.RESERVED.ENV),\n    authServer: app.get('adminAuthServerMonitor') // auth server function\n  });\n};\n\nmodule.exports = Monitor;\n\nMonitor.prototype.start = function(cb) {\n  moduleUtil.registerDefaultModules(false, this.app, this.closeWatcher);\n  this.startConsole(cb);\n};\n\nMonitor.prototype.startConsole = function(cb) {\n  moduleUtil.loadModules(this, this.monitorConsole);\n\n  var self = this;\n  this.monitorConsole.start(function(err) {\n    if (err) {\n      utils.invokeCallback(cb, err);\n      return;\n    }\n    moduleUtil.startModules(self.modules, function(err) {\n      utils.invokeCallback(cb, err);\n      return;\n    });\n  });\n\n  this.monitorConsole.on('error', function(err) {\n    if(!!err) {\n      logger.error('monitorConsole encounters with error: %j', err.stack);\n      return;\n    }\n  });\n};\n\nMonitor.prototype.stop = function(cb) {\n  this.monitorConsole.stop();\n  this.modules = [];\n  process.nextTick(function() {\n    utils.invokeCallback(cb);\n  });\n};\n\n// monitor reconnect to master\nMonitor.prototype.reconnect = function(masterInfo) {\n  var self = this;\n  this.stop(function() {\n    self.monitorConsole = admin.createMonitorConsole({\n      id: self.serverInfo.id,\n      type: self.app.getServerType(),\n      host: masterInfo.host,\n      port: masterInfo.port,\n      info: self.serverInfo,\n      env: self.app.get(Constants.RESERVED.ENV)\n    });\n    self.startConsole(function() {\n      logger.info('restart modules for server : %j finish.', self.app.serverId);\n    });\n  });\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/components/protobuf.js":"var fs = require('fs');\nvar path = require('path');\nvar protobuf = require('pomelo-protobuf');\nvar Constants = require('../util/constants');\nvar crypto = require('crypto');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\n\nmodule.exports = function(app, opts) {\n  return new Component(app, opts);\n};\n\nvar Component = function(app, opts) {\n  this.app = app;\n  opts = opts || {};\n  this.watchers = {};\n  this.serverProtos = {};\n  this.clientProtos = {};\n  this.version = \"\";\n  \n  var env = app.get(Constants.RESERVED.ENV);\n  var originServerPath = path.join(app.getBase(), Constants.FILEPATH.SERVER_PROTOS);\n  var presentServerPath = path.join(Constants.FILEPATH.CONFIG_DIR, env, path.basename(Constants.FILEPATH.SERVER_PROTOS));\n  var originClientPath = path.join(app.getBase(), Constants.FILEPATH.CLIENT_PROTOS);\n  var presentClientPath = path.join(Constants.FILEPATH.CONFIG_DIR, env, path.basename(Constants.FILEPATH.CLIENT_PROTOS));\n\n  this.serverProtosPath = opts.serverProtos || (fs.existsSync(originServerPath) ? Constants.FILEPATH.SERVER_PROTOS : presentServerPath);\n  this.clientProtosPath = opts.clientProtos || (fs.existsSync(originClientPath) ? Constants.FILEPATH.CLIENT_PROTOS : presentClientPath);\n\n  this.setProtos(Constants.RESERVED.SERVER, path.join(app.getBase(), this.serverProtosPath));\n  this.setProtos(Constants.RESERVED.CLIENT, path.join(app.getBase(), this.clientProtosPath));\n\n  protobuf.init({encoderProtos:this.serverProtos, decoderProtos:this.clientProtos});\n};\n\nvar pro = Component.prototype;\n\npro.name = '__protobuf__';\n\npro.encode = function(key, msg) {\n  return protobuf.encode(key, msg);\n};\n\npro.encode2Bytes = function(key, msg) {\n  return protobuf.encode2Bytes(key, msg);\n};\n\npro.decode = function(key, msg) {\n  return protobuf.decode(key, msg);\n};\n\npro.getProtos = function() {\n  return {\n    server : this.serverProtos,\n    client : this.clientProtos,\n    version : this.version\n  };\n};\n\npro.getVersion = function() {\n  return this.version;\n};\n\npro.setProtos = function(type, path) {\n  if(!fs.existsSync(path)) {\n    return;\n  }\n\n  if(type === Constants.RESERVED.SERVER) {\n    this.serverProtos = protobuf.parse(require(path));\n  }\n\n  if(type === Constants.RESERVED.CLIENT) {\n    this.clientProtos = protobuf.parse(require(path));\n  }\n\n  var protoStr = JSON.stringify(this.clientProtos) + JSON.stringify(this.serverProtos);\n  this.version = crypto.createHash('md5').update(protoStr).digest('base64');\n\n  //Watch file\n  var watcher = fs.watch(path, this.onUpdate.bind(this, type, path));\n  if (this.watchers[type]) {\n    this.watchers[type].close();\n  }\n  this.watchers[type] = watcher;\n};\n\npro.onUpdate = function(type, path, event) {\n  if(event !== 'change') {\n    return;\n  }\n\n  var self = this;\n  fs.readFile(path, 'utf8' ,function(err, data) {\n    try {\n      var protos = protobuf.parse(JSON.parse(data));\n      if(type === Constants.RESERVED.SERVER) {\n        protobuf.setEncoderProtos(protos);\n        self.serverProtos = protos;\n      } else {\n        protobuf.setDecoderProtos(protos);\n        self.clientProtos = protos;\n      }\n\n      var protoStr = JSON.stringify(self.clientProtos) + JSON.stringify(self.serverProtos);\n      self.version = crypto.createHash('md5').update(protoStr).digest('base64');\n      logger.info('change proto file , type : %j, path : %j, version : %j', type, path, self.version);\n    } catch(e) {\n      logger.warn(\"change proto file error! path : %j\", path);\n      logger.warn(e);\n    }\n  });\n};\n\npro.stop = function(force, cb) {\n  for (var type in this.watchers) {\n    this.watchers[type].close();\n  }\n  this.watchers = {};\n  process.nextTick(cb);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-protobuf/lib/protobuf.js":"var encoder = require('./encoder');\nvar decoder = require('./decoder');\nvar parser = require('./parser');\n\nvar Protobuf = module.exports;\n\n/**\n * [encode the given message, return a Buffer represent the message encoded by protobuf]\n * @param  {[type]} key The key to identify the message type.\n * @param  {[type]} msg The message body, a js object.\n * @return {[type]} The binary encode result in a Buffer.\n */\nProtobuf.encode = function(key, msg){\n\treturn encoder.encode(key, msg);\n};\n\nProtobuf.encode2Bytes = function(key, msg){\n\tvar buffer = this.encode(key, msg);\n\tif(!buffer || !buffer.length){\n\t\tconsole.warn('encode msg failed! key : %j, msg : %j', key, msg);\n\t\treturn null;\n\t}\n\tvar bytes = new Uint8Array(buffer.length);\n\tfor(var offset = 0; offset < buffer.length; offset++){\n\t\tbytes[offset] = buffer.readUInt8(offset);\n\t}\n\n\treturn bytes;\n};\n\nProtobuf.encodeStr = function(key, msg, code){\n\tcode = code || 'base64';\n\tvar buffer = Protobuf.encode(key, msg);\n\treturn !!buffer?buffer.toString(code):buffer;\n};\n\nProtobuf.decode = function(key, msg){\n\treturn decoder.decode(key, msg);\n};\n\nProtobuf.decodeStr = function(key, str, code){\n\tcode = code || 'base64';\n\tvar buffer = new Buffer(str, code);\n\n\treturn !!buffer?Protobuf.decode(key, buffer):buffer;\n};\n\nProtobuf.parse = function(json){\n\treturn parser.parse(json);\n};\n\nProtobuf.setEncoderProtos = function(protos){\n\tencoder.init(protos);\n};\n\nProtobuf.setDecoderProtos = function(protos){\n\tdecoder.init(protos);\n};\n\nProtobuf.init = function(opts){\n\t//On the serverside, use serverProtos to encode messages send to client\n\tencoder.init(opts.encoderProtos);\n\n\t//On the serverside, user clientProtos to decode messages receive from clients\n\tdecoder.init(opts.decoderProtos);\n\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-protobuf/lib/encoder.js":"var codec = require('./codec');\nvar constant = require('./constant');\nvar util = require('./util');\n\nvar Encoder = module.exports;\n\nEncoder.init = function(protos){\n\tthis.protos = protos || {};\n};\n\nEncoder.encode = function(route, msg){\n\tif(!route || !msg){\n\t\tconsole.warn('Route or msg can not be null! route : %j, msg %j', route, msg);\n\t\treturn null;\n\t}\n\n\t//Get protos from protos map use the route as key\n\tvar protos = this.protos[route];\n\n\t//Check msg\n\tif(!checkMsg(msg, protos)){\n\t\tconsole.warn('check msg failed! msg : %j, proto : %j', msg, protos);\n\t\treturn null;\n\t}\n\n\t//Set the length of the buffer 2 times bigger to prevent overflow\n\tvar length = Buffer.byteLength(JSON.stringify(msg))*2;\n\n\t//Init buffer and offset\n\tvar buffer = new Buffer(length);\n\tvar offset = 0;\n\n\tif(!!protos){\n\t\toffset = encodeMsg(buffer, offset, protos, msg);\n\t\tif(offset > 0){\n\t\t\treturn buffer.slice(0, offset);\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\n * Check if the msg follow the defination in the protos\n */\nfunction checkMsg(msg, protos){\n\tif(!protos || !msg){\n\t\tconsole.warn('no protos or msg exist! msg : %j, protos : %j', msg, protos);\n\t\treturn false;\n\t}\n\n\tfor(var name in protos){\n\t\tvar proto = protos[name];\n\n\t\t//All required element must exist\n\t\tswitch(proto.option){\n\t\t\tcase 'required' :\n\t\t\t\tif(typeof(msg[name]) === 'undefined'){\n\t\t\t\t\tconsole.warn('no property exist for required! name: %j, proto: %j, msg: %j', name, proto, msg);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\tcase 'optional' :\n\t\t\t\tif(typeof(msg[name]) !== 'undefined'){\n\t\t\t\t\tvar message = protos.__messages[proto.type] || Encoder.protos['message ' + proto.type];\n\t\t\t\t\tif(!!message && !checkMsg(msg[name], message)){\n\t\t\t\t\t\tconsole.warn('inner proto error! name: %j, proto: %j, msg: %j', name, proto, msg);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'repeated' :\n\t\t\t\t//Check nest message in repeated elements\n\t\t\t\tvar message = protos.__messages[proto.type] || Encoder.protos['message ' + proto.type];\n\t\t\t\tif(!!msg[name] && !!message){\n\t\t\t\t\tfor(var i = 0; i < msg[name].length; i++){\n\t\t\t\t\t\tif(!checkMsg(msg[name][i], message)){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction encodeMsg(buffer, offset, protos, msg){\n\tfor(var name in msg){\n\t\tif(!!protos[name]){\n\t\t\tvar proto = protos[name];\n\n\t\t\tswitch(proto.option){\n\t\t\t\tcase 'required' :\n\t\t\t\tcase 'optional' :\n\t\t\t\t\toffset = writeBytes(buffer, offset, encodeTag(proto.type, proto.tag));\n\t\t\t\t\toffset = encodeProp(msg[name], proto.type, offset, buffer, protos);\n\t\t\t\tbreak;\n\t\t\t\tcase 'repeated' :\n\t\t\t\t\tif(!!msg[name] && msg[name].length > 0){\n\t\t\t\t\t\toffset = encodeArray(msg[name], proto, offset, buffer, protos);\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn offset;\n}\n\nfunction encodeProp(value, type, offset, buffer, protos){\n\tvar length = 0;\n\n\tswitch(type){\n\t\tcase 'uInt32':\n\t\t\toffset = writeBytes(buffer, offset, codec.encodeUInt32(value));\n\t\tbreak;\n\t\tcase 'int32' :\n\t\tcase 'sInt32':\n\t\t\toffset = writeBytes(buffer, offset, codec.encodeSInt32(value));\n\t\tbreak;\n\t\tcase 'float':\n\t\t\tbuffer.writeFloatLE(value, offset);\n\t\t\toffset += 4;\n\t\tbreak;\n\t\tcase 'double':\n\t\t\tbuffer.writeDoubleLE(value, offset);\n\t\t\toffset += 8;\n\t\tbreak;\n\t\tcase 'string':\n\t\t\tlength = Buffer.byteLength(value);\n\n\t\t\t//Encode length\n\t\t\toffset = writeBytes(buffer, offset, codec.encodeUInt32(length));\n\t\t\t//write string\n\t\t\tbuffer.write(value, offset, length);\n\t\t\toffset += length;\n\t\tbreak;\n\t\tdefault :\n\t\t\tvar message = protos.__messages[type] || Encoder.protos['message ' + type];\n\t\t\tif(!!message){\n\t\t\t\t//Use a tmp buffer to build an internal msg\n\t\t\t\tvar tmpBuffer = new Buffer(Buffer.byteLength(JSON.stringify(value))*2);\n\t\t\t\tlength = 0;\n\n\t\t\t\tlength = encodeMsg(tmpBuffer, length, message, value);\n\t\t\t\t//Encode length\n\t\t\t\toffset = writeBytes(buffer, offset, codec.encodeUInt32(length));\n\t\t\t\t//contact the object\n\t\t\t\ttmpBuffer.copy(buffer, offset, 0, length);\n\n\t\t\t\toffset += length;\n\t\t\t}\n\t\tbreak;\n\t}\n\n\treturn offset;\n}\n\n/**\n * Encode reapeated properties, simple msg and object are decode differented\n */\nfunction encodeArray(array, proto, offset, buffer, protos){\n\tvar i = 0;\n\tif(util.isSimpleType(proto.type)){\n\t\toffset = writeBytes(buffer, offset, encodeTag(proto.type, proto.tag));\n\t\toffset = writeBytes(buffer, offset, codec.encodeUInt32(array.length));\n\t\tfor(i = 0; i < array.length; i++){\n\t\t\toffset = encodeProp(array[i], proto.type, offset, buffer);\n\t\t}\n\t}else{\n\t\tfor(i = 0; i < array.length; i++){\n\t\t\toffset = writeBytes(buffer, offset, encodeTag(proto.type, proto.tag));\n\t\t\toffset = encodeProp(array[i], proto.type, offset, buffer, protos);\n\t\t}\n\t}\n\n\treturn offset;\n}\n\nfunction writeBytes(buffer, offset, bytes){\n\tfor(var i = 0; i < bytes.length; i++){\n\t\tbuffer.writeUInt8(bytes[i], offset);\n\t\toffset++;\n\t}\n\n\treturn offset;\n}\n\nfunction encodeTag(type, tag){\n\tvar value = constant.TYPES[type];\n\n\tif(value === undefined) value = 2;\n\n\treturn codec.encodeUInt32((tag<<3)|value);\n}\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-protobuf/lib/codec.js":"var Encoder = module.exports;\n\n/**\n * [encode an uInt32, return a array of bytes]\n * @param  {[integer]} num\n * @return {[array]}\n */\nEncoder.encodeUInt32 = function(num){\n\tvar n = parseInt(num);\n\tif(isNaN(n) || n < 0){\n\t\tconsole.log(n);\n\t\treturn null;\n\t}\n\n\tvar result = [];\n\tdo{\n\t\tvar tmp = n % 128;\n\t\tvar next = Math.floor(n/128);\n\n\t\tif(next !== 0){\n\t\t\ttmp = tmp + 128;\n\t\t}\n\t\tresult.push(tmp);\n\t\tn = next;\n\t} while(n !== 0);\n\n\treturn result;\n};\n\n/**\n * [encode a sInt32, return a byte array]\n * @param  {[sInt32]} num  The sInt32 need to encode\n * @return {[array]} A byte array represent the integer\n */\nEncoder.encodeSInt32 = function(num){\n\tvar n = parseInt(num);\n\tif(isNaN(n)){\n\t\treturn null;\n\t}\n\tn = n<0?(Math.abs(n)*2-1):n*2;\n\n\treturn Encoder.encodeUInt32(n);\n};\n\nEncoder.decodeUInt32 = function(bytes){\n\tvar n = 0;\n\n\tfor(var i = 0; i < bytes.length; i++){\n\t\tvar m = parseInt(bytes[i]);\n\t\tn = n + ((m & 0x7f) * Math.pow(2,(7*i)));\n\t\tif(m < 128){\n\t\t\treturn n;\n\t\t}\n\t}\n\n\treturn n;\n};\n\n\nEncoder.decodeSInt32 = function(bytes){\n\tvar n = this.decodeUInt32(bytes);\n\tvar flag = ((n%2) === 1)?-1:1;\n\n\tn = ((n%2 + n)/2)*flag;\n\n\treturn n;\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-protobuf/lib/constant.js":"module.exports = {\n\tTYPES : {\n\t\tuInt32 : 0,\n\t\tsInt32 : 0,\n\t\tint32 : 0,\n\t\tdouble : 1,\n\t\tstring : 2,\n\t\tmessage : 2,\n\t\tfloat : 5\n\t}\n}","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-protobuf/lib/util.js":"var util = module.exports;\n\nutil.isSimpleType = function(type){\n\treturn ( type === 'uInt32' ||\n\t\t\t\t\t type === 'sInt32' ||\n\t\t\t\t\t type === 'int32'  ||\n\t\t\t\t\t type === 'uInt64' ||\n\t\t\t\t\t type === 'sInt64' ||\n\t\t\t\t\t type === 'float'  ||\n\t\t\t\t\t type === 'double');\n};\n\nutil.equal = function(obj0, obj1){\n\tfor(var key in obj0){\n\t\tvar m = obj0[key];\n\t\tvar n = obj1[key];\n\n\t\tif(typeof(m) === 'object'){\n\t\t\tif(!util.equal(m, n)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if(m !== n){\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-protobuf/lib/decoder.js":"var codec = require('./codec');\nvar util = require('./util');\n\nvar Decoder = module.exports;\n\nvar buffer;\nvar offset = 0;\n\nDecoder.init = function(protos){\n\tthis.protos = protos || {};\n};\n\nDecoder.setProtos = function(protos){\n\tif(!!protos){\n\t\tthis.protos = protos;\n\t}\n};\n\nDecoder.decode = function(route, buf){\n\tvar protos = this.protos[route];\n\n\tbuffer = buf;\n\toffset = 0;\n\n\tif(!!protos){\n\t\treturn decodeMsg({}, protos, buffer.length);\n\t}\n\n\treturn null;\n};\n\nfunction decodeMsg(msg, protos, length){\n\twhile(offset<length){\n\t\tvar head = getHead();\n\t\tvar type = head.type;\n\t\tvar tag = head.tag;\n\t\tvar name = protos.__tags[tag];\n\n\t\tswitch(protos[name].option){\n\t\t\tcase 'optional' :\n\t\t\tcase 'required' :\n\t\t\t\tmsg[name] = decodeProp(protos[name].type, protos);\n\t\t\tbreak;\n\t\t\tcase 'repeated' :\n\t\t\t\tif(!msg[name]){\n\t\t\t\t\tmsg[name] = [];\n\t\t\t\t}\n\t\t\t\tdecodeArray(msg[name], protos[name].type, protos);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn msg;\n}\n\n/**\n * Test if the given msg is finished\n */\nfunction isFinish(msg, protos){\n\treturn (!protos.__tags[peekHead().tag]);\n}\n/**\n * Get property head from protobuf\n */\nfunction getHead(){\n\tvar tag = codec.decodeUInt32(getBytes());\n\n\treturn {\n\t\ttype : tag&0x7,\n\t\ttag\t: tag>>3\n\t};\n}\n\n/**\n * Get tag head without move the offset\n */\nfunction peekHead(){\n\tvar tag = codec.decodeUInt32(peekBytes());\n\n\treturn {\n\t\ttype : tag&0x7,\n\t\ttag\t: tag>>3\n\t};\n}\n\nfunction decodeProp(type, protos){\n\tswitch(type){\n\t\tcase 'uInt32':\n\t\t\treturn codec.decodeUInt32(getBytes());\n\t\tcase 'int32' :\n\t\tcase 'sInt32' :\n\t\t\treturn codec.decodeSInt32(getBytes());\n\t\tcase 'float' :\n\t\t\tvar float = buffer.readFloatLE(offset);\n\t\t\toffset += 4;\n\t\t\treturn float;\n\t\tcase 'double' :\n\t\t\tvar double = buffer.readDoubleLE(offset);\n\t\t\toffset += 8;\n\t\t\treturn double;\n\t\tcase 'string' :\n\t\t\tvar length = codec.decodeUInt32(getBytes());\n\n\t\t\tvar str =  buffer.toString('utf8', offset, offset+length);\n\t\t\toffset += length;\n\n\t\t\treturn str;\n\t\tdefault :\n\t\t\tvar message = protos && (protos.__messages[type] || Decoder.protos['message ' + type]);\n\t\t\tif(message){\n\t\t\t\tvar length = codec.decodeUInt32(getBytes());\n\t\t\t\tvar msg = {};\n\t\t\t\tdecodeMsg(msg, message, offset+length);\n\t\t\t\treturn msg;\n\t\t\t}\n\t\tbreak;\n\t}\n}\n\nfunction decodeArray(array, type, protos){\n\tif(util.isSimpleType(type)){\n\t\tvar length = codec.decodeUInt32(getBytes());\n\n\t\tfor(var i = 0; i < length; i++){\n\t\t\tarray.push(decodeProp(type));\n\t\t}\n\t}else{\n\t\tarray.push(decodeProp(type, protos));\n\t}\n}\n\nfunction getBytes(flag){\n\tvar bytes = [];\n\tvar pos = offset;\n\tflag = flag || false;\n\n\tvar b;\n\tdo{\n\t\tvar b = buffer.readUInt8(pos);\n\t\tbytes.push(b);\n\t\tpos++;\n\t}while(b >= 128);\n\n\tif(!flag){\n\t\toffset = pos;\n\t}\n\treturn bytes;\n}\n\nfunction peekBytes(){\n\treturn getBytes(true);\n}","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-protobuf/lib/parser.js":"var Parser = module.exports;\n\n/**\n * [parse the original protos, give the paresed result can be used by protobuf encode/decode.]\n * @param  {[Object]} protos Original protos, in a js map.\n * @return {[Object]} The presed result, a js object represent all the meta data of the given protos.\n */\nParser.parse = function(protos){\n\tvar maps = {};\n\tfor(var key in protos){\n\t\tmaps[key] = parseObject(protos[key]);\n\t}\n\n\treturn maps;\n};\n\n/**\n * [parse a single protos, return a object represent the result. The method can be invocked recursively.]\n * @param  {[Object]} obj The origin proto need to parse.\n * @return {[Object]} The parsed result, a js object.\n */\nfunction parseObject(obj){\n\tvar proto = {};\n\tvar nestProtos = {};\n\tvar tags = {};\n\n\tfor(var name in obj){\n\t\tvar tag = obj[name];\n\t\tvar params = name.split(' ');\n\n\t\tswitch(params[0]){\n\t\t\tcase 'message':\n\t\t\t\tif(params.length !== 2){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnestProtos[params[1]] = parseObject(tag);\n\t\t\t\tcontinue;\n\t\t\tcase 'required':\n\t\t\tcase 'optional':\n\t\t\tcase 'repeated':{\n\t\t\t\t//params length should be 3 and tag can't be duplicated\n\t\t\t\tif(params.length !== 3 || !!tags[tag]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tproto[params[2]] = {\n\t\t\t\t\toption : params[0],\n\t\t\t\t\ttype : params[1],\n\t\t\t\t\ttag : tag\n\t\t\t\t};\n\t\t\t\ttags[tag] = params[2];\n\t\t\t}\n\t\t}\n\t}\n\n\tproto.__messages = nestProtos;\n\tproto.__tags = tags;\n\treturn proto;\n}","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/components/proxy.js":"/**\n * Component for proxy.\n * Generate proxies for rpc client.\n */\nvar crc = require('crc');\nvar utils = require('../util/utils');\nvar events = require('../util/events');\nvar Client = require('pomelo-rpc').client;\nvar pathUtil = require('../util/pathUtil');\nvar Constants = require('../util/constants');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\n\n/**\n * Component factory function\n *\n * @param {Object} app  current application context\n * @param {Object} opts construct parameters\n *                      opts.router: (optional) rpc message route function, route(routeParam, msg, cb),\n *                      opts.mailBoxFactory: (optional) mail box factory instance.\n * @return {Object}     component instance\n */\nmodule.exports = function(app, opts) {\n  opts = opts || {};\n  // proxy default config\n  // cacheMsg is deprecated, just for compatibility here.\n  opts.bufferMsg = opts.bufferMsg || opts.cacheMsg || false;\n  opts.interval = opts.interval || 30;\n  opts.router = genRouteFun();\n  opts.context = app;\n  opts.routeContext = app;\n  if (app.enabled('rpcDebugLog')) {\n    opts.rpcDebugLog = true;\n    opts.rpcLogger = require('pomelo-logger').getLogger('rpc-debug', __filename);\n  }\n\n  return new Component(app, opts);\n};\n\n/**\n * Proxy component class\n *\n * @param {Object} app  current application context\n * @param {Object} opts construct parameters\n */\nvar Component = function(app, opts) {\n  this.app = app;\n  this.opts = opts;\n  this.client = genRpcClient(this.app, opts);\n  this.app.event.on(events.ADD_SERVERS, this.addServers.bind(this));\n  this.app.event.on(events.REMOVE_SERVERS, this.removeServers.bind(this));\n  this.app.event.on(events.REPLACE_SERVERS, this.replaceServers.bind(this));\n};\n\nvar pro = Component.prototype;\n\npro.name = '__proxy__';\n\n/**\n * Proxy component lifecycle function\n *\n * @param {Function} cb\n * @return {Void}\n */\npro.start = function(cb) {\n  if(this.opts.enableRpcLog) {\n    logger.warn('enableRpcLog is deprecated in 0.8.0, please use app.rpcFilter(pomelo.rpcFilters.rpcLog())');\n  }\n  var rpcBefores = this.app.get(Constants.KEYWORDS.RPC_BEFORE_FILTER);\n  var rpcAfters = this.app.get(Constants.KEYWORDS.RPC_AFTER_FILTER);\n  var rpcErrorHandler = this.app.get(Constants.RESERVED.RPC_ERROR_HANDLER);\n\n  if(!!rpcBefores) {\n    this.client.before(rpcBefores);\n  } \n  if(!!rpcAfters) {\n    this.client.after(rpcAfters);\n  }\n  if(!!rpcErrorHandler) {\n    this.client.setErrorHandler(rpcErrorHandler);\n  }\n  process.nextTick(cb);\n};\n\n/**\n * Component lifecycle callback\n *\n * @param {Function} cb\n * @return {Void}\n */\npro.afterStart = function(cb) {\n  var self = this;\n  this.app.__defineGetter__('rpc', function() {\n    return self.client.proxies.user;\n  });\n  this.app.__defineGetter__('sysrpc', function() {\n    return self.client.proxies.sys;\n  });\n  this.app.set('rpcInvoke', this.client.rpcInvoke.bind(this.client), true);\n  this.client.start(cb);\n};\n\n/**\n * Add remote server to the rpc client.\n *\n * @param {Array} servers server info list, {id, serverType, host, port}\n */\npro.addServers = function(servers) {\n  if (!servers || !servers.length) {\n    return;\n  }\n\n  genProxies(this.client, this.app, servers);\n  this.client.addServers(servers);\n};\n\n/**\n * Remove remote server from the rpc client.\n *\n * @param  {Array} ids server id list\n */\npro.removeServers = function(ids) {\n  this.client.removeServers(ids);\n};\n\n/**\n * Replace remote servers from the rpc client.\n *\n * @param  {Array} ids server id list\n */\npro.replaceServers = function(servers) {\n  if (!servers || !servers.length) {\n    return;\n  }\n\n  // update proxies\n  this.client.proxies = {};\n  genProxies(this.client, this.app, servers);\n\n  this.client.replaceServers(servers);\n};\n\n/**\n * Proxy for rpc client rpcInvoke.\n *\n * @param {String}   serverId remote server id\n * @param {Object}   msg      rpc message: {serverType: serverType, service: serviceName, method: methodName, args: arguments}\n * @param {Function} cb      callback function\n */\npro.rpcInvoke = function(serverId, msg, cb) {\n  this.client.rpcInvoke(serverId, msg, cb);\n};\n\n/**\n * Generate rpc client\n *\n * @param {Object} app current application context\n * @param {Object} opts contructor parameters for rpc client\n * @return {Object} rpc client\n */\nvar genRpcClient = function(app, opts) {\n  opts.context = app;\n  opts.routeContext = app;\n  if(!!opts.rpcClient) {\n    return opts.rpcClient.create(opts);\n  } else {\n    return Client.create(opts);\n  }\n};\n\n/**\n * Generate proxy for the server infos.\n *\n * @param  {Object} client rpc client instance\n * @param  {Object} app    application context\n * @param  {Array} sinfos server info list\n */\nvar genProxies = function(client, app, sinfos) {\n  var item;\n  for (var i = 0, l = sinfos.length; i < l; i++) {\n    item = sinfos[i];\n    if (hasProxy(client, item)) {\n      continue;\n    }\n    client.addProxies(getProxyRecords(app, item));\n  }\n};\n\n/**\n * Check a server whether has generated proxy before\n *\n * @param  {Object}  client rpc client instance\n * @param  {Object}  sinfo  server info\n * @return {Boolean}        true or false\n */\nvar hasProxy = function(client, sinfo) {\n  var proxy = client.proxies;\n  return !!proxy.sys && !! proxy.sys[sinfo.serverType];\n};\n\n/**\n * Get proxy path for rpc client.\n * Iterate all the remote service path and create remote path record.\n *\n * @param {Object} app current application context\n * @param {Object} sinfo server info, format: {id, serverType, host, port}\n * @return {Array}     remote path record array\n */\nvar getProxyRecords = function(app, sinfo) {\n  var records = [],\n    appBase = app.getBase(),\n    record;\n  // sys remote service path record\n  if (app.isFrontend(sinfo)) {\n    record = pathUtil.getSysRemotePath('frontend');\n  } else {\n    record = pathUtil.getSysRemotePath('backend');\n  }\n  if (record) {\n    records.push(pathUtil.remotePathRecord('sys', sinfo.serverType, record));\n  }\n\n  // user remote service path record\n  record = pathUtil.getUserRemotePath(appBase, sinfo.serverType);\n  if (record) {\n    records.push(pathUtil.remotePathRecord('user', sinfo.serverType, record));\n  }\n\n  return records;\n};\n\nvar genRouteFun = function() {\n  return function(session, msg, app, cb) {\n    var routes = app.get('__routes__');\n\n    if (!routes) {\n      defaultRoute(session, msg, app, cb);\n      return;\n    }\n\n    var type = msg.serverType,\n      route = routes[type] || routes['default'];\n\n    if (route) {\n      route(session, msg, app, cb);\n    } else {\n      defaultRoute(session, msg, app, cb);\n    }\n  };\n};\n\nvar defaultRoute = function(session, msg, app, cb) {\n  var list = app.getServersByType(msg.serverType);\n  if (!list || !list.length) {\n    cb(new Error('can not find server info for type:' + msg.serverType));\n    return;\n  }\n\n  var uid = session ? (session.uid || '') : '';\n  var index = Math.abs(crc.crc32(uid.toString())) % list.length;\n  utils.invokeCallback(cb, null, list[index].id);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/index.js":"if(process.env.POMELO_RPC_COV) {\n  module.exports.client = require('./lib-cov/rpc-client/client');\n  module.exports.server = require('./lib-cov/rpc-server/server');\n} else {\n  module.exports.client = require('./lib/rpc-client/client');\n  module.exports.server = require('./lib/rpc-server/server');\n}","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/rpc-client/client.js":"var logger = require('pomelo-logger').getLogger('pomelo-rpc', 'rpc-client');\nvar failureProcess = require('./failureProcess');\nvar constants = require('../util/constants');\nvar Station = require('./mailstation');\nvar Tracer = require('../util/tracer');\nvar Loader = require('pomelo-loader');\nvar utils = require('../util/utils');\nvar Proxy = require('../util/proxy');\nvar router = require('./router');\nvar async = require('async');\n\n/**\n * Client states\n */\nvar STATE_INITED = 1; // client has inited\nvar STATE_STARTED = 2; // client has started\nvar STATE_CLOSED = 3; // client has closed\n\n/**\n * RPC Client Class\n */\nvar Client = function(opts) {\n  opts = opts || {};\n  this._context = opts.context;\n  this._routeContext = opts.routeContext;\n  this.router = opts.router || router.df;\n  this.routerType = opts.routerType;\n  this.rpcDebugLog = opts.rpcDebugLog;\n  if (this._context) {\n    opts.clientId = this._context.serverId;\n  }\n  this.opts = opts;\n  this.proxies = {};\n  this._station = createStation(opts);\n  this.state = STATE_INITED;\n};\n\nvar pro = Client.prototype;\n\n/**\n * Start the rpc client which would try to connect the remote servers and\n * report the result by cb.\n *\n * @param cb {Function} cb(err)\n */\npro.start = function(cb) {\n  if (this.state > STATE_INITED) {\n    cb(new Error('rpc client has started.'));\n    return;\n  }\n\n  var self = this;\n  this._station.start(function(err) {\n    if (err) {\n      logger.error('[pomelo-rpc] client start fail for ' + err.stack);\n      return cb(err);\n    }\n    self._station.on('error', failureProcess.bind(self._station));\n    self.state = STATE_STARTED;\n    cb();\n  });\n};\n\n/**\n * Stop the rpc client.\n *\n * @param  {Boolean} force\n * @return {Void}\n */\npro.stop = function(force) {\n  if (this.state !== STATE_STARTED) {\n    logger.warn('[pomelo-rpc] client is not running now.');\n    return;\n  }\n  this.state = STATE_CLOSED;\n  this._station.stop(force);\n};\n\n/**\n * Add a new proxy to the rpc client which would overrid the proxy under the\n * same key.\n *\n * @param {Object} record proxy description record, format:\n *                        {namespace, serverType, path}\n */\npro.addProxy = function(record) {\n  if (!record) {\n    return;\n  }\n  var proxy = generateProxy(this, record, this._context);\n  if (!proxy) {\n    return;\n  }\n  insertProxy(this.proxies, record.namespace, record.serverType, proxy);\n};\n\n/**\n * Batch version for addProxy.\n *\n * @param {Array} records list of proxy description record\n */\npro.addProxies = function(records) {\n  if (!records || !records.length) {\n    return;\n  }\n  for (var i = 0, l = records.length; i < l; i++) {\n    this.addProxy(records[i]);\n  }\n};\n\n/**\n * Add new remote server to the rpc client.\n *\n * @param {Object} server new server information\n */\npro.addServer = function(server) {\n  this._station.addServer(server);\n};\n\n/**\n * Batch version for add new remote server.\n *\n * @param {Array} servers server info list\n */\npro.addServers = function(servers) {\n  this._station.addServers(servers);\n};\n\n/**\n * Remove remote server from the rpc client.\n *\n * @param  {String|Number} id server id\n */\npro.removeServer = function(id) {\n  this._station.removeServer(id);\n};\n\n/**\n * Batch version for remove remote server.\n *\n * @param  {Array} ids remote server id list\n */\npro.removeServers = function(ids) {\n  this._station.removeServers(ids);\n};\n\n/**\n * Replace remote servers.\n *\n * @param {Array} servers server info list\n */\npro.replaceServers = function(servers) {\n  this._station.replaceServers(servers);\n};\n\n/**\n * Do the rpc invoke directly.\n *\n * @param serverId {String} remote server id\n * @param msg {Object} rpc message. Message format:\n *    {serverType: serverType, service: serviceName, method: methodName, args: arguments}\n * @param cb {Function} cb(err, ...)\n */\npro.rpcInvoke = function(serverId, msg, cb) {\n  var rpcDebugLog = this.rpcDebugLog;\n  var tracer = null;\n\n  if (rpcDebugLog) {\n    tracer = new Tracer(this.opts.rpcLogger, this.opts.rpcDebugLog, this.opts.clientId, serverId, msg);\n    tracer.info('client', __filename, 'rpcInvoke', 'the entrance of rpc invoke');\n  }\n\n  if (this.state !== STATE_STARTED) {\n    tracer && tracer.error('client', __filename, 'rpcInvoke', 'fail to do rpc invoke for client is not running');\n    logger.error('[pomelo-rpc] fail to do rpc invoke for client is not running');\n    cb(new Error('[pomelo-rpc] fail to do rpc invoke for client is not running'));\n    return;\n  }\n  this._station.dispatch(tracer, serverId, msg, this.opts, cb);\n};\n\n/**\n * Add rpc before filter.\n * \n * @param filter {Function} rpc before filter function.\n *\n * @api public\n */\npro.before = function(filter) {\n  this._station.before(filter);\n};\n\n/**\n * Add rpc after filter.\n * \n * @param filter {Function} rpc after filter function.\n *\n * @api public\n */\npro.after = function(filter) {\n  this._station.after(filter);\n};\n\n/**\n * Add rpc filter.\n * \n * @param filter {Function} rpc filter function.\n *\n * @api public\n */\npro.filter = function(filter) {\n  this._station.filter(filter);\n};\n\n/**\n * Set rpc filter error handler.\n * \n * @param handler {Function} rpc filter error handler function.\n *\n * @api public\n */\npro.setErrorHandler = function(handler) {\n  this._station.handleError = handler;\n};\n\n/**\n * Create mail station.\n *\n * @param opts {Object} construct parameters.\n *\n * @api private\n */\nvar createStation = function(opts) {\n  return Station.create(opts);\n};\n\n/**\n * Generate proxies for remote servers.\n *\n * @param client {Object} current client instance.\n * @param record {Object} proxy reocrd info. {namespace, serverType, path}\n * @param context {Object} mailbox init context parameter\n *\n * @api private\n */\nvar generateProxy = function(client, record, context) {\n  if (!record) {\n    return;\n  }\n  var res, name;\n  var modules = Loader.load(record.path, context);\n  if (modules) {\n    res = {};\n    for (name in modules) {\n      res[name] = Proxy.create({\n        service: name,\n        origin: modules[name],\n        attach: record,\n        proxyCB: proxyCB.bind(null, client)\n      });\n    }\n  }\n  return res;\n};\n\n/**\n * Generate prxoy for function type field\n *\n * @param client {Object} current client instance.\n * @param serviceName {String} delegated service name.\n * @param methodName {String} delegated method name.\n * @param args {Object} rpc invoke arguments.\n * @param attach {Object} attach parameter pass to proxyCB.\n * @param isToSpecifiedServer {boolean} true means rpc route to specified remote server.\n *\n * @api private\n */\nvar proxyCB = function(client, serviceName, methodName, args, attach, isToSpecifiedServer) {\n  if (client.state !== STATE_STARTED) {\n    logger.error('[pomelo-rpc] fail to invoke rpc proxy for client is not running');\n    return;\n  }\n  if (args.length < 2) {\n    logger.error('[pomelo-rpc] invalid rpc invoke, arguments length less than 2, namespace: %j, serverType, %j, serviceName: %j, methodName: %j',\n      attach.namespace, attach.serverType, serviceName, methodName);\n    return;\n  }\n  var routeParam = args.shift();\n  var cb = args.pop();\n  var serverType = attach.serverType;\n  var msg = {\n    namespace: attach.namespace,\n    serverType: serverType,\n    service: serviceName,\n    method: methodName,\n    args: args\n  };\n\n  if (isToSpecifiedServer) {\n    rpcToSpecifiedServer(client, msg, serverType, routeParam, cb);\n  } else {\n    getRouteTarget(client, serverType, msg, routeParam, function(err, serverId) {\n      if (err) {\n        return cb(err);\n      }\n\n      client.rpcInvoke(serverId, msg, cb);\n    });\n  }\n};\n\n/**\n * Calculate remote target server id for rpc client.\n *\n * @param client {Object} current client instance.\n * @param serverType {String} remote server type.\n * @param routeParam {Object} mailbox init context parameter.\n * @param cb {Function} return rpc remote target server id.\n *\n * @api private\n */\nvar getRouteTarget = function(client, serverType, msg, routeParam, cb) {\n  if (!!client.routerType) {\n    var method;\n    switch (client.routerType) {\n      case constants.SCHEDULE.ROUNDROBIN:\n        method = router.rr;\n        break;\n      case constants.SCHEDULE.WEIGHT_ROUNDROBIN:\n        method = router.wrr;\n        break;\n      case constants.SCHEDULE.LEAST_ACTIVE:\n        method = router.la;\n        break;\n      case constants.SCHEDULE.CONSISTENT_HASH:\n        method = router.ch;\n        break;\n      default:\n        method = router.rd;\n        break;\n    }\n    method.call(null, client, serverType, msg, function(err, serverId) {\n      cb(err, serverId);\n    });\n  } else {\n    var route, target;\n    if (typeof client.router === 'function') {\n      route = client.router;\n      target = null;\n    } else if (typeof client.router.route === 'function') {\n      route = client.router.route;\n      target = client.router;\n    } else {\n      logger.error('[pomelo-rpc] invalid route function.');\n      return;\n    }\n    route.call(target, routeParam, msg, client._routeContext, function(err, serverId) {\n      cb(err, serverId);\n    });\n  }\n};\n\n/**\n * Rpc to specified server id or servers.\n *\n * @param client     {Object} current client instance.\n * @param msg        {Object} rpc message.\n * @param serverType {String} remote server type.\n * @param serverId   {Object} mailbox init context parameter.\n *\n * @api private\n */\nvar rpcToSpecifiedServer = function(client, msg, serverType, serverId, cb) {\n  if (typeof serverId !== 'string') {\n    logger.error('[pomelo-rpc] serverId is not a string : %s', serverId);\n    return;\n  }\n  if (serverId === '*') {\n    var servers = client._routeContext.getServersByType(serverType);\n    if (!servers) {\n      logger.error('[pomelo-rpc] serverType %s servers not exist', serverType);\n      return;\n    }\n\n    async.each(servers, function(server, next) {\n      var serverId = server['id'];\n      client.rpcInvoke(serverId, msg, function(err) {\n        next(err);\n      });\n    }, cb);\n  } else {\n    client.rpcInvoke(serverId, msg, cb);\n  }\n};\n\n/**\n * Add proxy into array.\n * \n * @param proxies {Object} rpc proxies\n * @param namespace {String} rpc namespace sys/user\n * @param serverType {String} rpc remote server type\n * @param proxy {Object} rpc proxy\n *\n * @api private\n */\nvar insertProxy = function(proxies, namespace, serverType, proxy) {\n  proxies[namespace] = proxies[namespace] || {};\n  if (proxies[namespace][serverType]) {\n    for (var attr in proxy) {\n      proxies[namespace][serverType][attr] = proxy[attr];\n    }\n  } else {\n    proxies[namespace][serverType] = proxy;\n  }\n};\n\n/**\n * RPC client factory method.\n *\n * @param  {Object}      opts client init parameter.\n *                       opts.context: mail box init parameter,\n *                       opts.router: (optional) rpc message route function, route(routeParam, msg, cb),\n *                       opts.mailBoxFactory: (optional) mail box factory instance.\n * @return {Object}      client instance.\n */\nmodule.exports.create = function(opts) {\n  return new Client(opts);\n};\n\n// module.exports.WSMailbox = require('./mailboxes/ws-mailbox'); // socket.io \n// module.exports.WS2Mailbox = require('./mailboxes/ws2-mailbox'); // ws\nmodule.exports.MQTTMailbox = require('./mailboxes/mqtt-mailbox'); // mqtt","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/rpc-client/failureProcess.js":"var logger = require('pomelo-logger').getLogger('pomelo-rpc', 'failprocess');\nvar constants = require('../util/constants');\nvar utils = require('../util/utils');\n\nmodule.exports = function(code, tracer, serverId, msg, opts) {\n\tvar cb = tracer && tracer.cb;\n\tvar mode = opts.failMode;\n\tvar FAIL_MODE = constants.FAIL_MODE;\n\tvar method = failfast;\n\n\tif (mode == FAIL_MODE.FAILOVER) {\n\t\tmethod = failover;\n\t} else if (mode == FAIL_MODE.FAILBACK) {\n\t\tmethod = failback;\n\t} else if (mode == FAIL_MODE.FAILFAST) {\n\n\t}\n\t// switch (mode) {\n\t// \tcase constants.FAIL_MODE.FAILOVER:\n\t// \t\tmethod = failover;\n\t// \t\tbreak;\n\t// \tcase constants.FAIL_MODE.FAILBACK:\n\t// \t\tmethod = failback;\n\t// \t\tbreak;\n\t// \tcase constants.FAIL_MODE.FAILFAST:\n\t// \t\tmethod = failfast;\n\t// \t\tbreak;\n\t// \tcase constants.FAIL_MODE.FAILSAFE:\n\t// \tdefault:\n\t// \t\tmethod = failfast;\n\t// \t\tbreak;\n\t// }\n\tmethod.call(this, code, tracer, serverId, msg, opts, cb);\n};\n\n/**\n * Failover rpc failure process. This will try other servers with option retries.\n *\n * @param code {Number} error code number.\n * @param tracer {Object} current rpc tracer.\n * @param serverId {String} rpc remote target server id.\n * @param msg {Object} rpc message.\n * @param opts {Object} rpc client options.\n * @param cb {Function} user rpc callback.\n *\n * @api private\n */\nvar failover = function(code, tracer, serverId, msg, opts, cb) {\n\tvar servers;\n\tvar self = this;\n\tvar counter = 0;\n\tvar success = true;\n\tvar serverType = msg.serverType;\n\tif (!tracer || !tracer.servers) {\n\t\tservers = self.serversMap[serverType];\n\t} else {\n\t\tservers = tracer.servers;\n\t}\n\n\tvar index = servers.indexOf(serverId);\n\tif (index >= 0) {\n\t\tservers.splice(index, 1);\n\t}\n\ttracer && (tracer.servers = servers);\n\n\tif (!servers.length) {\n\t\tlogger.error('[pomelo-rpc] rpc failed with all this type of servers, with serverType: %s', serverType);\n\t\tcb(new Error('rpc failed with all this type of servers, with serverType: ' + serverType));\n\t\treturn;\n\t}\n\tself.dispatch.call(self, tracer, servers[0], msg, opts, cb);\n};\n\n/**\n * Failsafe rpc failure process.\n *\n * @param code {Number} error code number.\n * @param tracer {Object} current rpc tracer.\n * @param serverId {String} rpc remote target server id.\n * @param msg {Object} rpc message.\n * @param opts {Object} rpc client options.\n * @param cb {Function} user rpc callback.\n *\n * @api private\n */\nvar failsafe = function(code, tracer, serverId, msg, opts, cb) {\n\tvar self = this;\n\tvar retryTimes = opts.retryTimes || constants.DEFAULT_PARAM.FAILSAFE_RETRIES;\n\tvar retryConnectTime = opts.retryConnectTime || constants.DEFAULT_PARAM.FAILSAFE_CONNECT_TIME;\n\n\tif (!tracer.retryTimes) {\n\t\ttracer.retryTimes = 1;\n\t} else {\n\t\ttracer.retryTimes += 1;\n\t}\n\tswitch (code) {\n\t\tcase constants.RPC_ERROR.SERVER_NOT_STARTED:\n\t\tcase constants.RPC_ERROR.NO_TRAGET_SERVER:\n\t\t\tcb(new Error('rpc client is not started or cannot find remote server.'));\n\t\t\tbreak;\n\t\tcase constants.RPC_ERROR.FAIL_CONNECT_SERVER:\n\t\t\tif (tracer.retryTimes <= retryTimes) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tself.connect(tracer, serverId, cb);\n\t\t\t\t}, retryConnectTime * tracer.retryTimes);\n\t\t\t} else {\n\t\t\t\tcb(new Error('rpc client failed to connect to remote server: ' + serverId));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase constants.RPC_ERROR.FAIL_FIND_MAILBOX:\n\t\tcase constants.RPC_ERROR.FAIL_SEND_MESSAGE:\n\t\t\tif (tracer.retryTimes <= retryTimes) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tself.dispatch.call(self, tracer, serverId, msg, opts, cb);\n\t\t\t\t}, retryConnectTime * tracer.retryTimes);\n\t\t\t} else {\n\t\t\t\tcb(new Error('rpc client failed to send message to remote server: ' + serverId));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase constants.RPC_ERROR.FILTER_ERROR:\n\t\t\tcb(new Error('rpc client filter encounters error.'));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcb(new Error('rpc client unknown error.'));\n\t}\n};\n\n/**\n * Failback rpc failure process. This will try the same server with sendInterval option and retries option.\n *\n * @param code {Number} error code number.\n * @param tracer {Object} current rpc tracer.\n * @param serverId {String} rpc remote target server id.\n * @param msg {Object} rpc message.\n * @param opts {Object} rpc client options.\n * @param cb {Function} user rpc callback.\n *\n * @api private\n */\nvar failback = function(code, tracer, serverId, msg, opts, cb) {\n\t// todo record message in background and send the message at timing\n};\n\n/**\n * Failfast rpc failure process. This will ignore error in rpc client.\n *\n * @param code {Number} error code number.\n * @param tracer {Object} current rpc tracer.\n * @param serverId {String} rpc remote target server id.\n * @param msg {Object} rpc message.\n * @param opts {Object} rpc client options.\n * @param cb {Function} user rpc callback.\n *\n * @api private\n */\nvar failfast = function(code, tracer, serverId, msg, opts, cb) {\n\tlogger.error('rpc failed with error, remote server: %s, msg: %j, error code: %s', serverId, msg, code);\n\tcb && cb(new Error('rpc failed with error code: ' + code));\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/util/constants.js":"module.exports = {\n\tFAIL_MODE: {\n\t\tFAILOVER: 'failover',\n\t\tFAILFAST: 'failfast',\n\t\tFAILSAFE: 'failsafe',\n\t\tFAILBACK: 'failback'\n\t},\n\tSCHEDULE: {\n\t\tROUNDROBIN: 'rr',\n\t\tWEIGHT_ROUNDROBIN: 'wrr',\n\t\tLEAST_ACTIVE: 'la',\n\t\tCONSISTENT_HASH: 'ch'\n\t},\n\tDEFAULT_PARAM: {\n\t\tFAILSAFE_RETRIES: 3,\n\t\tFAILSAFE_CONNECT_TIME: 5 * 1000,\n\t\tCALLBACK_TIMEOUT: 30 * 1000,\n\t\tINTERVAL: 50,\n\t\tGRACE_TIMEOUT: 3 * 1000,\n\t\tDEFAULT_PENDING_SIZE: 10000,\n\t\tKEEPALIVE: 10 * 1000\n\t},\n\tRPC_ERROR: {\n\t\tSERVER_NOT_STARTED: 1,\n\t\tNO_TRAGET_SERVER: 2,\n\t\tFAIL_CONNECT_SERVER: 3,\n\t\tFAIL_FIND_MAILBOX: 4,\n\t\tFAIL_SEND_MESSAGE: 5,\n\t\tFILTER_ERROR: 6\n\t},\n\tTOPIC_RPC: 'r',\n\tTOPIC_HANDSHAKE: 'h'\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/util/utils.js":"var Utils = {};\n\nUtils.invokeCallback = function(cb) {\n\tif (typeof cb === 'function') {\n\t\tcb.apply(null, Array.prototype.slice.call(arguments, 1));\n\t}\n};\n\nUtils.applyCallback = function(cb, args) {\n\tif (typeof cb === 'function') {\n\t\tcb.apply(null, args);\n\t}\n};\n\nUtils.getObjectClass = function(obj) {\n\tif (!obj) {\n\t\treturn;\n\t}\n\n\tvar constructor = obj.constructor;\n\tif (!constructor) {\n\t\treturn;\n\t}\n\n\tif (constructor.name) {\n\t\treturn constructor.name;\n\t}\n\n\tvar str = constructor.toString();\n\tif (!str) {\n\t\treturn;\n\t}\n\n\tvar arr = null;\n\tif (str.charAt(0) == '[') {\n\t\tarr = str.match(/\\[\\w+\\s*(\\w+)\\]/);\n\t} else {\n\t\tarr = str.match(/function\\s*(\\w+)/);\n\t}\n\n\tif (arr && arr.length == 2) {\n\t\treturn arr[1];\n\t}\n};\n\n/**\n * Utils check float\n *\n * @param  {Float}   float\n * @return {Boolean} true|false\n * @api public\n */\nUtils.checkFloat = function(v) {\n\treturn v === Number(v) && v % 1 !== 0;\n\t// return parseInt(v) !== v;\n}\n\n/**\n * Utils check type\n *\n * @param  {String}   type\n * @return {Function} high order function\n * @api public\n */\nUtils.isType = function(type) {\n\treturn function(obj) {\n\t\treturn {}.toString.call(obj) == \"[object \" + type + \"]\";\n\t}\n}\n\n/**\n * Utils check array\n *\n * @param  {Array}   array\n * @return {Boolean} true|false\n * @api public\n */\nUtils.checkArray = Array.isArray || Utils.isType(\"Array\");\n\n/**\n * Utils check number\n *\n * @param  {Number}  number\n * @return {Boolean} true|false\n * @api public\n */\nUtils.checkNumber = Utils.isType(\"Number\");\n\n/**\n * Utils check function\n *\n * @param  {Function}   func function\n * @return {Boolean}    true|false\n * @api public\n */\nUtils.checkFunction = Utils.isType(\"Function\");\n/**\n * Utils check object\n *\n * @param  {Object}   obj object\n * @return {Boolean}  true|false\n * @api public\n */\nUtils.checkObject = Utils.isType(\"Object\");\n\n/**\n * Utils check string\n *\n * @param  {String}   string\n * @return {Boolean}  true|false\n * @api public\n */\nUtils.checkString = Utils.isType(\"String\");\n\n/**\n * Utils check boolean\n *\n * @param  {Object}   obj object\n * @return {Boolean}  true|false\n * @api public\n */\nUtils.checkBoolean = Utils.isType(\"Boolean\");\n\n/**\n * Utils check bean\n *\n * @param  {Object}   obj object\n * @return {Boolean}  true|false\n * @api public\n */\nUtils.checkBean = function(obj) {\n\treturn obj && obj['$id'] &&\n\t\tUtils.checkFunction(obj['writeFields']) &&\n\t\tUtils.checkFunction(obj['readFields']);\n}\n\nUtils.checkNull = function(obj) {\n\treturn !Utils.isNotNull(obj);\n}\n\n/**\n * Utils args to array\n *\n * @param  {Object}  args arguments\n * @return {Array}   array\n * @api public\n */\nUtils.to_array = function(args) {\n\tvar len = args.length;\n\tvar arr = new Array(len);\n\n\tfor (var i = 0; i < len; i++) {\n\t\tarr[i] = args[i];\n\t}\n\n\treturn arr;\n}\n\n/**\n * Utils check is not null\n *\n * @param  {Object}   value\n * @return {Boolean}  true|false\n * @api public\n */\nUtils.isNotNull = function(value) {\n\tif (value !== null && typeof value !== 'undefined')\n\t\treturn true;\n\treturn false;\n}\n\nUtils.getType = function(object) {\n\tif (object == null || typeof object === 'undefined') {\n\t\treturn Utils.typeMap['null'];\n\t}\n\n\tif (Buffer.isBuffer(object)) {\n\t\treturn Utils.typeMap['buffer'];\n\t}\n\n\tif (Utils.checkArray(object)) {\n\t\treturn Utils.typeMap['array'];\n\t}\n\n\tif (Utils.checkString(object)) {\n\t\treturn Utils.typeMap['string'];\n\t}\n\n\tif (Utils.checkObject(object)) {\n\t\tif (Utils.checkBean(object)) {\n\t\t\treturn Utils.typeMap['bean'];\n\t\t}\n\n\t\treturn Utils.typeMap['object'];\n\t}\n\n\tif (Utils.checkBoolean(object)) {\n\t\treturn Utils.typeMap['boolean'];\n\t}\n\n\tif (Utils.checkNumber(object)) {\n\t\tif (Utils.checkFloat(object)) {\n\t\t\treturn Utils.typeMap['float'];\n\t\t}\n\n\t\tif (isNaN(object)) {\n\t\t\treturn Utils.typeMap['null'];\n\t\t}\n\n\t\treturn Utils.typeMap['number'];\n\t}\n}\n\nvar typeArray = ['', 'null', 'buffer', 'array', 'string', 'object', 'bean', 'boolean', 'float', 'number'];\nvar typeMap = {};\nfor (var i = 1; i <= typeArray.length; i++) {\n\ttypeMap[typeArray[i]] = i;\n}\n\nUtils.typeArray = typeArray;\n\nUtils.typeMap = typeMap;\n\nUtils.getBearcat = function() {\n\treturn require('bearcat');\n}\n\nUtils.genServicesMap = function(services) {\n\tvar nMap = {}; // namespace\n\tvar sMap = {}; // service\n\tvar mMap = {}; // method\n\tvar nList = [];\n\tvar sList = [];\n\tvar mList = [];\n\n\tvar nIndex = 0;\n\tvar sIndex = 0;\n\tvar mIndex = 0;\n\n\tfor (var namespace in services) {\n\t\tnList.push(namespace);\n\t\tnMap[namespace] = nIndex++;\n\t\tvar s = services[namespace];\n\n\t\tfor (var service in s) {\n\t\t\tsList.push(service);\n\t\t\tsMap[service] = sIndex++;\n\t\t\tvar m = s[service];\n\n\t\t\tfor (var method in m) {\n\t\t\t\tvar func = m[method];\n\t\t\t\tif (Utils.checkFunction(func)) {\n\t\t\t\t\tmList.push(method);\n\t\t\t\t\tmMap[method] = mIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [nMap, sMap, mMap, nList, sList, mList];\n}\n\nmodule.exports = Utils;","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/rpc-client/mailstation.js":"var logger = require('pomelo-logger').getLogger('pomelo-rpc', 'MailStation');\nvar EventEmitter = require('events').EventEmitter;\nvar blackhole = require('./mailboxes/blackhole');\nvar defaultMailboxFactory = require('./mailbox');\nvar constants = require('../util/constants');\nvar utils = require('../util/utils');\nvar util = require('util');\n\nvar STATE_INITED = 1; // station has inited\nvar STATE_STARTED = 2; // station has started\nvar STATE_CLOSED = 3; // station has closed\n\n/**\n * Mail station constructor.\n *\n * @param {Object} opts construct parameters\n */\nvar MailStation = function(opts) {\n  EventEmitter.call(this);\n  this.opts = opts;\n  this.servers = {}; // remote server info map, key: server id, value: info\n  this.serversMap = {}; // remote server info map, key: serverType, value: servers array\n  this.onlines = {}; // remote server online map, key: server id, value: 0/offline 1/online\n  this.mailboxFactory = opts.mailboxFactory || defaultMailboxFactory;\n\n  // filters\n  this.befores = [];\n  this.afters = [];\n\n  // pending request queues\n  this.pendings = {};\n  this.pendingSize = opts.pendingSize || constants.DEFAULT_PARAM.DEFAULT_PENDING_SIZE;\n\n  // connecting remote server mailbox map\n  this.connecting = {};\n\n  // working mailbox map\n  this.mailboxes = {};\n\n  this.state = STATE_INITED;\n};\n\nutil.inherits(MailStation, EventEmitter);\n\nvar pro = MailStation.prototype;\n\n/**\n * Init and start station. Connect all mailbox to remote servers.\n *\n * @param  {Function} cb(err) callback function\n * @return {Void}\n */\npro.start = function(cb) {\n  if (this.state > STATE_INITED) {\n    cb(new Error('station has started.'));\n    return;\n  }\n\n  var self = this;\n  process.nextTick(function() {\n    self.state = STATE_STARTED;\n    cb();\n  });\n};\n\n/**\n * Stop station and all its mailboxes\n *\n * @param  {Boolean} force whether stop station forcely\n * @return {Void}\n */\npro.stop = function(force) {\n  if (this.state !== STATE_STARTED) {\n    logger.warn('[pomelo-rpc] client is not running now.');\n    return;\n  }\n  this.state = STATE_CLOSED;\n\n  var self = this;\n\n  function closeAll() {\n    for (var id in self.mailboxes) {\n      self.mailboxes[id].close();\n    }\n  }\n  if (force) {\n    closeAll();\n  } else {\n    setTimeout(closeAll, constants.DEFAULT_PARAM.GRACE_TIMEOUT);\n  }\n};\n\n/**\n * Add a new server info into the mail station and clear\n * the blackhole associated with the server id if any before.\n *\n * @param {Object} serverInfo server info such as {id, host, port}\n */\npro.addServer = function(serverInfo) {\n  if (!serverInfo || !serverInfo.id) {\n    return;\n  }\n\n  var id = serverInfo.id;\n  var type = serverInfo.serverType;\n  this.servers[id] = serverInfo;\n  this.onlines[id] = 1;\n\n  if (!this.serversMap[type]) {\n    this.serversMap[type] = [];\n  }\n\n  if (this.serversMap[type].indexOf(id) < 0) {\n    this.serversMap[type].push(id);\n  }\n  this.emit('addServer', id);\n};\n\n/**\n * Batch version for add new server info.\n *\n * @param {Array} serverInfos server info list\n */\npro.addServers = function(serverInfos) {\n  if (!serverInfos || !serverInfos.length) {\n    return;\n  }\n\n  for (var i = 0, l = serverInfos.length; i < l; i++) {\n    this.addServer(serverInfos[i]);\n  }\n};\n\n/**\n * Remove a server info from the mail station and remove\n * the mailbox instance associated with the server id.\n *\n * @param  {String|Number} id server id\n */\npro.removeServer = function(id) {\n  this.onlines[id] = 0;\n  var mailbox = this.mailboxes[id];\n  if (mailbox) {\n    mailbox.close();\n    delete this.mailboxes[id];\n  }\n  this.emit('removeServer', id);\n};\n\n/**\n * Batch version for remove remote servers.\n *\n * @param  {Array} ids server id list\n */\npro.removeServers = function(ids) {\n  if (!ids || !ids.length) {\n    return;\n  }\n\n  for (var i = 0, l = ids.length; i < l; i++) {\n    this.removeServer(ids[i]);\n  }\n};\n\n/**\n * Clear station infomation.\n *\n */\npro.clearStation = function() {\n  this.onlines = {};\n  this.serversMap = {};\n}\n\n/**\n * Replace remote servers info.\n *\n * @param {Array} serverInfos server info list\n */\npro.replaceServers = function(serverInfos) {\n  this.clearStation();\n  if (!serverInfos || !serverInfos.length) {\n    return;\n  }\n\n  for (var i = 0, l = serverInfos.length; i < l; i++) {\n    var id = serverInfos[i].id;\n    var type = serverInfos[i].serverType;\n    this.onlines[id] = 1;\n    if (!this.serversMap[type]) {\n      this.serversMap[type] = [];\n    }\n    this.servers[id] = serverInfos[i];\n    if (this.serversMap[type].indexOf(id) < 0) {\n      this.serversMap[type].push(id);\n    }\n  }\n};\n\n/**\n * Dispatch rpc message to the mailbox\n *\n * @param  {Object}   tracer   rpc debug tracer\n * @param  {String}   serverId remote server id\n * @param  {Object}   msg      rpc invoke message\n * @param  {Object}   opts     rpc invoke option args\n * @param  {Function} cb       callback function\n * @return {Void}\n */\npro.dispatch = function(tracer, serverId, msg, opts, cb) {\n  tracer && tracer.info('client', __filename, 'dispatch', 'dispatch rpc message to the mailbox');\n  tracer && (tracer.cb = cb);\n  if (this.state !== STATE_STARTED) {\n    tracer && tracer.error('client', __filename, 'dispatch', 'client is not running now');\n    logger.error('[pomelo-rpc] client is not running now.');\n    this.emit('error', constants.RPC_ERROR.SERVER_NOT_STARTED, tracer, serverId, msg, opts);\n    return;\n  }\n\n  var self = this;\n  var mailbox = this.mailboxes[serverId];\n  if (!mailbox) {\n    tracer && tracer.debug('client', __filename, 'dispatch', 'mailbox is not exist');\n    // try to connect remote server if mailbox instance not exist yet\n    if (!lazyConnect(tracer, this, serverId, this.mailboxFactory, cb)) {\n      tracer && tracer.error('client', __filename, 'dispatch', 'fail to find remote server:' + serverId);\n      logger.error('[pomelo-rpc] fail to find remote server:' + serverId);\n      self.emit('error', constants.RPC_ERROR.NO_TRAGET_SERVER, tracer, serverId, msg, opts);\n    }\n    // push request to the pending queue\n    addToPending(tracer, this, serverId, arguments);\n    return;\n  }\n\n  if (this.connecting[serverId]) {\n    tracer && tracer.debug('client', __filename, 'dispatch', 'request add to connecting');\n    // if the mailbox is connecting to remote server\n    addToPending(tracer, this, serverId, arguments);\n    return;\n  }\n\n  var send = function(tracer, err, serverId, msg, opts) {\n    tracer && tracer.info('client', __filename, 'send', 'get corresponding mailbox and try to send message');\n    var mailbox = self.mailboxes[serverId];\n    if (err) {\n      return errorHandler(tracer, self, err, serverId, msg, opts, true, cb);\n    }\n    if (!mailbox) {\n      tracer && tracer.error('client', __filename, 'send', 'can not find mailbox with id:' + serverId);\n      logger.error('[pomelo-rpc] could not find mailbox with id:' + serverId);\n      self.emit('error', constants.RPC_ERROR.FAIL_FIND_MAILBOX, tracer, serverId, msg, opts);\n      return;\n    }\n    mailbox.send(tracer, msg, opts, function(tracer_send, send_err, args) {\n      // var tracer_send = arguments[0];\n      // var send_err = arguments[1];\n      if (send_err) {\n        logger.error('[pomelo-rpc] fail to send message %s', send_err.stack || send_err.message);\n        self.emit('error', constants.RPC_ERROR.FAIL_SEND_MESSAGE, tracer, serverId, msg, opts);\n        cb && cb(send_err);\n        // utils.applyCallback(cb, send_err);\n        return;\n      }\n      // var args = arguments[2];\n      doFilter(tracer_send, null, serverId, msg, opts, self.afters, 0, 'after', function(tracer, err, serverId, msg, opts) {\n        if (err) {\n          errorHandler(tracer, self, err, serverId, msg, opts, false, cb);\n        }\n        utils.applyCallback(cb, args);\n      });\n    });\n  };\n\n  doFilter(tracer, null, serverId, msg, opts, this.befores, 0, 'before', send);\n};\n\n/**\n * Add a before filter\n *\n * @param  {[type]} filter [description]\n * @return {[type]}        [description]\n */\npro.before = function(filter) {\n  if (Array.isArray(filter)) {\n    this.befores = this.befores.concat(filter);\n    return;\n  }\n  this.befores.push(filter);\n};\n\n/**\n * Add after filter\n *\n * @param  {[type]} filter [description]\n * @return {[type]}        [description]\n */\npro.after = function(filter) {\n  if (Array.isArray(filter)) {\n    this.afters = this.afters.concat(filter);\n    return;\n  }\n  this.afters.push(filter);\n};\n\n/**\n * Add before and after filter\n *\n * @param  {[type]} filter [description]\n * @return {[type]}        [description]\n */\npro.filter = function(filter) {\n  this.befores.push(filter);\n  this.afters.push(filter);\n};\n\n/**\n * Try to connect to remote server\n *\n * @param  {Object}   tracer   rpc debug tracer\n * @return {String}   serverId remote server id\n * @param  {Function}   cb     callback function\n */\npro.connect = function(tracer, serverId, cb) {\n  var self = this;\n  var mailbox = self.mailboxes[serverId];\n  mailbox.connect(tracer, function(err) {\n    if (!!err) {\n      tracer && tracer.error('client', __filename, 'lazyConnect', 'fail to connect to remote server: ' + serverId);\n      logger.error('[pomelo-rpc] mailbox fail to connect to remote server: ' + serverId);\n      if (!!self.mailboxes[serverId]) {\n        delete self.mailboxes[serverId];\n      }\n      self.emit('error', constants.RPC_ERROR.FAIL_CONNECT_SERVER, tracer, serverId, null, self.opts);\n      return;\n    }\n    mailbox.on('close', function(id) {\n      var mbox = self.mailboxes[id];\n      if (!!mbox) {\n        mbox.close();\n        delete self.mailboxes[id];\n      }\n      self.emit('close', id);\n    });\n    delete self.connecting[serverId];\n    flushPending(tracer, self, serverId);\n  });\n};\n\n/**\n * Do before or after filter\n */\nvar doFilter = function(tracer, err, serverId, msg, opts, filters, index, operate, cb) {\n  if (index < filters.length) {\n    tracer && tracer.info('client', __filename, 'doFilter', 'do ' + operate + ' filter ' + filters[index].name);\n  }\n  if (index >= filters.length || !!err) {\n    cb(tracer, err, serverId, msg, opts);\n    return;\n  }\n  var self = this;\n  var filter = filters[index];\n  if (typeof filter === 'function') {\n    filter(serverId, msg, opts, function(target, message, options) {\n      index++;\n      //compatible for pomelo filter next(err) method\n      if (utils.getObjectClass(target) === 'Error') {\n        doFilter(tracer, target, serverId, msg, opts, filters, index, operate, cb);\n      } else {\n        doFilter(tracer, null, target || serverId, message || msg, options || opts, filters, index, operate, cb);\n      }\n    });\n    return;\n  }\n  if (typeof filter[operate] === 'function') {\n    filter[operate](serverId, msg, opts, function(target, message, options) {\n      index++;\n      if (utils.getObjectClass(target) === 'Error') {\n        doFilter(tracer, target, serverId, msg, opts, filters, index, operate, cb);\n      } else {\n        doFilter(tracer, null, target || serverId, message || msg, options || opts, filters, index, operate, cb);\n      }\n    });\n    return;\n  }\n  index++;\n  doFilter(tracer, err, serverId, msg, opts, filters, index, operate, cb);\n};\n\nvar lazyConnect = function(tracer, station, serverId, factory, cb) {\n  tracer && tracer.info('client', __filename, 'lazyConnect', 'create mailbox and try to connect to remote server');\n  var server = station.servers[serverId];\n  var online = station.onlines[serverId];\n  if (!server) {\n    logger.error('[pomelo-rpc] unknown server: %s', serverId);\n    return false;\n  }\n  if (!online || online !== 1) {\n    logger.error('[pomelo-rpc] server is not online: %s', serverId);\n    return false;\n  }\n  var mailbox = factory.create(server, station.opts);\n  station.connecting[serverId] = true;\n  station.mailboxes[serverId] = mailbox;\n  station.connect(tracer, serverId, cb);\n  return true;\n};\n\nvar addToPending = function(tracer, station, serverId, args) {\n  tracer && tracer.info('client', __filename, 'addToPending', 'add pending requests to pending queue');\n  var pending = station.pendings[serverId];\n  if (!pending) {\n    pending = station.pendings[serverId] = [];\n  }\n  if (pending.length > station.pendingSize) {\n    tracer && tracer.debug('client', __filename, 'addToPending', 'station pending too much for: ' + serverId);\n    logger.warn('[pomelo-rpc] station pending too much for: %s', serverId);\n    return;\n  }\n  pending.push(args);\n};\n\nvar flushPending = function(tracer, station, serverId, cb) {\n  tracer && tracer.info('client', __filename, 'flushPending', 'flush pending requests to dispatch method');\n  var pending = station.pendings[serverId];\n  var mailbox = station.mailboxes[serverId];\n  if (!pending || !pending.length) {\n    return;\n  }\n  if (!mailbox) {\n    tracer && tracer.error('client', __filename, 'flushPending', 'fail to flush pending messages for empty mailbox: ' + serverId);\n    logger.error('[pomelo-rpc] fail to flush pending messages for empty mailbox: ' + serverId);\n  }\n  for (var i = 0, l = pending.length; i < l; i++) {\n    station.dispatch.apply(station, pending[i]);\n  }\n  delete station.pendings[serverId];\n};\n\nvar errorHandler = function(tracer, station, err, serverId, msg, opts, flag, cb) {\n  if (!!station.handleError) {\n    station.handleError(err, serverId, msg, opts);\n  } else {\n    logger.error('[pomelo-rpc] rpc filter error with serverId: %s, err: %j', serverId, err.stack);\n    station.emit('error', constants.RPC_ERROR.FILTER_ERROR, tracer, serverId, msg, opts);\n  }\n};\n\n/**\n * Mail station factory function.\n *\n * @param  {Object} opts construct paramters\n *           opts.servers {Object} global server info map. {serverType: [{id, host, port, ...}, ...]}\n *           opts.mailboxFactory {Function} mailbox factory function\n * @return {Object}      mail station instance\n */\nmodule.exports.create = function(opts) {\n  return new MailStation(opts || {});\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/rpc-client/mailboxes/blackhole.js":"var logger = require('pomelo-logger').getLogger('pomelo-rpc', 'blackhole');\nvar EventEmitter = require('events').EventEmitter;\nvar utils = require('../../util/utils');\n\nvar exp = module.exports = new EventEmitter();\n\nexp.connect = function(tracer, cb) {\n\ttracer && tracer.info('client', __filename, 'connect', 'connect to blackhole');\n\tprocess.nextTick(function() {\n\t\tcb(new Error('fail to connect to remote server and switch to blackhole.'));\n\t});\n};\n\nexp.close = function(cb) {};\n\nexp.send = function(tracer, msg, opts, cb) {\n\ttracer && tracer.info('client', __filename, 'send', 'send rpc msg to blackhole');\n\tlogger.info('message into blackhole: %j', msg);\n\tprocess.nextTick(function() {\n\t\tcb(tracer, new Error('message was forward to blackhole.'));\n\t});\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/rpc-client/mailbox.js":"/**\n * Default mailbox factory\n */\nvar Mailbox = require('./mailboxes/mqtt-mailbox');\n// var Ws2Mailbox = require('./mailboxes/ws2-mailbox');\n// var WsMailbox = require('./mailboxes/ws-mailbox');\n\n/**\n * default mailbox factory\n *\n * @param {Object} serverInfo single server instance info, {id, host, port, ...}\n * @param {Object} opts construct parameters\n * @return {Object} mailbox instancef\n */\nmodule.exports.create = function(serverInfo, opts) {\n\t// var mailbox = opts.mailbox || 'mqtt';\n\t// var Mailbox = null;\n\t// if (mailbox == 'ws') {\n\t// \tMailbox = WsMailbox;\n\t// } else if (mailbox == 'ws2') {\n\t// \tMailbox = Ws2Mailbox;\n\t// } else if (mailbox == 'mqtt') {\n\t// \tMailbox = MqttMailbox;\n\t// }\n\treturn Mailbox.create(serverInfo, opts);\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/rpc-client/mailboxes/mqtt-mailbox.js":"var logger = require('pomelo-logger').getLogger('pomelo-rpc', 'mqtt-mailbox');\nvar EventEmitter = require('events').EventEmitter;\nvar constants = require('../../util/constants');\nvar Tracer = require('../../util/tracer');\nvar MqttCon = require('mqtt-connection');\nvar utils = require('../../util/utils');\nvar util = require('util');\nvar net = require('net');\n\nvar CONNECT_TIMEOUT = 2000;\n\nvar MailBox = function(server, opts) {\n  EventEmitter.call(this);\n  this.curId = 0;\n  this.id = server.id;\n  this.host = server.host;\n  this.port = server.port;\n  this.requests = {};\n  this.timeout = {};\n  this.queue = [];\n  this.bufferMsg = opts.bufferMsg;\n  this.keepalive = opts.keepalive || constants.DEFAULT_PARAM.KEEPALIVE;\n  this.interval = opts.interval || constants.DEFAULT_PARAM.INTERVAL;\n  this.timeoutValue = opts.timeout || constants.DEFAULT_PARAM.CALLBACK_TIMEOUT;\n  this.keepaliveTimer = null;\n  this.lastPing = -1;\n  this.lastPong = -1;\n  this.connected = false;\n  this.closed = false;\n  this.opts = opts;\n  this.serverId = opts.context.serverId;\n};\n\nutil.inherits(MailBox, EventEmitter);\n\nMailBox.prototype.connect = function(tracer, cb) {\n  tracer && tracer.info('client', __filename, 'connect', 'mqtt-mailbox try to connect');\n  if (this.connected) {\n    tracer && tracer.error('client', __filename, 'connect', 'mailbox has already connected');\n    return cb(new Error('mailbox has already connected.'));\n  }\n\n  var self = this;\n\n  var stream = net.createConnection(this.port, this.host);\n  this.socket = MqttCon(stream);\n\n  var connectTimeout = setTimeout(function() {\n    logger.error('rpc client %s connect to remote server %s timeout', self.serverId, self.id);\n    self.emit('close', self.id);\n  }, CONNECT_TIMEOUT);\n\n  this.socket.connect({\n    clientId: 'MQTT_RPC_' + Date.now()\n  }, function() {\n    if (self.connected) {\n      return;\n    }\n\n    clearTimeout(connectTimeout);\n    self.connected = true;\n    if (self.bufferMsg) {\n      self._interval = setInterval(function() {\n        flush(self);\n      }, self.interval);\n    }\n\n    self.setupKeepAlive();\n    cb();\n  });\n\n  this.socket.on('publish', function(pkg) {\n    pkg = pkg.payload.toString();\n    try {\n      pkg = JSON.parse(pkg);\n      if (pkg instanceof Array) {\n        processMsgs(self, pkg);\n      } else {\n        processMsg(self, pkg);\n      }\n    } catch (err) {\n      logger.error('rpc client %s process remote server %s message with error: %s', self.serverId, self.id, err.stack);\n    }\n  });\n\n  this.socket.on('error', function(err) {\n    logger.error('rpc socket %s is error, remote server %s host: %s, port: %s', self.serverId, self.id, self.host, self.port);\n    self.emit('close', self.id);\n  });\n\n  this.socket.on('pingresp', function() {\n    self.lastPong = Date.now();\n  });\n\n  this.socket.on('disconnect', function(reason) {\n    logger.error('rpc socket %s is disconnect from remote server %s, reason: %s', self.serverId, self.id, reason);\n    var reqs = self.requests;\n    for (var id in reqs) {\n      var ReqCb = reqs[id];\n      ReqCb(tracer, new Error(self.serverId + ' disconnect with remote server ' + self.id));\n    }\n    self.emit('close', self.id);\n  });\n};\n\n/**\n * close mailbox\n */\nMailBox.prototype.close = function() {\n  if (this.closed) {\n    return;\n  }\n  this.closed = true;\n  this.connected = false;\n  if (this._interval) {\n    clearInterval(this._interval);\n    this._interval = null;\n  }\n  this.socket.destroy();\n};\n\n/**\n * send message to remote server\n *\n * @param msg {service:\"\", method:\"\", args:[]}\n * @param opts {} attach info to send method\n * @param cb declaration decided by remote interface\n */\nMailBox.prototype.send = function(tracer, msg, opts, cb) {\n  tracer && tracer.info('client', __filename, 'send', 'mqtt-mailbox try to send');\n  if (!this.connected) {\n    tracer && tracer.error('client', __filename, 'send', 'mqtt-mailbox not init');\n    cb(tracer, new Error(this.serverId + ' mqtt-mailbox is not init ' + this.id));\n    return;\n  }\n\n  if (this.closed) {\n    tracer && tracer.error('client', __filename, 'send', 'mailbox has already closed');\n    cb(tracer, new Error(this.serverId + ' mqtt-mailbox has already closed ' + this.id));\n    return;\n  }\n\n  var id = this.curId++;\n  this.requests[id] = cb;\n  setCbTimeout(this, id, tracer, cb);\n\n  var pkg;\n  if (tracer && tracer.isEnabled) {\n    pkg = {\n      traceId: tracer.id,\n      seqId: tracer.seq,\n      source: tracer.source,\n      remote: tracer.remote,\n      id: id,\n      msg: msg\n    };\n  } else {\n    pkg = {\n      id: id,\n      msg: msg\n    };\n  }\n  if (this.bufferMsg) {\n    enqueue(this, pkg);\n  } else {\n    doSend(this.socket, pkg);\n  }\n};\n\nMailBox.prototype.setupKeepAlive = function() {\n  var self = this;\n  this.keepaliveTimer = setInterval(function() {\n    self.checkKeepAlive();\n  }, this.keepalive);\n}\n\nMailBox.prototype.checkKeepAlive = function() {\n  if (this.closed) {\n    return;\n  }\n\n  // console.log('checkKeepAlive lastPing %d lastPong %d ~~~', this.lastPing, this.lastPong);\n  var now = Date.now();\n  var KEEP_ALIVE_TIMEOUT = this.keepalive * 2;\n  if (this.lastPing > 0) {\n    if (this.lastPong < this.lastPing) {\n      if (now - this.lastPing > KEEP_ALIVE_TIMEOUT) {\n        logger.error('mqtt rpc client %s checkKeepAlive timeout from remote server %s for %d lastPing: %s lastPong: %s', this.serverId, this.id, KEEP_ALIVE_TIMEOUT, this.lastPing, this.lastPong);\n        this.emit('close', this.id);\n        this.lastPing = -1;\n        // this.close();\n      }\n    } else {\n      this.socket.pingreq();\n      this.lastPing = Date.now();\n    }\n  } else {\n    this.socket.pingreq();\n    this.lastPing = Date.now();\n  }\n}\n\nvar enqueue = function(mailbox, msg) {\n  mailbox.queue.push(msg);\n};\n\nvar flush = function(mailbox) {\n  if (mailbox.closed || !mailbox.queue.length) {\n    return;\n  }\n  doSend(mailbox.socket, mailbox.queue);\n  mailbox.queue = [];\n};\n\nvar doSend = function(socket, msg) {\n  socket.publish({\n    topic: 'rpc',\n    payload: JSON.stringify(msg)\n  });\n}\n\nvar processMsgs = function(mailbox, pkgs) {\n  for (var i = 0, l = pkgs.length; i < l; i++) {\n    processMsg(mailbox, pkgs[i]);\n  }\n};\n\nvar processMsg = function(mailbox, pkg) {\n  var pkgId = pkg.id;\n  clearCbTimeout(mailbox, pkgId);\n  var cb = mailbox.requests[pkgId];\n  if (!cb) {\n    return;\n  }\n\n  delete mailbox.requests[pkgId];\n  var rpcDebugLog = mailbox.opts.rpcDebugLog;\n  var tracer = null;\n  var sendErr = null;\n  if (rpcDebugLog) {\n    tracer = new Tracer(mailbox.opts.rpcLogger, mailbox.opts.rpcDebugLog, mailbox.opts.clientId, pkg.source, pkg.resp, pkg.traceId, pkg.seqId);\n  }\n  var pkgResp = pkg.resp;\n\n  cb(tracer, sendErr, pkgResp);\n};\n\nvar setCbTimeout = function(mailbox, id, tracer, cb) {\n  var timer = setTimeout(function() {\n    // logger.warn('rpc request is timeout, id: %s, host: %s, port: %s', id, mailbox.host, mailbox.port);\n    clearCbTimeout(mailbox, id);\n    if (mailbox.requests[id]) {\n      delete mailbox.requests[id];\n    }\n    var eMsg = util.format('rpc %s callback timeout %d, remote server %s host: %s, port: %s', mailbox.serverId, mailbox.timeoutValue, id, mailbox.host, mailbox.port);\n    logger.error(eMsg);\n    cb(tracer, new Error(eMsg));\n  }, mailbox.timeoutValue);\n  mailbox.timeout[id] = timer;\n};\n\nvar clearCbTimeout = function(mailbox, id) {\n  if (!mailbox.timeout[id]) {\n    logger.warn('timer is not exsits, serverId: %s remote: %s, host: %s, port: %s', mailbox.serverId, id, mailbox.host, mailbox.port);\n    return;\n  }\n  clearTimeout(mailbox.timeout[id]);\n  delete mailbox.timeout[id];\n};\n\n/**\n * Factory method to create mailbox\n *\n * @param {Object} server remote server info {id:\"\", host:\"\", port:\"\"}\n * @param {Object} opts construct parameters\n *                      opts.bufferMsg {Boolean} msg should be buffered or send immediately.\n *                      opts.interval {Boolean} msg queue flush interval if bufferMsg is true. default is 50 ms\n */\nmodule.exports.create = function(server, opts) {\n  return new MailBox(server, opts || {});\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/util/tracer.js":"var uuid = require('node-uuid');\n\nvar Tracer = function(logger, enabledRpcLog, source, remote, msg, id, seq) {\n  this.isEnabled = enabledRpcLog;\n  if (!enabledRpcLog) {\n    return;\n  }\n  this.logger = logger;\n  this.source = source;\n  this.remote = remote;\n  this.id = id || uuid.v1();\n  this.seq = seq || 1;\n  this.msg = msg;\n};\n\nmodule.exports = Tracer;\n\nTracer.prototype.getLogger = function(role, module, method, des) {\n  return {\n    traceId: this.id,\n    seq: this.seq++,\n    role: role,\n    source: this.source,\n    remote: this.remote,\n    module: getModule(module),\n    method: method,\n    args: this.msg,\n    timestamp: Date.now(),\n    description: des\n  };\n};\n\nTracer.prototype.info = function(role, module, method, des) {\n  if (this.isEnabled) {\n    this.logger.info(JSON.stringify(this.getLogger(role, module, method, des)));\n  }\n  return;\n};\n\nTracer.prototype.debug = function(role, module, method, des) {\n  if (this.isEnabled) {\n    this.logger.debug(JSON.stringify(this.getLogger(role, module, method, des)));\n  }\n  return;\n};\n\nTracer.prototype.error = function(role, module, method, des) {\n  if (this.isEnabled) {\n    this.logger.error(JSON.stringify(this.getLogger(role, module, method, des)));\n  }\n  return;\n};\n\nvar getModule = function(module) {\n  var rs = '';\n  var strs = module.split('/');\n  var lines = strs.slice(-3);\n  for (var i = 0; i < lines.length; i++) {\n    rs += '/' + lines[i];\n  }\n  return rs;\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/util/proxy.js":"var logger = require('pomelo-logger').getLogger('pomelo-rpc', 'rpc-proxy');\nvar exp = module.exports;\n\n/**\n * Create proxy.\n *\n * @param  {Object} opts construct parameters\n *           opts.origin {Object} delegated object\n *           opts.proxyCB {Function} proxy invoke callback\n *           opts.service {String} deletgated service name\n *           opts.attach {Object} attach parameter pass to proxyCB\n * @return {Object}      proxy instance\n */\nexp.create = function(opts) {\n  if (!opts || !opts.origin) {\n    logger.warn('opts and opts.origin should not be empty.');\n    return null;\n  }\n\n  if (!opts.proxyCB || typeof opts.proxyCB !== 'function') {\n    logger.warn('opts.proxyCB is not a function, return the origin module directly.');\n    return opts.origin;\n  }\n\n  return genObjectProxy(opts.service, opts.origin, opts.attach, opts.proxyCB);\n};\n\nvar genObjectProxy = function(serviceName, origin, attach, proxyCB) {\n  //generate proxy for function field\n  var res = {};\n  for (var field in origin) {\n    if (typeof origin[field] === 'function') {\n      res[field] = genFunctionProxy(serviceName, field, origin, attach, proxyCB);\n    }\n  }\n\n  return res;\n};\n\n/**\n * Generate prxoy for function type field\n *\n * @param namespace {String} current namespace\n * @param serverType {String} server type string\n * @param serviceName {String} delegated service name\n * @param methodName {String} delegated method name\n * @param origin {Object} origin object\n * @param proxyCB {Functoin} proxy callback function\n * @returns function proxy\n */\nvar genFunctionProxy = function(serviceName, methodName, origin, attach, proxyCB) {\n  return (function() {\n    var proxy = function() {\n      // var args = arguments;\n      var len = arguments.length;\n      var args = new Array(len);\n      for (var i = 0; i < len; i++) {\n        args[i] = arguments[i];\n      }\n      // var args = Array.prototype.slice.call(arguments, 0);\n      proxyCB(serviceName, methodName, args, attach);\n    };\n\n    proxy.toServer = function() {\n      // var args = arguments;\n      var len = arguments.length;\n      var args = new Array(len);\n      for (var i = 0; i < len; i++) {\n        args[i] = arguments[i];\n      }\n      proxyCB(serviceName, methodName, args, attach, true);\n    };\n\n    return proxy;\n  })();\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/rpc-client/router.js":"var ConsistentHash = require('../util/consistentHash');\nvar utils = require('../util/utils');\nvar crc = require('crc');\n\n/**\n * Calculate route info and return an appropriate server id.\n *\n * @param session {Object} session object for current rpc request\n * @param msg {Object} rpc message. {serverType, service, method, args, opts}\n * @param context {Object} context of client\n * @param cb(err, serverId)\n */\nvar defRoute = function(session, msg, context, cb) {\n  var list = context.getServersByType(msg.serverType);\n  if (!list || !list.length) {\n    cb(new Error('can not find server info for type:' + msg.serverType));\n    return;\n  }\n  var uid = session ? (session.uid || '') : '';\n  var index = Math.abs(crc.crc32(uid.toString())) % list.length;\n  cb(null, list[index].id);\n};\n\n/**\n * Random algorithm for calculating server id.\n *\n * @param client {Object} rpc client.\n * @param serverType {String} rpc target serverType.\n * @param msg {Object} rpc message.\n * @param cb {Function} cb(err, serverId).\n */\nvar rdRoute = function(client, serverType, msg, cb) {\n  var servers = client._station.serversMap[serverType];\n  if (!servers || !servers.length) {\n    cb(new Error('rpc servers not exist with serverType: ' + serverType));\n    return;\n  }\n  var index = Math.floor(Math.random() * servers.length);\n  cb(null, servers[index]);\n};\n\n/**\n * Round-Robin algorithm for calculating server id.\n *\n * @param client {Object} rpc client.\n * @param serverType {String} rpc target serverType.\n * @param msg {Object} rpc message.\n * @param cb {Function} cb(err, serverId).\n */\nvar rrRoute = function(client, serverType, msg, cb) {\n  var servers = client._station.serversMap[serverType];\n  if (!servers || !servers.length) {\n    cb(new Error('rpc servers not exist with serverType: ' + serverType));\n    return;\n  }\n  var index;\n  if (!client.rrParam) {\n    client.rrParam = {};\n  }\n  if (!!client.rrParam[serverType]) {\n    index = client.rrParam[serverType];\n  } else {\n    index = 0;\n  }\n  cb(null, servers[index % servers.length]);\n  if (index++ === Number.MAX_VALUE) {\n    index = 0;\n  }\n  client.rrParam[serverType] = index;\n};\n\n/**\n * Weight-Round-Robin algorithm for calculating server id.\n *\n * @param client {Object} rpc client.\n * @param serverType {String} rpc target serverType.\n * @param msg {Object} rpc message.\n * @param cb {Function} cb(err, serverId).\n */\nvar wrrRoute = function(client, serverType, msg, cb) {\n  var servers = client._station.serversMap[serverType];\n  if (!servers || !servers.length) {\n    cb(new Error('rpc servers not exist with serverType: ' + serverType));\n    return;\n  }\n  var index, weight;\n  if (!client.wrrParam) {\n    client.wrrParam = {};\n  }\n  if (!!client.wrrParam[serverType]) {\n    index = client.wrrParam[serverType].index;\n    weight = client.wrrParam[serverType].weight;\n  } else {\n    index = -1;\n    weight = 0;\n  }\n  var getMaxWeight = function() {\n    var maxWeight = -1;\n    for (var i = 0; i < servers.length; i++) {\n      var server = client._station.servers[servers[i]];\n      if (!!server.weight && server.weight > maxWeight) {\n        maxWeight = server.weight;\n      }\n    }\n    return maxWeight;\n  };\n  while (true) {\n    index = (index + 1) % servers.length;\n    if (index === 0) {\n      weight = weight - 1;\n      if (weight <= 0) {\n        weight = getMaxWeight();\n        if (weight <= 0) {\n          cb(new Error('rpc wrr route get invalid weight.'));\n          return;\n        }\n      }\n    }\n    var server = client._station.servers[servers[index]];\n    if (server.weight >= weight) {\n      client.wrrParam[serverType] = {\n        index: index,\n        weight: weight\n      };\n      cb(null, server.id);\n      return;\n    }\n  }\n};\n\n/**\n * Least-Active algorithm for calculating server id.\n *\n * @param client {Object} rpc client.\n * @param serverType {String} rpc target serverType.\n * @param msg {Object} rpc message.\n * @param cb {Function} cb(err, serverId).\n */\nvar laRoute = function(client, serverType, msg, cb) {\n  var servers = client._station.serversMap[serverType];\n  if (!servers || !servers.length) {\n    return cb(new Error('rpc servers not exist with serverType: ' + serverType));\n  }\n  var actives = [];\n  if (!client.laParam) {\n    client.laParam = {};\n  }\n  if (!!client.laParam[serverType]) {\n    for (var j = 0; j < servers.length; j++) {\n      var count = client.laParam[serverType][servers[j]];\n      if (!count) {\n        client.laParam[servers[j]] = count = 0;\n      }\n      actives.push(count);\n    }\n  } else {\n    client.laParam[serverType] = {};\n    for (var i = 0; i < servers.length; i++) {\n      client.laParam[serverType][servers[i]] = 0;\n      actives.push(0);\n    }\n  }\n  var rs = [];\n  var minInvoke = Number.MAX_VALUE;\n  for (var k = 0; k < actives.length; k++) {\n    if (actives[k] < minInvoke) {\n      minInvoke = actives[k];\n      rs = [];\n      rs.push(servers[k]);\n    } else if (actives[k] === minInvoke) {\n      rs.push(servers[k]);\n    }\n  }\n  var index = Math.floor(Math.random() * rs.length);\n  var serverId = rs[index];\n  client.laParam[serverType][serverId] += 1;\n  cb(null, serverId);\n};\n\n/**\n * Consistent-Hash algorithm for calculating server id.\n *\n * @param client {Object} rpc client.\n * @param serverType {String} rpc target serverType.\n * @param msg {Object} rpc message.\n * @param cb {Function} cb(err, serverId).\n */\nvar chRoute = function(client, serverType, msg, cb) {\n  var servers = client._station.serversMap[serverType];\n  if (!servers || !servers.length) {\n    return cb(new Error('rpc servers not exist with serverType: ' + serverType));\n  }\n\n  var index, con;\n  if (!client.chParam) {\n    client.chParam = {};\n  }\n  if (!!client.chParam[serverType]) {\n    con = client.chParam[serverType].consistentHash;\n  } else {\n    client.opts.station = client._station;\n    con = new ConsistentHash(servers, client.opts);\n  }\n  var hashFieldIndex = client.opts.hashFieldIndex;\n  var field = msg.args[hashFieldIndex] || JSON.stringify(msg);\n  cb(null, con.getNode(field));\n  client.chParam[serverType] = {\n    consistentHash: con\n  };\n};\n\nmodule.exports = {\n  rr: rrRoute,\n  wrr: wrrRoute,\n  la: laRoute,\n  ch: chRoute,\n  rd: rdRoute,\n  df: defRoute\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/util/consistentHash.js":"var crypto = require('crypto');\n\nvar ConsistentHash = function(nodes, opts) {\n  this.opts = opts || {};\n  this.replicas = this.opts.replicas || 100;\n  this.algorithm = this.opts.algorithm || 'md5';\n  this.station = this.opts.station;\n  this.ring = {};\n  this.keys = [];\n  this.nodes = [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    this.addNode(nodes[i]);\n  }\n\n  this.station.on('addServer', this.addNode.bind(this));\n  this.station.on('removeServer', this.removeNode.bind(this));\n};\n\nmodule.exports = ConsistentHash;\n\nConsistentHash.prototype.addNode = function(node) {\n  this.nodes.push(node);\n  for (var i = 0; i < this.replicas; i++) {\n    var key = hash(this.algorithm, (node.id || node) + ':' + i);\n    this.keys.push(key);\n    this.ring[key] = node;\n  }\n  this.keys.sort();\n};\n\nConsistentHash.prototype.removeNode = function(node) {\n  for (var i = 0; i < this.nodes.length; i++) {\n    if (this.nodes[i] === node) {\n      this.nodes.splice(i, 1);\n      i--;\n    }\n  }\n\n  for (var j = 0; j < this.replicas; j++) {\n    var key = hash(this.algorithm, (node.id || node) + ':' + j);\n    delete this.ring[key];\n    for (var k = 0; k < this.keys.length; k++) {\n      if (this.keys[k] === key) {\n        this.keys.splice(k, 1);\n        k--;\n      }\n    }\n  }\n};\n\nConsistentHash.prototype.getNode = function(key) {\n  if (getKeysLength(this.ring) === 0) {\n    return 0;\n  }\n  var result = hash(this.algorithm, key);\n  var pos = this.getNodePosition(result);\n  return this.ring[this.keys[pos]];\n};\n\nConsistentHash.prototype.getNodePosition = function(result) {\n  var upper = getKeysLength(this.ring) - 1;\n  var lower = 0;\n  var idx = 0;\n  var comp = 0;\n\n  if (upper === 0) {\n    return 0;\n  }\n\n  //binary search\n  while (lower <= upper) {\n    idx = Math.floor((lower + upper) / 2);\n    comp = compare(this.keys[idx], result);\n\n    if (comp === 0) {\n      return idx;\n    } else if (comp > 0) {\n      upper = idx - 1;\n    } else {\n      lower = idx + 1;\n    }\n  }\n\n  if (upper < 0) {\n    upper = getKeysLength(this.ring) - 1;\n  }\n\n  return upper;\n};\n\nvar getKeysLength = function(map) {\n  return Object.keys(map).length;\n};\n\nvar hash = function(algorithm, str) {\n  return crypto.createHash(algorithm).update(str).digest('hex');\n};\n\nvar compare = function(v1, v2) {\n  return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/node_modules/async/lib/async.js":"/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n(function () {\n\n    var async = {};\n    function noop() {}\n    function identity(v) {\n        return v;\n    }\n    function toBool(v) {\n        return !!v;\n    }\n    function notId(v) {\n        return !v;\n    }\n\n    // global on the server, window in the browser\n    var previous_async;\n\n    // Establish the root object, `window` (`self`) in the browser, `global`\n    // on the server, or `this` in some virtual machines. We use `self`\n    // instead of `window` for `WebWorker` support.\n    var root = typeof self === 'object' && self.self === self && self ||\n            typeof global === 'object' && global.global === global && global ||\n            this;\n\n    if (root != null) {\n        previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        return function() {\n            if (fn === null) throw new Error(\"Callback was already called.\");\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    function _once(fn) {\n        return function() {\n            if (fn === null) return;\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    // Ported from underscore.js isObject\n    var _isObject = function(obj) {\n        var type = typeof obj;\n        return type === 'function' || type === 'object' && !!obj;\n    };\n\n    function _isArrayLike(arr) {\n        return _isArray(arr) || (\n            // has a positive integer length property\n            typeof arr.length === \"number\" &&\n            arr.length >= 0 &&\n            arr.length % 1 === 0\n        );\n    }\n\n    function _arrayEach(arr, iterator) {\n        var index = -1,\n            length = arr.length;\n\n        while (++index < length) {\n            iterator(arr[index], index, arr);\n        }\n    }\n\n    function _map(arr, iterator) {\n        var index = -1,\n            length = arr.length,\n            result = Array(length);\n\n        while (++index < length) {\n            result[index] = iterator(arr[index], index, arr);\n        }\n        return result;\n    }\n\n    function _range(count) {\n        return _map(Array(count), function (v, i) { return i; });\n    }\n\n    function _reduce(arr, iterator, memo) {\n        _arrayEach(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    }\n\n    function _forEachOf(object, iterator) {\n        _arrayEach(_keys(object), function (key) {\n            iterator(object[key], key);\n        });\n    }\n\n    function _indexOf(arr, item) {\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] === item) return i;\n        }\n        return -1;\n    }\n\n    var _keys = Object.keys || function (obj) {\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    function _keyIterator(coll) {\n        var i = -1;\n        var len;\n        var keys;\n        if (_isArrayLike(coll)) {\n            len = coll.length;\n            return function next() {\n                i++;\n                return i < len ? i : null;\n            };\n        } else {\n            keys = _keys(coll);\n            len = keys.length;\n            return function next() {\n                i++;\n                return i < len ? keys[i] : null;\n            };\n        }\n    }\n\n    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\n    // This accumulates the arguments passed into an array, after a given index.\n    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).\n    function _restParam(func, startIndex) {\n        startIndex = startIndex == null ? func.length - 1 : +startIndex;\n        return function() {\n            var length = Math.max(arguments.length - startIndex, 0);\n            var rest = Array(length);\n            for (var index = 0; index < length; index++) {\n                rest[index] = arguments[index + startIndex];\n            }\n            switch (startIndex) {\n                case 0: return func.call(this, rest);\n                case 1: return func.call(this, arguments[0], rest);\n            }\n            // Currently unused but handle cases outside of the switch statement:\n            // var args = Array(startIndex + 1);\n            // for (index = 0; index < startIndex; index++) {\n            //     args[index] = arguments[index];\n            // }\n            // args[startIndex] = rest;\n            // return func.apply(this, args);\n        };\n    }\n\n    function _withoutIndex(iterator) {\n        return function (value, index, callback) {\n            return iterator(value, callback);\n        };\n    }\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n\n    // capture the global reference to guard against fakeTimer mocks\n    var _setImmediate = typeof setImmediate === 'function' && setImmediate;\n\n    var _delay = _setImmediate ? function(fn) {\n        // not a direct alias for IE10 compatibility\n        _setImmediate(fn);\n    } : function(fn) {\n        setTimeout(fn, 0);\n    };\n\n    if (typeof process === 'object' && typeof process.nextTick === 'function') {\n        async.nextTick = process.nextTick;\n    } else {\n        async.nextTick = _delay;\n    }\n    async.setImmediate = _setImmediate ? _delay : async.nextTick;\n\n\n    async.forEach =\n    async.each = function (arr, iterator, callback) {\n        return async.eachOf(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachSeries =\n    async.eachSeries = function (arr, iterator, callback) {\n        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);\n    };\n\n\n    async.forEachLimit =\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachOf =\n    async.eachOf = function (object, iterator, callback) {\n        callback = _once(callback || noop);\n        object = object || [];\n\n        var iter = _keyIterator(object);\n        var key, completed = 0;\n\n        while ((key = iter()) != null) {\n            completed += 1;\n            iterator(object[key], key, only_once(done));\n        }\n\n        if (completed === 0) callback(null);\n\n        function done(err) {\n            completed--;\n            if (err) {\n                callback(err);\n            }\n            // Check key is null in case iterator isn't exhausted\n            // and done resolved synchronously.\n            else if (key === null && completed <= 0) {\n                callback(null);\n            }\n        }\n    };\n\n    async.forEachOfSeries =\n    async.eachOfSeries = function (obj, iterator, callback) {\n        callback = _once(callback || noop);\n        obj = obj || [];\n        var nextKey = _keyIterator(obj);\n        var key = nextKey();\n        function iterate() {\n            var sync = true;\n            if (key === null) {\n                return callback(null);\n            }\n            iterator(obj[key], key, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    key = nextKey();\n                    if (key === null) {\n                        return callback(null);\n                    } else {\n                        if (sync) {\n                            async.setImmediate(iterate);\n                        } else {\n                            iterate();\n                        }\n                    }\n                }\n            }));\n            sync = false;\n        }\n        iterate();\n    };\n\n\n\n    async.forEachOfLimit =\n    async.eachOfLimit = function (obj, limit, iterator, callback) {\n        _eachOfLimit(limit)(obj, iterator, callback);\n    };\n\n    function _eachOfLimit(limit) {\n\n        return function (obj, iterator, callback) {\n            callback = _once(callback || noop);\n            obj = obj || [];\n            var nextKey = _keyIterator(obj);\n            if (limit <= 0) {\n                return callback(null);\n            }\n            var done = false;\n            var running = 0;\n            var errored = false;\n\n            (function replenish () {\n                if (done && running <= 0) {\n                    return callback(null);\n                }\n\n                while (running < limit && !errored) {\n                    var key = nextKey();\n                    if (key === null) {\n                        done = true;\n                        if (running <= 0) {\n                            callback(null);\n                        }\n                        return;\n                    }\n                    running += 1;\n                    iterator(obj[key], key, only_once(function (err) {\n                        running -= 1;\n                        if (err) {\n                            callback(err);\n                            errored = true;\n                        }\n                        else {\n                            replenish();\n                        }\n                    }));\n                }\n            })();\n        };\n    }\n\n\n    function doParallel(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOf, obj, iterator, callback);\n        };\n    }\n    function doParallelLimit(fn) {\n        return function (obj, limit, iterator, callback) {\n            return fn(_eachOfLimit(limit), obj, iterator, callback);\n        };\n    }\n    function doSeries(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOfSeries, obj, iterator, callback);\n        };\n    }\n\n    function _asyncMap(eachfn, arr, iterator, callback) {\n        callback = _once(callback || noop);\n        arr = arr || [];\n        var results = _isArrayLike(arr) ? [] : {};\n        eachfn(arr, function (value, index, callback) {\n            iterator(value, function (err, v) {\n                results[index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = doParallelLimit(_asyncMap);\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.inject =\n    async.foldl =\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachOfSeries(arr, function (x, i, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n\n    async.foldr =\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, identity).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n\n    async.transform = function (arr, memo, iterator, callback) {\n        if (arguments.length === 3) {\n            callback = iterator;\n            iterator = memo;\n            memo = _isArray(arr) ? [] : {};\n        }\n\n        async.eachOf(arr, function(v, k, cb) {\n            iterator(memo, v, k, cb);\n        }, function(err) {\n            callback(err, memo);\n        });\n    };\n\n    function _filter(eachfn, arr, iterator, callback) {\n        var results = [];\n        eachfn(arr, function (x, index, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    results.push({index: index, value: x});\n                }\n                callback();\n            });\n        }, function () {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    }\n\n    async.select =\n    async.filter = doParallel(_filter);\n\n    async.selectLimit =\n    async.filterLimit = doParallelLimit(_filter);\n\n    async.selectSeries =\n    async.filterSeries = doSeries(_filter);\n\n    function _reject(eachfn, arr, iterator, callback) {\n        _filter(eachfn, arr, function(value, cb) {\n            iterator(value, function(v) {\n                cb(!v);\n            });\n        }, callback);\n    }\n    async.reject = doParallel(_reject);\n    async.rejectLimit = doParallelLimit(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    function _createTester(eachfn, check, getResult) {\n        return function(arr, limit, iterator, cb) {\n            function done() {\n                if (cb) cb(getResult(false, void 0));\n            }\n            function iteratee(x, _, callback) {\n                if (!cb) return callback();\n                iterator(x, function (v) {\n                    if (cb && check(v)) {\n                        cb(getResult(true, x));\n                        cb = iterator = false;\n                    }\n                    callback();\n                });\n            }\n            if (arguments.length > 3) {\n                eachfn(arr, limit, iteratee, done);\n            } else {\n                cb = iterator;\n                iterator = limit;\n                eachfn(arr, iteratee, done);\n            }\n        };\n    }\n\n    async.any =\n    async.some = _createTester(async.eachOf, toBool, identity);\n\n    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);\n\n    async.all =\n    async.every = _createTester(async.eachOf, notId, notId);\n\n    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);\n\n    function _findGetResult(v, x) {\n        return x;\n    }\n    async.detect = _createTester(async.eachOf, identity, _findGetResult);\n    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);\n    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                callback(null, _map(results.sort(comparator), function (x) {\n                    return x.value;\n                }));\n            }\n\n        });\n\n        function comparator(left, right) {\n            var a = left.criteria, b = right.criteria;\n            return a < b ? -1 : a > b ? 1 : 0;\n        }\n    };\n\n    async.auto = function (tasks, concurrency, callback) {\n        if (typeof arguments[1] === 'function') {\n            // concurrency is optional, shift the args.\n            callback = concurrency;\n            concurrency = null;\n        }\n        callback = _once(callback || noop);\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length;\n        if (!remainingTasks) {\n            return callback(null);\n        }\n        if (!concurrency) {\n            concurrency = remainingTasks;\n        }\n\n        var results = {};\n        var runningTasks = 0;\n\n        var hasError = false;\n\n        var listeners = [];\n        function addListener(fn) {\n            listeners.unshift(fn);\n        }\n        function removeListener(fn) {\n            var idx = _indexOf(listeners, fn);\n            if (idx >= 0) listeners.splice(idx, 1);\n        }\n        function taskComplete() {\n            remainingTasks--;\n            _arrayEach(listeners.slice(0), function (fn) {\n                fn();\n            });\n        }\n\n        addListener(function () {\n            if (!remainingTasks) {\n                callback(null, results);\n            }\n        });\n\n        _arrayEach(keys, function (k) {\n            if (hasError) return;\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = _restParam(function(err, args) {\n                runningTasks--;\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _forEachOf(results, function(val, rkey) {\n                        safeResults[rkey] = val;\n                    });\n                    safeResults[k] = args;\n                    hasError = true;\n\n                    callback(err, safeResults);\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            });\n            var requires = task.slice(0, task.length - 1);\n            // prevent dead-locks\n            var len = requires.length;\n            var dep;\n            while (len--) {\n                if (!(dep = tasks[requires[len]])) {\n                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));\n                }\n                if (_isArray(dep) && _indexOf(dep, k) >= 0) {\n                    throw new Error('Has cyclic dependencies');\n                }\n            }\n            function ready() {\n                return runningTasks < concurrency && _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            }\n            if (ready()) {\n                runningTasks++;\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                addListener(listener);\n            }\n            function listener() {\n                if (ready()) {\n                    runningTasks++;\n                    removeListener(listener);\n                    task[task.length - 1](taskCallback, results);\n                }\n            }\n        });\n    };\n\n\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var DEFAULT_INTERVAL = 0;\n\n        var attempts = [];\n\n        var opts = {\n            times: DEFAULT_TIMES,\n            interval: DEFAULT_INTERVAL\n        };\n\n        function parseTimes(acc, t){\n            if(typeof t === 'number'){\n                acc.times = parseInt(t, 10) || DEFAULT_TIMES;\n            } else if(typeof t === 'object'){\n                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;\n                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;\n            } else {\n                throw new Error('Unsupported argument type for \\'times\\': ' + typeof t);\n            }\n        }\n\n        var length = arguments.length;\n        if (length < 1 || length > 3) {\n            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');\n        } else if (length <= 2 && typeof times === 'function') {\n            callback = task;\n            task = times;\n        }\n        if (typeof times !== 'function') {\n            parseTimes(opts, times);\n        }\n        opts.callback = callback;\n        opts.task = task;\n\n        function wrappedTask(wrappedCallback, wrappedResults) {\n            function retryAttempt(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            }\n\n            function retryInterval(interval){\n                return function(seriesCallback){\n                    setTimeout(function(){\n                        seriesCallback(null);\n                    }, interval);\n                };\n            }\n\n            while (opts.times) {\n\n                var finalAttempt = !(opts.times-=1);\n                attempts.push(retryAttempt(opts.task, finalAttempt));\n                if(!finalAttempt && opts.interval > 0){\n                    attempts.push(retryInterval(opts.interval));\n                }\n            }\n\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || opts.callback)(data.err, data.result);\n            });\n        }\n\n        // If a callback is passed, run this as a controll flow\n        return opts.callback ? wrappedTask() : wrappedTask;\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = _once(callback || noop);\n        if (!_isArray(tasks)) {\n            var err = new Error('First argument to waterfall must be an array of functions');\n            return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        function wrapIterator(iterator) {\n            return _restParam(function (err, args) {\n                if (err) {\n                    callback.apply(null, [err].concat(args));\n                }\n                else {\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    ensureAsync(iterator).apply(null, args);\n                }\n            });\n        }\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    function _parallel(eachfn, tasks, callback) {\n        callback = callback || noop;\n        var results = _isArrayLike(tasks) ? [] : {};\n\n        eachfn(tasks, function (task, key, callback) {\n            task(_restParam(function (err, args) {\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                results[key] = args;\n                callback(err);\n            }));\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.parallel = function (tasks, callback) {\n        _parallel(async.eachOf, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel(_eachOfLimit(limit), tasks, callback);\n    };\n\n    async.series = function(tasks, callback) {\n        _parallel(async.eachOfSeries, tasks, callback);\n    };\n\n    async.iterator = function (tasks) {\n        function makeCallback(index) {\n            function fn() {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            }\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        }\n        return makeCallback(0);\n    };\n\n    async.apply = _restParam(function (fn, args) {\n        return _restParam(function (callArgs) {\n            return fn.apply(\n                null, args.concat(callArgs)\n            );\n        });\n    });\n\n    function _concat(eachfn, arr, fn, callback) {\n        var result = [];\n        eachfn(arr, function (x, index, cb) {\n            fn(x, function (err, y) {\n                result = result.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, result);\n        });\n    }\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        callback = callback || noop;\n        if (test()) {\n            var next = _restParam(function(err, args) {\n                if (err) {\n                    callback(err);\n                } else if (test.apply(this, args)) {\n                    iterator(next);\n                } else {\n                    callback.apply(null, [null].concat(args));\n                }\n            });\n            iterator(next);\n        } else {\n            callback(null);\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        var calls = 0;\n        return async.whilst(function() {\n            return ++calls <= 1 || test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.until = function (test, iterator, callback) {\n        return async.whilst(function() {\n            return !test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        return async.doWhilst(iterator, function() {\n            return !test.apply(this, arguments);\n        }, callback);\n    };\n\n    async.during = function (test, iterator, callback) {\n        callback = callback || noop;\n\n        var next = _restParam(function(err, args) {\n            if (err) {\n                callback(err);\n            } else {\n                args.push(check);\n                test.apply(this, args);\n            }\n        });\n\n        var check = function(err, truth) {\n            if (err) {\n                callback(err);\n            } else if (truth) {\n                iterator(next);\n            } else {\n                callback(null);\n            }\n        };\n\n        test(check);\n    };\n\n    async.doDuring = function (iterator, test, callback) {\n        var calls = 0;\n        async.during(function(next) {\n            if (calls++ < 1) {\n                next(null, true);\n            } else {\n                test.apply(this, arguments);\n            }\n        }, iterator, callback);\n    };\n\n    function _queue(worker, concurrency, payload) {\n        if (concurrency == null) {\n            concurrency = 1;\n        }\n        else if(concurrency === 0) {\n            throw new Error('Concurrency must not be zero');\n        }\n        function _insert(q, data, pos, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0 && q.idle()) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    callback: callback || noop\n                };\n\n                if (pos) {\n                    q.tasks.unshift(item);\n                } else {\n                    q.tasks.push(item);\n                }\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n            });\n            async.setImmediate(q.process);\n        }\n        function _next(q, tasks) {\n            return function(){\n                workers -= 1;\n\n                var removed = false;\n                var args = arguments;\n                _arrayEach(tasks, function (task) {\n                    _arrayEach(workersList, function (worker, index) {\n                        if (worker === task && !removed) {\n                            workersList.splice(index, 1);\n                            removed = true;\n                        }\n                    });\n\n                    task.callback.apply(task, args);\n                });\n                if (q.tasks.length + workers === 0) {\n                    q.drain();\n                }\n                q.process();\n            };\n        }\n\n        var workers = 0;\n        var workersList = [];\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            payload: payload,\n            saturated: noop,\n            empty: noop,\n            drain: noop,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n                _insert(q, data, false, callback);\n            },\n            kill: function () {\n                q.drain = noop;\n                q.tasks = [];\n            },\n            unshift: function (data, callback) {\n                _insert(q, data, true, callback);\n            },\n            process: function () {\n                while(!q.paused && workers < q.concurrency && q.tasks.length){\n\n                    var tasks = q.payload ?\n                        q.tasks.splice(0, q.payload) :\n                        q.tasks.splice(0, q.tasks.length);\n\n                    var data = _map(tasks, function (task) {\n                        return task.data;\n                    });\n\n                    if (q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    workersList.push(tasks[0]);\n                    var cb = only_once(_next(q, tasks));\n                    worker(data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            workersList: function () {\n                return workersList;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                q.paused = true;\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                var resumeCount = Math.min(q.concurrency, q.tasks.length);\n                // Need to call q.process once per concurrent\n                // worker to preserve full concurrency after pause\n                for (var w = 1; w <= resumeCount; w++) {\n                    async.setImmediate(q.process);\n                }\n            }\n        };\n        return q;\n    }\n\n    async.queue = function (worker, concurrency) {\n        var q = _queue(function (items, cb) {\n            worker(items[0], cb);\n        }, concurrency, 1);\n\n        return q;\n    };\n\n    async.priorityQueue = function (worker, concurrency) {\n\n        function _compareTasks(a, b){\n            return a.priority - b.priority;\n        }\n\n        function _binarySearch(sequence, item, compare) {\n            var beg = -1,\n                end = sequence.length - 1;\n            while (beg < end) {\n                var mid = beg + ((end - beg + 1) >>> 1);\n                if (compare(item, sequence[mid]) >= 0) {\n                    beg = mid;\n                } else {\n                    end = mid - 1;\n                }\n            }\n            return beg;\n        }\n\n        function _insert(q, data, priority, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    priority: priority,\n                    callback: typeof callback === 'function' ? callback : noop\n                };\n\n                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n                async.setImmediate(q.process);\n            });\n        }\n\n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n\n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n            _insert(q, data, priority, callback);\n        };\n\n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        return _queue(worker, 1, payload);\n    };\n\n    function _console_fn(name) {\n        return _restParam(function (fn, args) {\n            fn.apply(null, args.concat([_restParam(function (err, args) {\n                if (typeof console === 'object') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _arrayEach(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            })]));\n        });\n    }\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        var has = Object.prototype.hasOwnProperty;\n        hasher = hasher || identity;\n        var memoized = _restParam(function memoized(args) {\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (has.call(memo, key)) {   \n                async.setImmediate(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (has.call(queues, key)) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([_restParam(function (args) {\n                    memo[key] = args;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                        q[i].apply(null, args);\n                    }\n                })]));\n            }\n        });\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n        return function () {\n            return (fn.unmemoized || fn).apply(null, arguments);\n        };\n    };\n\n    function _times(mapper) {\n        return function (count, iterator, callback) {\n            mapper(_range(count), iterator, callback);\n        };\n    }\n\n    async.times = _times(async.map);\n    async.timesSeries = _times(async.mapSeries);\n    async.timesLimit = function (count, limit, iterator, callback) {\n        return async.mapLimit(_range(count), limit, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return _restParam(function (args) {\n            var that = this;\n\n            var callback = args[args.length - 1];\n            if (typeof callback == 'function') {\n                args.pop();\n            } else {\n                callback = noop;\n            }\n\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {\n                    cb(err, nextargs);\n                })]));\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        });\n    };\n\n    async.compose = function (/* functions... */) {\n        return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n\n    function _applyEach(eachfn) {\n        return _restParam(function(fns, args) {\n            var go = _restParam(function(args) {\n                var that = this;\n                var callback = args.pop();\n                return eachfn(fns, function (fn, _, cb) {\n                    fn.apply(that, args.concat([cb]));\n                },\n                callback);\n            });\n            if (args.length) {\n                return go.apply(this, args);\n            }\n            else {\n                return go;\n            }\n        });\n    }\n\n    async.applyEach = _applyEach(async.eachOf);\n    async.applyEachSeries = _applyEach(async.eachOfSeries);\n\n\n    async.forever = function (fn, callback) {\n        var done = only_once(callback || noop);\n        var task = ensureAsync(fn);\n        function next(err) {\n            if (err) {\n                return done(err);\n            }\n            task(next);\n        }\n        next();\n    };\n\n    function ensureAsync(fn) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            args.push(function () {\n                var innerArgs = arguments;\n                if (sync) {\n                    async.setImmediate(function () {\n                        callback.apply(null, innerArgs);\n                    });\n                } else {\n                    callback.apply(null, innerArgs);\n                }\n            });\n            var sync = true;\n            fn.apply(this, args);\n            sync = false;\n        });\n    }\n\n    async.ensureAsync = ensureAsync;\n\n    async.constant = _restParam(function(values) {\n        var args = [null].concat(values);\n        return function (callback) {\n            return callback.apply(this, args);\n        };\n    });\n\n    async.wrapSync =\n    async.asyncify = function asyncify(func) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            var result;\n            try {\n                result = func.apply(this, args);\n            } catch (e) {\n                return callback(e);\n            }\n            // if result is Promise object\n            if (_isObject(result) && typeof result.then === \"function\") {\n                result.then(function(value) {\n                    callback(null, value);\n                })[\"catch\"](function(err) {\n                    callback(err.message ? err : new Error(err));\n                });\n            } else {\n                callback(null, result);\n            }\n        });\n    };\n\n    // Node.js\n    if (typeof module === 'object' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (typeof define === 'function' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/rpc-server/server.js":"var Loader = require('pomelo-loader');\nvar Gateway = require('./gateway');\n\nvar loadRemoteServices = function(paths, context) {\n  var res = {},\n    item, m;\n  for (var i = 0, l = paths.length; i < l; i++) {\n    item = paths[i];\n    m = Loader.load(item.path, context);\n\n    if (m) {\n      createNamespace(item.namespace, res);\n      for (var s in m) {\n        res[item.namespace][s] = m[s];\n      }\n    }\n  }\n\n  return res;\n};\n\nvar createNamespace = function(namespace, proxies) {\n  proxies[namespace] = proxies[namespace] || {};\n};\n\n/**\n * Create rpc server.\n *\n * @param  {Object}      opts construct parameters\n *                       opts.port {Number|String} rpc server listen port\n *                       opts.paths {Array} remote service code paths, [{namespace, path}, ...]\n *                       opts.context {Object} context for remote service\n *                       opts.acceptorFactory {Object} (optionals)acceptorFactory.create(opts, cb)\n * @return {Object}      rpc server instance\n */\nmodule.exports.create = function(opts) {\n  if (!opts || !opts.port || opts.port < 0 || !opts.paths) {\n    throw new Error('opts.port or opts.paths invalid.');\n  }\n  var services = loadRemoteServices(opts.paths, opts.context);\n  opts.services = services;\n  var gateway = Gateway.create(opts);\n  return gateway;\n};\n\n// module.exports.WSAcceptor = require('./acceptors/ws-acceptor');\n// module.exports.TcpAcceptor = require('./acceptors/tcp-acceptor');\nmodule.exports.MqttAcceptor = require('./acceptors/mqtt-acceptor');","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/rpc-server/gateway.js":"var defaultAcceptorFactory = require('./acceptor');\nvar EventEmitter = require('events').EventEmitter;\nvar Dispatcher = require('./dispatcher');\nvar Loader = require('pomelo-loader');\nvar utils = require('../util/utils');\nvar util = require('util');\nvar fs = require('fs');\n\nvar Gateway = function(opts) {\n  EventEmitter.call(this);\n  this.opts = opts || {};\n  this.port = opts.port || 3050;\n  this.started = false;\n  this.stoped = false;\n  this.acceptorFactory = opts.acceptorFactory || defaultAcceptorFactory;\n  this.services = opts.services;\n  var dispatcher = new Dispatcher(this.services);\n  if (!!this.opts.reloadRemotes) {\n    watchServices(this, dispatcher);\n  }\n  this.acceptor = this.acceptorFactory.create(opts, function(tracer, msg, cb) {\n    dispatcher.route(tracer, msg, cb);\n  });\n};\n\nutil.inherits(Gateway, EventEmitter);\n\nvar pro = Gateway.prototype;\n\npro.stop = function() {\n  if (!this.started || this.stoped) {\n    return;\n  }\n  this.stoped = true;\n  try {\n    this.acceptor.close();\n  } catch (err) {}\n};\n\npro.start = function() {\n  if (this.started) {\n    throw new Error('gateway already start.');\n  }\n  this.started = true;\n\n  var self = this;\n  this.acceptor.on('error', self.emit.bind(self, 'error'));\n  this.acceptor.on('closed', self.emit.bind(self, 'closed'));\n  this.acceptor.listen(this.port);\n};\n\n/**\n * create and init gateway\n *\n * @param opts {services: {rpcServices}, connector:conFactory(optional), router:routeFunction(optional)}\n */\nmodule.exports.create = function(opts) {\n  if (!opts || !opts.services) {\n    throw new Error('opts and opts.services should not be empty.');\n  }\n\n  return new Gateway(opts);\n};\n\nvar watchServices = function(gateway, dispatcher) {\n  var paths = gateway.opts.paths;\n  var app = gateway.opts.context;\n  for (var i = 0; i < paths.length; i++) {\n    (function(index) {\n      fs.watch(paths[index].path, function(event, name) {\n        if (event === 'change') {\n          var res = {};\n          var item = paths[index];\n          var m = Loader.load(item.path, app);\n          if (m) {\n            createNamespace(item.namespace, res);\n            for (var s in m) {\n              res[item.namespace][s] = m[s];\n            }\n          }\n          dispatcher.emit('reload', res);\n        }\n      });\n    })(i);\n  }\n};\n\nvar createNamespace = function(namespace, proxies) {\n  proxies[namespace] = proxies[namespace] || {};\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/rpc-server/acceptor.js":"var acceptor = require('./acceptors/mqtt-acceptor');\n// var acceptor = require('./acceptors/ws2-acceptor');\n\nmodule.exports.create = function(opts, cb) {\n\treturn acceptor.create(opts, cb);\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/rpc-server/acceptors/mqtt-acceptor.js":"var logger = require('pomelo-logger').getLogger('pomelo-rpc', 'mqtt-acceptor');\nvar EventEmitter = require('events').EventEmitter;\nvar Tracer = require('../../util/tracer');\nvar utils = require('../../util/utils');\nvar MqttCon = require('mqtt-connection');\nvar util = require('util');\nvar net = require('net');\n\nvar curId = 1;\n\nvar Acceptor = function(opts, cb) {\n  EventEmitter.call(this);\n  this.interval = opts.interval; // flush interval in ms\n  this.bufferMsg = opts.bufferMsg;\n  this.rpcLogger = opts.rpcLogger;\n  this.rpcDebugLog = opts.rpcDebugLog;\n  this._interval = null; // interval object\n  this.sockets = {};\n  this.msgQueues = {};\n  this.cb = cb;\n};\n\nutil.inherits(Acceptor, EventEmitter);\n\nvar pro = Acceptor.prototype;\n\npro.listen = function(port) {\n  //check status\n  if (!!this.inited) {\n    this.cb(new Error('already inited.'));\n    return;\n  }\n  this.inited = true;\n\n  var self = this;\n\n  this.server = new net.Server();\n  this.server.listen(port);\n\n  this.server.on('error', function(err) {\n    logger.error('rpc server is error: %j', err.stack);\n    self.emit('error', err);\n  });\n\n  this.server.on('connection', function(stream) {\n    var socket = MqttCon(stream);\n    socket['id'] = curId++;\n\n    socket.on('connect', function(pkg) {\n      console.log('connected');\n    });\n\n    socket.on('publish', function(pkg) {\n      pkg = pkg.payload.toString();\n      var isArray = false;\n      try {\n        pkg = JSON.parse(pkg);\n        if (pkg instanceof Array) {\n          processMsgs(socket, self, pkg);\n          isArray = true;\n        } else {\n          processMsg(socket, self, pkg);\n        }\n      } catch (err) {\n        if (!isArray) {\n          doSend(socket, {\n            id: pkg.id,\n            resp: [cloneError(err)]\n          });\n        }\n        logger.error('process rpc message error %s', err.stack);\n      }\n    });\n\n    socket.on('pingreq', function() {\n      socket.pingresp();\n    });\n\n    socket.on('error', function() {\n      self.onSocketClose(socket);\n    });\n\n    socket.on('close', function() {\n      self.onSocketClose(socket);\n    });\n\n    self.sockets[socket.id] = socket;\n\n    socket.on('disconnect', function(reason) {\n      self.onSocketClose(socket);\n    });\n  });\n\n  if (this.bufferMsg) {\n    this._interval = setInterval(function() {\n      flush(self);\n    }, this.interval);\n  }\n};\n\npro.close = function() {\n  if (this.closed) {\n    return;\n  }\n  this.closed = true;\n  if (this._interval) {\n    clearInterval(this._interval);\n    this._interval = null;\n  }\n  this.server.close();\n  this.emit('closed');\n};\n\npro.onSocketClose = function(socket) {\n  if (!socket['closed']) {\n    var id = socket.id;\n    socket['closed'] = true;\n    delete this.sockets[id];\n    delete this.msgQueues[id];\n  }\n}\n\nvar cloneError = function(origin) {\n  // copy the stack infos for Error instance json result is empty\n  var res = {\n    msg: origin.msg,\n    stack: origin.stack\n  };\n  return res;\n};\n\nvar processMsg = function(socket, acceptor, pkg) {\n  var tracer = null;\n  if (this.rpcDebugLog) {\n    tracer = new Tracer(acceptor.rpcLogger, acceptor.rpcDebugLog, pkg.remote, pkg.source, pkg.msg, pkg.traceId, pkg.seqId);\n    tracer.info('server', __filename, 'processMsg', 'mqtt-acceptor receive message and try to process message');\n  }\n  acceptor.cb(tracer, pkg.msg, function() {\n    // var args = Array.prototype.slice.call(arguments, 0);\n    var len = arguments.length;\n    var args = new Array(len);\n    for (var i = 0; i < len; i++) {\n      args[i] = arguments[i];\n    }\n\n    var errorArg = args[0]; // first callback argument can be error object, the others are message\n    if (errorArg && errorArg instanceof Error) {\n      args[0] = cloneError(errorArg);\n    }\n\n    var resp;\n    if (tracer && tracer.isEnabled) {\n      resp = {\n        traceId: tracer.id,\n        seqId: tracer.seq,\n        source: tracer.source,\n        id: pkg.id,\n        resp: args\n      };\n    } else {\n      resp = {\n        id: pkg.id,\n        resp: args\n      };\n    }\n    if (acceptor.bufferMsg) {\n      enqueue(socket, acceptor, resp);\n    } else {\n      doSend(socket, resp);\n    }\n  });\n};\n\nvar processMsgs = function(socket, acceptor, pkgs) {\n  for (var i = 0, l = pkgs.length; i < l; i++) {\n    processMsg(socket, acceptor, pkgs[i]);\n  }\n};\n\nvar enqueue = function(socket, acceptor, msg) {\n  var id = socket.id;\n  var queue = acceptor.msgQueues[id];\n  if (!queue) {\n    queue = acceptor.msgQueues[id] = [];\n  }\n  queue.push(msg);\n};\n\nvar flush = function(acceptor) {\n  var sockets = acceptor.sockets,\n    queues = acceptor.msgQueues,\n    queue, socket;\n  for (var socketId in queues) {\n    socket = sockets[socketId];\n    if (!socket) {\n      // clear pending messages if the socket not exist any more\n      delete queues[socketId];\n      continue;\n    }\n    queue = queues[socketId];\n    if (!queue.length) {\n      continue;\n    }\n    doSend(socket, queue);\n    queues[socketId] = [];\n  }\n};\n\nvar doSend = function(socket, msg) {\n  socket.publish({\n    topic: 'rpc',\n    payload: JSON.stringify(msg)\n  });\n}\n\n/**\n * create acceptor\n *\n * @param opts init params\n * @param cb(tracer, msg, cb) callback function that would be invoked when new message arrives\n */\nmodule.exports.create = function(opts, cb) {\n  return new Acceptor(opts || {}, cb);\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-rpc/lib/rpc-server/dispatcher.js":"var EventEmitter = require('events').EventEmitter;\nvar utils = require('../util/utils');\nvar util = require('util');\n\nvar Dispatcher = function(services) {\n  EventEmitter.call(this);\n  var self = this;\n  this.on('reload', function(services) {\n    self.services = services;\n  });\n  this.services = services;\n};\n\nutil.inherits(Dispatcher, EventEmitter);\n\nmodule.exports = Dispatcher;\n\nvar pro = Dispatcher.prototype;\n\n/**\n * route the msg to appropriate service object\n *\n * @param msg msg package {service:serviceString, method:methodString, args:[]}\n * @param services services object collection, such as {service1: serviceObj1, service2: serviceObj2}\n * @param cb(...) callback function that should be invoked as soon as the rpc finished\n */\npro.route = function(tracer, msg, cb) {\n  tracer && tracer.info('server', __filename, 'route', 'route messsage to appropriate service object');\n  var namespace = this.services[msg.namespace];\n  if (!namespace) {\n    tracer && tracer.error('server', __filename, 'route', 'no such namespace:' + msg.namespace);\n    cb(new Error('no such namespace:' + msg.namespace));\n    return;\n  }\n\n  var service = namespace[msg.service];\n  if (!service) {\n    tracer && tracer.error('server', __filename, 'route', 'no such service:' + msg.service);\n    cb(new Error('no such service:' + msg.service));\n    return;\n  }\n\n  var method = service[msg.method];\n  if (!method) {\n    tracer && tracer.error('server', __filename, 'route', 'no such method:' + msg.method);\n    cb(new Error('no such method:' + msg.method));\n    return;\n  }\n\n  var args = msg.args;\n  args.push(cb);\n  method.apply(service, args);\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/components/pushScheduler.js":"/**\n * Scheduler component to schedule message sending.\n */\n\nvar DefaultScheduler = require('../pushSchedulers/direct');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\n\nmodule.exports = function(app, opts) {\n  return new PushScheduler(app, opts);\n};\n\nvar PushScheduler = function(app, opts) {\n  this.app = app;\n  opts = opts || {};\n  this.scheduler = getScheduler(this, app, opts);\n};\n\nPushScheduler.prototype.name = '__pushScheduler__';\n\n/**\n * Component lifecycle callback\n *\n * @param {Function} cb\n * @return {Void}\n */\nPushScheduler.prototype.afterStart = function(cb) {\n  if(this.isSelectable) {\n    for (var k in this.scheduler) {\n      var sch = this.scheduler[k];\n      if(typeof sch.start === 'function') {\n        sch.start();\n      }\n    }\n    process.nextTick(cb);\n  } else if(typeof this.scheduler.start === 'function') {\n    this.scheduler.start(cb);\n  } else {\n    process.nextTick(cb);\n  }\n};\n\n/**\n * Component lifecycle callback\n *\n * @param {Function} cb\n * @return {Void}\n */\nPushScheduler.prototype.stop = function(force, cb) {\n  if(this.isSelectable) {\n    for (var k in this.scheduler) {\n      var sch = this.scheduler[k];\n      if(typeof sch.stop === 'function') {\n        sch.stop();\n      }\n    }\n    process.nextTick(cb);\n  } else if(typeof this.scheduler.stop === 'function') {\n    this.scheduler.stop(cb);\n  } else {\n    process.nextTick(cb);\n  }\n};\n\n/**\n * Schedule how the message to send.\n *\n * @param  {Number}   reqId request id\n * @param  {String}   route route string of the message\n * @param  {Object}   msg   message content after encoded\n * @param  {Array}    recvs array of receiver's session id\n * @param  {Object}   opts  options\n * @param  {Function} cb\n */\n\nPushScheduler.prototype.schedule = function(reqId, route, msg, recvs, opts, cb) {\n  var self = this;\n  if(self.isSelectable) {\n    if(typeof self.selector === 'function') {\n      self.selector(reqId, route, msg, recvs, opts, function(id) {\n        if(self.scheduler[id] && typeof self.scheduler[id].schedule === 'function') {\n          self.scheduler[id].schedule(reqId, route, msg, recvs, opts, cb);\n        } else {\n          logger.error('invalid pushScheduler id, id: %j', id);\n        }\n      });\n    } else {\n      logger.error('the selector for pushScheduler is not a function, selector: %j', self.selector);\n    }\n  } else {\n    if (typeof self.scheduler.schedule === 'function') {\n      self.scheduler.schedule(reqId, route, msg, recvs, opts, cb);\n    } else {\n      logger.error('the scheduler does not have a schedule function, scheduler: %j', self.scheduler);\n    }\n  }\n};\n\nvar getScheduler = function(pushSchedulerComp, app, opts) {\n  var scheduler = opts.scheduler || DefaultScheduler;\n  if(typeof scheduler === 'function') {\n    return scheduler(app, opts);\n  }\n\n  if(Array.isArray(scheduler)) {\n    var res = {};\n    scheduler.forEach(function(sch) {\n      if(typeof sch.scheduler === 'function') {\n        res[sch.id] = sch.scheduler(app, sch.options);\n      } else {\n        res[sch.id] = sch.scheduler;\n      }\n    });\n    pushSchedulerComp.isSelectable = true;\n    pushSchedulerComp.selector = opts.selector;\n    return res; \n  }\n\n  return scheduler;\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/pushSchedulers/direct.js":"var utils = require('../util/utils');\n\nvar Service = function(app, opts) {\n  if (!(this instanceof Service)) {\n    return new Service(app, opts);\n  }\n\n  opts = opts || {};\n  this.app = app;\n};\n\nmodule.exports = Service;\n\nService.prototype.schedule = function(reqId, route, msg, recvs, opts, cb) {\n  opts = opts || {};\n  if(opts.type === 'broadcast') {\n    doBroadcast(this, msg, opts.userOptions);\n  } else {\n    doBatchPush(this, msg, recvs);\n  }\n\n  if(cb) {\n    process.nextTick(function() {\n      utils.invokeCallback(cb);\n    });\n  }\n};\n\nvar doBroadcast = function(self, msg, opts) {\n  var channelService = self.app.get('channelService');\n  var sessionService = self.app.get('sessionService');\n\n  if(opts.binded) {\n    sessionService.forEachBindedSession(function(session) {\n      if(channelService.broadcastFilter &&\n         !channelService.broadcastFilter(session, msg, opts.filterParam)) {\n        return;\n      }\n\n      sessionService.sendMessageByUid(session.uid, msg);\n    });\n  } else {\n    sessionService.forEachSession(function(session) {\n      if(channelService.broadcastFilter &&\n         !channelService.broadcastFilter(session, msg, opts.filterParam)) {\n        return;\n      }\n\n      sessionService.sendMessage(session.id, msg);\n    });\n  }\n};\n\nvar doBatchPush = function(self, msg, recvs) {\n  var sessionService = self.app.get('sessionService');\n  for(var i=0, l=recvs.length; i<l; i++) {\n    sessionService.sendMessage(recvs[i], msg);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/components/remote.js":"/**\n * Component for remote service.\n * Load remote service and add to global context.\n */\nvar fs = require('fs');\nvar pathUtil = require('../util/pathUtil');\nvar RemoteServer = require('pomelo-rpc').server;\n\n/**\n * Remote component factory function\n *\n * @param {Object} app  current application context\n * @param {Object} opts construct parameters\n *                       opts.acceptorFactory {Object}: acceptorFactory.create(opts, cb)\n * @return {Object}     remote component instances\n */\nmodule.exports = function(app, opts) {\n  opts = opts || {};\n\n  // cacheMsg is deprecated, just for compatibility here.\n  opts.bufferMsg = opts.bufferMsg || opts.cacheMsg || false;\n  opts.interval = opts.interval || 30;\n  if(app.enabled('rpcDebugLog')) {\n    opts.rpcDebugLog = true;\n    opts.rpcLogger = require('pomelo-logger').getLogger('rpc-debug', __filename);\n  }\n  return new Component(app, opts);\n};\n\n/**\n * Remote component class\n *\n * @param {Object} app  current application context\n * @param {Object} opts construct parameters\n */\nvar Component = function(app, opts) {\n  this.app = app;\n  this.opts = opts;\n};\n\nvar pro = Component.prototype;\n\npro.name = '__remote__';\n\n/**\n * Remote component lifecycle function\n *\n * @param {Function} cb\n * @return {Void}\n */\npro.start = function(cb) {\n  this.opts.port = this.app.getCurServer().port;\n  this.remote = genRemote(this.app, this.opts);\n  this.remote.start();\n  process.nextTick(cb);\n};\n\n/**\n * Remote component lifecycle function\n *\n * @param {Boolean}  force whether stop the component immediately\n * @param {Function}  cb\n * @return {Void}\n */\npro.stop = function(force, cb) {\n  this.remote.stop(force);\n  process.nextTick(cb);\n};\n\n/**\n * Get remote paths from application\n *\n * @param {Object} app current application context\n * @return {Array} paths\n *\n */\nvar getRemotePaths = function(app) {\n  var paths = [];\n\n  var role;\n  // master server should not come here\n  if(app.isFrontend()) {\n    role = 'frontend';\n  } else {\n    role = 'backend';\n  }\n\n  var sysPath = pathUtil.getSysRemotePath(role), serverType = app.getServerType();\n  if(fs.existsSync(sysPath)) {\n    paths.push(pathUtil.remotePathRecord('sys', serverType, sysPath));\n  }\n  var userPath = pathUtil.getUserRemotePath(app.getBase(), serverType);\n  if(fs.existsSync(userPath)) {\n    paths.push(pathUtil.remotePathRecord('user', serverType, userPath));\n  }\n\n  return paths;\n};\n\n/**\n * Generate remote server instance\n *\n * @param {Object} app current application context\n * @param {Object} opts contructor parameters for rpc Server\n * @return {Object} remote server instance\n */\nvar genRemote = function(app, opts) {\n  opts.paths = getRemotePaths(app);\n  opts.context = app;\n  if(!!opts.rpcServer) {\n    return opts.rpcServer.create(opts);\n  } else {\n    return RemoteServer.create(opts);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/components/server.js":"/**\n * Component for server starup.\n */\nvar Server = require('../server/server');\n\n/**\n * Component factory function\n *\n * @param {Object} app  current application context\n * @return {Object}     component instance\n */\nmodule.exports = function(app, opts) {\n\treturn new Component(app, opts);\n};\n\n/**\n * Server component class\n *\n * @param {Object} app  current application context\n */\nvar Component = function(app, opts) {\n\tthis.server = Server.create(app, opts);\n};\n\nvar pro = Component.prototype;\n\npro.name = '__server__';\n\n/**\n * Component lifecycle callback\n *\n * @param {Function} cb\n * @return {Void}\n */\npro.start = function(cb) {\n\tthis.server.start();\n\tprocess.nextTick(cb);\n};\n\n/**\n * Component lifecycle callback\n *\n * @param {Function} cb\n * @return {Void}\n */\nComponent.prototype.afterStart = function(cb) {\n\tthis.server.afterStart();\n\tprocess.nextTick(cb);\n};\n\n/**\n * Component lifecycle function\n *\n * @param {Boolean}  force whether stop the component immediately\n * @param {Function}  cb\n * @return {Void}\n */\npro.stop = function(force, cb) {\n\tthis.server.stop();\n\tprocess.nextTick(cb);\n};\n\n/**\n * Proxy server handle\n */\npro.handle = function(msg, session, cb) {\n\tthis.server.handle(msg, session, cb);\n};\n\n/**\n * Proxy server global handle\n */\nComponent.prototype.globalHandle = function(msg, session, cb) {\n\tthis.server.globalHandle(msg, session, cb);\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/server/server.js":"/**\n * Implementation of server component.\n * Init and start server instance.\n */\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar fs = require('fs');\nvar path = require('path');\nvar pathUtil = require('../util/pathUtil');\nvar Loader = require('pomelo-loader');\nvar utils = require('../util/utils');\nvar schedule = require('pomelo-scheduler');\nvar events = require('../util/events');\nvar Constants = require('../util/constants');\nvar FilterService = require('../common/service/filterService');\nvar HandlerService = require('../common/service/handlerService');\n\nvar ST_INITED = 0;    // server inited\nvar ST_STARTED = 1;   // server started\nvar ST_STOPED = 2;    // server stoped\n\n/**\n * Server factory function.\n *\n * @param {Object} app  current application context\n * @return {Object} erver instance\n */\nmodule.exports.create = function(app, opts) {\n  return new Server(app, opts);\n};\n\nvar Server = function (app, opts) {\n  this.opts = opts || {};\n  this.app = app;\n  this.globalFilterService = null;\n  this.filterService = null;\n  this.handlerService = null;\n  this.crons = [];\n  this.jobs = {};\n  this.state = ST_INITED;\n\n  app.event.on(events.ADD_CRONS, this.addCrons.bind(this));\n  app.event.on(events.REMOVE_CRONS, this.removeCrons.bind(this));\n};\n\nvar pro = Server.prototype;\n\n/**\n * Server lifecycle callback\n */\npro.start = function() {\n  if(this.state > ST_INITED) {\n    return;\n  }\n\n  this.globalFilterService = initFilter(true, this.app);\n  this.filterService = initFilter(false, this.app);\n  this.handlerService = initHandler(this.app, this.opts);\n  this.cronHandlers = loadCronHandlers(this.app);\n  loadCrons(this, this.app);\n  this.state = ST_STARTED;\n};\n\npro.afterStart = function() {\n  scheduleCrons(this, this.crons);\n};\n\n/**\n * Stop server\n */\npro.stop = function() {\n  this.state = ST_STOPED;\n};\n\n/**\n * Global handler.\n *\n * @param  {Object} msg request message\n * @param  {Object} session session object\n * @param  {Callback} callback function \n */\npro.globalHandle = function(msg, session, cb) {\n  if(this.state !== ST_STARTED) {\n    utils.invokeCallback(cb, new Error('server not started'));\n    return;\n  }\n\n  var routeRecord = parseRoute(msg.route);\n  if(!routeRecord) {\n    utils.invokeCallback(cb, new Error('meet unknown route message %j', msg.route));\n    return;\n  }\n\n  var self = this;\n  var dispatch = function(err, resp, opts) {\n    if(err) {\n      handleError(true, self, err, msg, session, resp, opts, function(err, resp, opts) {\n        response(true, self, err, msg, session, resp, opts, cb);\n      });\n      return;\n    }\n\n    if(self.app.getServerType() !== routeRecord.serverType) {\n      doForward(self.app, msg, session, routeRecord, function(err, resp, opts) {\n        response(true, self, err, msg, session, resp, opts, cb);\n      });\n    } else {\n      doHandle(self, msg, session, routeRecord, function(err, resp, opts) {\n        response(true, self, err, msg, session, resp, opts, cb);\n      });\n    }\n  };\n  beforeFilter(true, self, msg, session, dispatch);\n};\n\n/**\n * Handle request\n */\npro.handle = function(msg, session, cb) {\n   if(this.state !== ST_STARTED) {\n    cb(new Error('server not started'));\n    return;\n  }\n\n  var routeRecord = parseRoute(msg.route);\n  doHandle(this, msg, session, routeRecord, cb);\n};\n\n/**\n * Add crons at runtime.\n *\n * @param {Array} crons would be added in application\n */\npro.addCrons = function(crons) {\n  this.cronHandlers = loadCronHandlers(this.app);\n  for(var i=0, l=crons.length; i<l; i++) {\n    var cron = crons[i];\n    checkAndAdd(cron, this.crons, this);\n  }\n  scheduleCrons(this, crons);\n};\n\n/**\n * Remove crons at runtime.\n *\n * @param {Array} crons would be removed in application\n */\npro.removeCrons = function(crons) {\n  for(var i=0, l=crons.length; i<l; i++) {\n    var cron = crons[i];\n    var id = parseInt(cron.id);\n    if(!!this.jobs[id]) {\n      schedule.cancelJob(this.jobs[id]);\n    } else {\n      logger.warn('cron is not in application: %j', cron);\n    }\n  }\n};\n\nvar initFilter = function(isGlobal, app) {\n  var service = new FilterService();\n  var befores, afters;\n\n  if(isGlobal) {\n    befores = app.get(Constants.KEYWORDS.GLOBAL_BEFORE_FILTER);\n    afters = app.get(Constants.KEYWORDS.GLOBAL_AFTER_FILTER);\n  } else {\n    befores = app.get(Constants.KEYWORDS.BEFORE_FILTER);\n    afters = app.get(Constants.KEYWORDS.AFTER_FILTER);\n  }\n\n  var i, l;\n  if(befores) {\n    for(i=0, l=befores.length; i<l; i++) {\n      service.before(befores[i]);\n    }\n  }\n\n  if(afters) {\n    for(i=0, l=afters.length; i<l; i++) {\n      service.after(afters[i]);\n    }\n  }\n\n  return service;\n};\n\nvar initHandler = function(app, opts) {\n  return new HandlerService(app, opts);\n};\n\n/**\n * Load cron handlers from current application\n */\nvar loadCronHandlers = function(app) {\n  var p = pathUtil.getCronPath(app.getBase(), app.getServerType());\n  if(p) {\n    return Loader.load(p, app);\n  }\n};\n\n/**\n * Load crons from configure file\n */\nvar loadCrons = function(server, app) {\n  var env = app.get(Constants.RESERVED.ENV);\n  var p = path.join(app.getBase(), Constants.FILEPATH.CRON);\n  if(!fs.existsSync(p)) {\n    p = path.join(app.getBase(), Constants.FILEPATH.CONFIG_DIR, env, path.basename(Constants.FILEPATH.CRON));\n    if (!fs.existsSync(p)) {\n      return;\n    }\n  }\n  app.loadConfigBaseApp(Constants.RESERVED.CRONS, Constants.FILEPATH.CRON);\n  var crons = app.get(Constants.RESERVED.CRONS);\n  for(var serverType in crons) {\n    if(app.serverType === serverType) {\n      var list = crons[serverType];\n      for(var i = 0; i<list.length; i++) {\n        if(!list[i].serverId) {\n          checkAndAdd(list[i], server.crons, server);\n        } else {\n          if(app.serverId === list[i].serverId) {\n            checkAndAdd(list[i], server.crons, server);\n          }\n        }\n      }\n    }\n  }\n};\n\n/**\n * Fire before filter chain if any\n */\nvar beforeFilter = function(isGlobal, server, msg, session, cb) {\n  var fm;\n  if(isGlobal) {\n    fm = server.globalFilterService;\n  } else {\n    fm = server.filterService;\n  }\n  if(fm) {\n    fm.beforeFilter(msg, session, cb);\n  } else {\n    utils.invokeCallback(cb);\n  }\n};\n\n/**\n * Fire after filter chain if have\n */\nvar afterFilter = function(isGlobal, server, err, msg, session, resp, opts, cb) {\n  var fm;\n  if(isGlobal) {\n    fm = server.globalFilterService;\n  } else {\n    fm = server.filterService;\n  }\n  if(fm) {\n    if(isGlobal) {\n      fm.afterFilter(err, msg, session, resp, function() {\n        // do nothing\n      });\n    } else {\n      fm.afterFilter(err, msg, session, resp, function(err) {\n        cb(err, resp, opts);\n      });\n    }\n  }\n};\n\n/**\n * pass err to the global error handler if specified\n */\nvar handleError = function(isGlobal, server, err, msg, session, resp, opts, cb) {\n  var handler;\n  if(isGlobal) {\n    handler = server.app.get(Constants.RESERVED.GLOBAL_ERROR_HANDLER);\n  } else {\n    handler = server.app.get(Constants.RESERVED.ERROR_HANDLER);\n  }\n  if(!handler) {\n    logger.debug('no default error handler to resolve unknown exception. ' + err.stack);\n    utils.invokeCallback(cb, err, resp, opts);\n  } else {\n    if(handler.length === 5) {\n      handler(err, msg, resp, session, cb);\n    } else {\n       handler(err, msg, resp, session, opts, cb);     \n    }\n  }\n};\n\n/**\n * Send response to client and fire after filter chain if any.\n */\n\nvar response = function(isGlobal, server, err, msg, session, resp, opts, cb) {\n  if(isGlobal) {\n    cb(err, resp, opts);\n    // after filter should not interfere response\n    afterFilter(isGlobal, server, err, msg, session, resp, opts, cb);\n  } else {\n    afterFilter(isGlobal, server, err, msg, session, resp, opts, cb);\n  }\n};\n\n/**\n * Parse route string.\n *\n * @param  {String} route route string, such as: serverName.handlerName.methodName\n * @return {Object}       parse result object or null for illeagle route string\n */\nvar parseRoute = function(route) {\n  if(!route) {\n    return null;\n  }\n  var ts = route.split('.');\n  if(ts.length !== 3) {\n    return null;\n  }\n\n  return {\n    route: route,\n    serverType: ts[0],\n    handler: ts[1],\n    method: ts[2]\n  };\n};\n\nvar doForward = function(app, msg, session, routeRecord, cb) {\n  var finished = false;\n  //should route to other servers\n  try {\n    app.sysrpc[routeRecord.serverType].msgRemote.forwardMessage(\n    // app.sysrpc[routeRecord.serverType].msgRemote.forwardMessage2(\n      session,\n      msg,\n      // msg.oldRoute || msg.route,\n      // msg.body,\n      // msg.aesPassword,\n      // msg.compressGzip,\n      session.export(),\n      function(err, resp, opts) {\n        if(err) {\n          logger.error('fail to process remote message:' + err.stack);\n        }\n        finished = true;\n        utils.invokeCallback(cb, err, resp, opts);\n      }\n    );\n  } catch(err) {\n    if(!finished) {\n      logger.error('fail to forward message:' + err.stack);\n      utils.invokeCallback(cb, err);\n    }\n  }\n};\n\nvar doHandle = function(server, msg, session, routeRecord, cb) {\n  var originMsg = msg;\n  msg = msg.body || {};\n  msg.__route__ = originMsg.route;\n\n  var self = server;\n\n  var handle = function(err, resp, opts) {\n    if(err) {\n      // error from before filter\n      handleError(false, self, err, msg, session, resp, opts, function(err, resp, opts) {\n        response(false, self, err, msg, session, resp, opts, cb);\n      });\n      return;\n    }\n\n    self.handlerService.handle(routeRecord, msg, session, function(err, resp, opts) {\n      if(err) {\n        //error from handler\n        handleError(false, self, err, msg, session, resp, opts, function(err, resp, opts) {\n          response(false, self, err, msg, session, resp, opts, cb);\n        });\n        return;\n      }\n\n      response(false, self, err, msg, session, resp, opts, cb);\n    });\n  };  //end of handle\n\n  beforeFilter(false, server, msg, session, handle);\n};\n\n/**\n * Schedule crons\n */\nvar scheduleCrons = function(server, crons) {\n  var handlers = server.cronHandlers;\n  for(var i = 0; i<crons.length; i++) {\n    var cronInfo = crons[i];\n    var time = cronInfo.time;\n    var action = cronInfo.action;\n    var jobId = cronInfo.id;\n\n    if(!time || !action || !jobId) {\n      logger.error('cron miss necessary parameters: %j', cronInfo);\n      continue;\n    }\n\n    if(action.indexOf('.') < 0) {\n      logger.error('cron action is error format: %j', cronInfo);\n      continue;\n    }\n    \n    var cron = action.split('.')[0];\n    var job = action.split('.')[1];\n    var handler = handlers[cron];\n    \n    if(!handler) {\n      logger.error('could not find cron: %j', cronInfo);\n      continue;\n    }\n      \n    if(typeof handler[job] !== 'function') {\n      logger.error('could not find cron job: %j, %s', cronInfo, job);\n      continue;\n    }\n      \n    var id = schedule.scheduleJob(time, handler[job].bind(handler));\n    server.jobs[jobId] = id;\n  }\n};\n\n/**\n * If cron is not in crons then put it in the array.\n */\nvar checkAndAdd = function(cron, crons, server) {\n  if(!containCron(cron.id, crons)) {\n    server.crons.push(cron);\n  } else {\n    logger.warn('cron is duplicated: %j', cron);\n  }\n};\n\n/**\n * Check if cron is in crons.\n */\nvar containCron = function(id, crons) {\n  for(var i=0, l=crons.length; i<l; i++) {\n    if(id === crons[i].id) {\n      return true;\n    }\n  }\n  return false;\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-scheduler/lib/schedule.js":"/**\n * The main class and interface of the schedule module\n */\nvar PriorityQueue = require('./priorityQueue');\nvar Job = require('./job.js');\nvar timerCount = 0;\n\nvar logger = require('log4js').getLogger(__filename);\n\nvar map = {};\nvar queue = PriorityQueue.createPriorityQueue(comparator);\n\nvar jobId = 0;\nvar timer;\n\n//The accuracy of the scheduler, it will affect the performance when the schedule tasks are\n//crowded together\nvar accuracy = 10;\n\n/**\n * Schedule a new Job\n */\nfunction scheduleJob(trigger, jobFunc, jobData){\n  var job = Job.createJob(trigger, jobFunc, jobData);\n  var excuteTime = job.excuteTime();\n  var id = job.id;\n\n  map[id] = job;\n  var element = {\n    id : id,\n    time : excuteTime\n  };\n\n  var curJob = queue.peek();\n  if(!curJob || excuteTime < curJob.time){\n    queue.offer(element);\n    setTimer(job);\n\n    return job.id;\n  }\n\n  queue.offer(element);\n  return job.id;\n}\n\n/**\n * Cancel Job\n */\nfunction cancelJob(id){\n  var curJob = queue.peek();\n  if(curJob && id === curJob.id){ // to avoid queue.peek() is null\n    queue.pop();\n    delete map[id];\n\n    clearTimeout(timer);\n    excuteJob();\n  }\n  delete map[id];\n  return true;\n}\n\n/**\n * Clear last timeout and schedule the next job, it will automaticly run the job that\n * need to run now\n * @param job The job need to schedule\n * @return void\n */\nfunction setTimer(job){\n  clearTimeout(timer);\n\n  timer = setTimeout(excuteJob, job.excuteTime()-Date.now());\n}\n\n/**\n * The function used to ran the schedule job, and setTimeout for next running job\n */\nfunction excuteJob(){\n  var job = peekNextJob();\n  var nextJob;\n\n  while(!!job && (job.excuteTime()-Date.now())<accuracy){\n    job.run();\n    queue.pop();\n\n    var nextTime = job.nextTime();\n\n    if(nextTime === null){\n      delete map[job.id];\n    }else{\n      queue.offer({id:job.id, time: nextTime});\n    }\n    job = peekNextJob();\n  }\n\n  //If all the job have been canceled\n  if(!job)\n    return;\n\n  //Run next schedule\n  setTimer(job);\n}\n\n/**\n * Return, but not remove the next valid job\n * @return Next valid job\n */\nfunction peekNextJob(){\n  if(queue.size() <= 0)\n    return null;\n\n  var job = null;\n\n  do{\n    job = map[queue.peek().id];\n    if(!job) queue.pop();\n  }while(!job && queue.size() > 0);\n\n  return (!!job)?job:null;\n}\n\n/**\n * Return and remove the next valid job\n * @return Next valid job\n */\nfunction getNextJob(){\n  var job = null;\n\n  while(!job && queue.size() > 0){\n    var id = queue.pop().id;\n    job = map[id];\n  }\n\n  return (!!job)?job:null;\n}\n\nfunction comparator(e1, e2){\n  return e1.time > e2.time;\n}\n\nmodule.exports.scheduleJob = scheduleJob;\nmodule.exports.cancelJob = cancelJob;\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-scheduler/lib/priorityQueue.js":"/**\n * The PriorityQeueu class\n */\nvar PriorityQueue = function(comparator){\n  this.init(comparator);\n}\n\nvar pro = PriorityQueue.prototype;\n\npro.init = function(comparator){\n  this._comparator = typeof(comparator)=='function'?comparator:this._defaultComparator;\n  \n  this._queue = [];\n  this._tailPos = 0;\n}\n\n/**\n * Return the size of the pirority queue\n * @return PirorityQueue size\n */\npro.size = function(){\n  return this._tailPos;\n};\n  \n/**\n * Insert an element to the queue\n * @param element The element to insert\n */\npro.offer = function(element){\n  var queue = this._queue;\n  var compare = this._comparator;\n  \n  queue[this._tailPos++] = element;\n  \n  var pos = this._tailPos-1;\n  \n  while(pos > 0){\n    var parentPos = (pos%2==0)?(pos/2-1):(pos-1)/2;\n    if(compare(queue[parentPos], element)){\n      queue[pos] = queue[parentPos];\n      queue[parentPos] = element;\n      \n      pos = parentPos;\n    }else{\n      break;\n    }\n  }\n};\n          \n/**\n * Get and remove the first element in the queue\n * @return The first element\n */        \npro.pop = function(){\n  var queue = this._queue;\n  var compare = this._comparator;\n  \n  if(this._tailPos == 0)\n    return null;\n  \n  \n  var headNode = queue[0];\n  \n  var tail = queue[this._tailPos - 1];\n\n  var pos = 0;\n  var left = pos*2 + 1;\n  var right = left + 1;\n  queue[pos] = tail;\n  this._tailPos--;\n  \n  while(left < this._tailPos){    \n    if(right<this._tailPos && compare(queue[left], queue[right]) && compare(queue[pos], queue[right])){\n      queue[pos] = queue[right];\n      queue[right] = tail;\n      \n      pos = right;\n    }else if(compare(queue[pos],queue[left])){\n      queue[pos] = queue[left];\n      queue[left] = tail;\n      \n      pos = left;\n    }else{\n      break;\n    }\n    \n    left = pos*2 + 1;\n    right = left + 1;\n  }\n  \n  return headNode;\n};\n\n/**\n * Get but not remove the first element in the queue\n * @return The first element\n */\npro.peek = function(){\n  if(this._tailPos == 0)\n    return null;\n  return this._queue[0];\n}\n\npro._defaultComparator = function(a , b){\n  return a > b;\n}\n\nmodule.exports.createPriorityQueue = function(comparator){\n  return new PriorityQueue(comparator);\n}","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-scheduler/lib/job.js":"/**\n * This is the class of the job used in schedule module\n */\nvar cronTrigger = require('./cronTrigger');\nvar simpleTrigger = require('./simpleTrigger');\n\nvar jobId = 1;\n\nvar SIMPLE_JOB = 1;\nvar CRON_JOB  = 2;\nvar jobCount = 0;\n\nvar warnLimit = 500;\n\nvar logger = require('log4js').getLogger(__filename);\n\n\n//For test\nvar lateCount = 0;\n\nvar Job = function(trigger, jobFunc, jobData){\n  this.data = (!!jobData)?jobData:null;\n  this.func = jobFunc;\n\n  if(typeof(trigger) == 'string'){\n    this.type = CRON_JOB;\n    this.trigger = cronTrigger.createTrigger(trigger, this);\n  }else if(typeof(trigger) == 'object'){\n    this.type = SIMPLE_JOB;\n    this.trigger = simpleTrigger.createTrigger(trigger, this);\n  }\n\n  this.id = jobId++;\n  this.runTime = 0;\n};\n\nvar pro = Job.prototype;\n\n/**\n * Run the job code\n */\npro.run = function(){\n  try{\n    jobCount++;\n    this.runTime++;\n    var late = Date.now() - this.excuteTime();\n    if(late>warnLimit)\n      logger.warn('run Job count ' + jobCount + ' late :' + late + ' lateCount ' + (++lateCount));\n    this.func(this.data);\n  }catch(e){\n    logger.error(\"Job run error for exception ! \" + e.stack);\n  }\n};\n\n/**\n * Compute the next excution time\n */\npro.nextTime = function(){\n  return this.trigger.nextExcuteTime();\n};\n\npro.excuteTime = function(){\n    return this.trigger.excuteTime();\n};\n\n/**\n * The Interface to create Job\n * @param trigger The trigger to use\n * @param jobFunc The function the job to run\n * @param jobDate The date the job use\n * @return The new instance of the give job or null if fail\n */\nfunction createJob(trigger, jobFunc, jobData){\n  return new Job(trigger, jobFunc, jobData);\n}\n\nmodule.exports.createJob = createJob;","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-scheduler/lib/cronTrigger.js":"/**\n * This is the trigger used to decode the cronTimer and calculate the next excution time of the cron Trigger.\n */\nvar logger = require('log4js').getLogger(__filename);\n\nvar SECOND = 0;\nvar MIN = 1;\nvar HOUR = 2;\nvar DOM = 3;\nvar MONTH = 4;\nvar DOW = 5;\n\nvar Limit = [[0,59],[0,59],[0,24],[1,31],[0,11],[0,6]];\n\n/**\n * The constructor of the CronTrigger\n * @param trigger The trigger str used to build the cronTrigger instance\n */\nvar CronTrigger = function(trigger, job){\n  this.trigger = this.decodeTrigger(trigger);\n\n  this.nextTime = this.nextExcuteTime(Date.now());\n\n  this.job = job;\n};\n\nvar pro = CronTrigger.prototype;\n\n/**\n * Get the current excuteTime of trigger\n */\npro.excuteTime = function(){\n  return this.nextTime;\n};\n\n/**\n * Caculate the next valid cronTime after the given time\n * @param The given time point\n * @return The nearest valid time after the given time point\n */\npro.nextExcuteTime = function(time){\n  //add 1s to the time so it must be the next time\n  time = !!time?time:this.nextTime;\n  time += 1000;\n\n  var cronTrigger = this.trigger;\n  var date = new Date(time);\n  date.setMilliseconds(0);\n\n  outmost:\n  while(true){\n    if(date.getFullYear() > 2999){\n      logger.error(\"Can't compute the next time, exceed the limit\");\n      return null;\n    }\n    if(!timeMatch(date.getMonth(), cronTrigger[MONTH])){\n      var nextMonth = nextCronTime(date.getMonth(), cronTrigger[MONTH]);\n\n      if(nextMonth == null)\n        return null;\n\n      if(nextMonth <= date.getMonth()){\n        date.setYear(date.getFullYear() + 1);\n        date.setMonth(0);\n        date.setDate(1);\n        date.setHours(0);\n        date.setMinutes(0);\n        date.setSeconds(0);\n        continue;\n      }\n      \n      date.setDate(1);\n      date.setMonth(nextMonth);\n      date.setHours(0);\n      date.setMinutes(0);\n      date.setSeconds(0);\n    }\n\n    if(!timeMatch(date.getDate(), cronTrigger[DOM]) || !timeMatch(date.getDay(), cronTrigger[DOW])){\n      var domLimit = getDomLimit(date.getFullYear(), date.getMonth());\n\n      do{\n        var nextDom = nextCronTime(date.getDate(), cronTrigger[DOM]);\n        if(nextDom == null)\n          return null;\n\n        //If the date is in the next month, add month\n        if(nextDom <= date.getDate() || nextDom > domLimit){\n          date.setDate(1);\n          date.setMonth(date.getMonth() + 1);\n          date.setHours(0);\n          date.setMinutes(0);\n          date.setSeconds(0);\n          continue outmost;\n        }\n\n         date.setDate(nextDom);\n      }while(!timeMatch(date.getDay(), cronTrigger[DOW]));\n\n      date.setHours(0);\n      date.setMinutes(0);\n      date.setSeconds(0);\n    }\n\n    if(!timeMatch(date.getHours(), cronTrigger[HOUR])){\n      var nextHour = nextCronTime(date.getHours(), cronTrigger[HOUR]);\n\n      if(nextHour <= date.getHours()){\n         date.setDate(date.getDate() + 1);\n         date.setHours(nextHour);\n         date.setMinutes(0);\n         date.setSeconds(0);\n         continue;\n      }\n\n      date.setHours(nextHour);\n      date.setMinutes(0);\n      date.setSeconds(0);\n    }\n\n    if(!timeMatch(date.getMinutes(), cronTrigger[MIN])){\n      var nextMinute = nextCronTime(date.getMinutes(), cronTrigger[MIN]);\n\n      if(nextMinute <= date.getMinutes()){\n         date.setHours(date.getHours() + 1);\n         date.setMinutes(nextMinute);\n         date.setSeconds(0);\n         continue;\n      }\n\n      date.setMinutes(nextMinute);\n      date.setSeconds(0);\n    }\n\n    if(!timeMatch(date.getSeconds(), cronTrigger[SECOND])){\n      var nextSecond = nextCronTime(date.getSeconds(), cronTrigger[SECOND]);\n\n      if(nextSecond <= date.getSeconds()){\n         date.setMinutes(date.getMinutes() + 1);\n         date.setSeconds(nextSecond);\n         continue;\n      }\n\n      date.setSeconds(nextSecond);\n    }\n    break;\n  }\n\n  this.nextTime = date.getTime();\n  return this.nextTime;\n};\n\n/**\n * return the next match time of the given value\n * @param value The time value\n * @param cronTime The cronTime need to match\n * @return The match value or null if unmatch(it offten means an error occur).\n */\nfunction nextCronTime(value, cronTime){\n  value += 1;\n\n  if(typeof(cronTime) == 'number'){\n    if(cronTime == -1)\n      return value;\n    else\n      return cronTime;\n  }else if(typeof(cronTime) == 'object' && cronTime instanceof Array){\n    if(value <= cronTime[0] || value > cronTime[cronTime.length -1])\n      return cronTime[0];\n\n    for(var i = 0; i < cronTime.length; i++)\n      if(value <= cronTime[i])\n        return cronTime[i];\n  }\n\n  logger.warn('Compute next Time error! value :' + value + ' cronTime : ' + cronTime);\n  return null;\n}\n\n/**\n * Match the given value to the cronTime\n * @param value The given value\n * @param cronTime The cronTime\n * @return The match result\n */\nfunction timeMatch(value, cronTime){\n  if(typeof(cronTime) == 'number'){\n    if(cronTime == -1)\n      return true;\n    if(value == cronTime)\n      return true;\n    return false;\n  }else if(typeof(cronTime) == 'object' && cronTime instanceof Array){\n    if(value < cronTime[0] || value > cronTime[cronTime.length -1])\n      return false;\n\n    for(var i = 0; i < cronTime.length; i++)\n      if(value == cronTime[i])\n        return true;\n\n    return false;\n  }\n\n  return null;\n}\n\n/**\n * Decude the cronTrigger string to arrays\n * @param cronTimeStr The cronTimeStr need to decode, like \"0 12 * * * 3\"\n * @return The array to represent the cronTimer\n */\npro.decodeTrigger = function(cronTimeStr){\n  var cronTimes = cronTimeStr.split(/\\s+/);\n\n  if(cronTimes.length != 6){\n    console.log('error');\n    return null;\n  }\n\n  for(var i = 0; i < cronTimes.length; i++){\n    cronTimes[i] = (this.decodeTimeStr(cronTimes[i], i));\n\n    if(!checkNum(cronTimes[i], Limit[i][0], Limit[i][1])){\n      logger.error('Decode crontime error, value exceed limit!' +\n        JSON.stringify({cronTime: cronTimes[i], limit:Limit[i]}));\n      return null;\n    }\n  }\n\n  return cronTimes;\n}\n\n/**\n * Decode the cron Time string\n * @param timeStr The cron time string, like: 1,2 or 1-3\n * @return A sorted array, like [1,2,3]\n */\npro.decodeTimeStr = function(timeStr, type){\n  var result = {};\n  var arr = [];\n\n  if(timeStr=='*'){\n    return -1;\n  }else if(timeStr.search(',')>0){\n    var timeArr = timeStr.split(',');\n    for(var i = 0; i < timeArr.length; i++){\n      var time = timeArr[i];\n      if(time.match(/^\\d+-\\d+$/)){\n        decodeRangeTime(result, time);\n      }else if(time.match(/^\\d+\\/\\d+/)){\n        decodePeriodTime(result, time, type);\n      }else if(!isNaN(time)){\n        var num = Number(time);\n        result[num] = num;\n      }else\n        return null;\n    }\n  }else if(timeStr.match(/^\\d+-\\d+$/)){\n    decodeRangeTime(result, timeStr);\n  }else if(timeStr.match(/^\\d+\\/\\d+/)){\n    decodePeriodTime(result, timeStr, type);\n  }else if(!isNaN(timeStr)){\n    var num = Number(timeStr);\n    result[num] = num;\n  }else{\n    return null;\n  }\n\n  for(var key in result){\n    arr.push(result[key]);\n  }\n\n  arr.sort(function(a, b){\n    return a - b;\n  });\n\n  return arr;\n}\n\n/**\n * Decode time range\n * @param map The decode map\n * @param timeStr The range string, like 2-5\n */\nfunction decodeRangeTime(map, timeStr){\n  var times = timeStr.split('-');\n\n  times[0] = Number(times[0]);\n  times[1] = Number(times[1]);\n  if(times[0] > times[1]){\n    console.log(\"Error time range\");\n    return null;\n  }\n\n  for(var i = times[0]; i <= times[1]; i++){\n    map[i] = i;\n  }\n}\n\n/**\n * Compute the period timer\n */\nfunction decodePeriodTime(map, timeStr, type){\n  var times = timeStr.split('/');\n  var min = Limit[type][0];\n  var max = Limit[type][1];\n\n  var remind = Number(times[0]);\n  var period = Number(times[1]);\n\n  if(period==0)\n    return;\n\n  for(var i = min; i <= max; i++){\n    if(i%period == remind)\n      map[i] = i;\n  }\n}\n\n/**\n * Check if the numbers are valid\n * @param nums The numbers array need to check\n * @param min Minimus value\n * @param max Maximam value\n * @return If all the numbers are in the data range\n */\nfunction checkNum(nums, min, max){\n  if(nums == null)\n    return false;\n\n  if(nums == -1)\n    return true;\n\n  for(var i = 0; i < nums.length; i++){\n    if(nums[i]<min || nums[i]>max)\n      return false;\n  }\n\n  return true;\n}\n\n/**\n * Get the date limit of given month\n * @param The given year\n * @month The given month\n * @return The date count of given month\n */\nfunction getDomLimit(year, month){\n  var date = new Date(year, month+1, 0);\n\n  return date.getDate();\n}\n\n/**\n * Create cronTrigger\n * @param trigger The Cron Trigger string\n * @return The Cron trigger\n */\nfunction createTrigger(trigger, job){\n  return new CronTrigger(trigger, job);\n}\n\nmodule.exports.createTrigger = createTrigger;\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-scheduler/node_modules/log4js/lib/log4js.js":"\"use strict\";\n/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview log4js is a library to log in JavaScript in similar manner\n * than in log4j for Java. The API should be nearly the same.\n *\n * <h3>Example:</h3>\n * <pre>\n *  var logging = require('log4js');\n *  //add an appender that logs all messages to stdout.\n *  logging.addAppender(logging.consoleAppender());\n *  //add an appender that logs \"some-category\" to a file\n *  logging.addAppender(logging.fileAppender(\"file.log\"), \"some-category\");\n *  //get a logger\n *  var log = logging.getLogger(\"some-category\");\n *  log.setLevel(logging.levels.TRACE); //set the Level\n *\n *  ...\n *\n *  //call the log\n *  log.trace(\"trace me\" );\n * </pre>\n *\n * NOTE: the authors below are the original browser-based log4js authors\n * don't try to contact them about bugs in this version :)\n * @version 1.0\n * @author Stephan Strittmatter - http://jroller.com/page/stritti\n * @author Seth Chisamore - http://www.chisamore.com\n * @since 2005-05-20\n * @static\n * Website: http://log4js.berlios.de\n */\nvar events = require('events')\n, fs = require('fs')\n, path = require('path')\n, util = require('util')\n, layouts = require('./layouts')\n, levels = require('./levels')\n, LoggingEvent = require('./logger').LoggingEvent\n, Logger = require('./logger').Logger\n, ALL_CATEGORIES = '[all]'\n, appenders = {}\n, loggers = {}\n, appenderMakers = {}\n, defaultConfig =   {\n  appenders: [\n    { type: \"console\" }\n  ],\n  replaceConsole: false\n};\n\n/**\n * Get a logger instance. Instance is cached on categoryName level.\n * @param  {String} categoryName name of category to log to.\n * @return {Logger} instance of logger for the category\n * @static\n */\nfunction getLogger (categoryName) {\n\n  // Use default logger if categoryName is not specified or invalid\n  if (typeof categoryName !== \"string\") {\n    categoryName = Logger.DEFAULT_CATEGORY;\n  }\n\n  var appenderList;\n  if (!loggers[categoryName]) {\n    // Create the logger for this name if it doesn't already exist\n    loggers[categoryName] = new Logger(categoryName);\n    if (appenders[categoryName]) {\n      appenderList = appenders[categoryName];\n      appenderList.forEach(function(appender) {\n        loggers[categoryName].addListener(\"log\", appender);\n      });\n    }\n    if (appenders[ALL_CATEGORIES]) {\n      appenderList = appenders[ALL_CATEGORIES];\n      appenderList.forEach(function(appender) {\n        loggers[categoryName].addListener(\"log\", appender);\n      });\n    }\n  }\n  \n  return loggers[categoryName];\n}\n\n/**\n * args are appender, then zero or more categories\n */\nfunction addAppender () {\n  var args = Array.prototype.slice.call(arguments);\n  var appender = args.shift();\n  if (args.length === 0 || args[0] === undefined) {\n    args = [ ALL_CATEGORIES ];\n  }\n  //argument may already be an array\n  if (Array.isArray(args[0])) {\n    args = args[0];\n  }\n  \n  args.forEach(function(category) {\n    addAppenderToCategory(appender, category);\n    \n    if (category === ALL_CATEGORIES) {\n      addAppenderToAllLoggers(appender);\n    } else if (loggers[category]) {\n      loggers[category].addListener(\"log\", appender);\n    }\n  });\n}\n\nfunction addAppenderToAllLoggers(appender) {\n  for (var logger in loggers) {\n    if (loggers.hasOwnProperty(logger)) {\n      loggers[logger].addListener(\"log\", appender);\n    }\n  }\n}\n\nfunction addAppenderToCategory(appender, category) {\n  if (!appenders[category]) {\n    appenders[category] = [];\n  }\n  appenders[category].push(appender);\n}\n\nfunction clearAppenders () {\n  appenders = {};\n  for (var logger in loggers) {\n    if (loggers.hasOwnProperty(logger)) {\n      loggers[logger].removeAllListeners(\"log\");\n    }\n  }\n}\n\nfunction configureAppenders(appenderList, options) {\n  clearAppenders();\n  if (appenderList) {\n    appenderList.forEach(function(appenderConfig) {\n      loadAppender(appenderConfig.type);\n      var appender;\n      appenderConfig.makers = appenderMakers;\n      try {\n        appender = appenderMakers[appenderConfig.type](appenderConfig, options);\n        addAppender(appender, appenderConfig.category);\n      } catch(e) {\n        throw new Error(\"log4js configuration problem for \" + util.inspect(appenderConfig), e);\n      }\n    });\n  }\n}\n\nfunction configureLevels(levels) {\n  if (levels) {\n    for (var category in levels) {\n      if (levels.hasOwnProperty(category)) {\n        getLogger(category).setLevel(levels[category]);\n      }\n    }\n  }\n}\n\nfunction setGlobalLogLevel(level) {\n  Logger.prototype.level = levels.toLevel(level, levels.TRACE);\n}\n\n/**\n * Get the default logger instance.\n * @return {Logger} instance of default logger\n * @static\n */\nfunction getDefaultLogger () {\n  return getLogger(Logger.DEFAULT_CATEGORY);\n}\n\nvar configState = {};\n\nfunction loadConfigurationFile(filename) {\n  if (filename) {\n    return JSON.parse(fs.readFileSync(filename, \"utf8\"));\n  }\n  return undefined;\n}\n\nfunction configureOnceOff(config, options) {\n  if (config) {\n    try {\n      configureAppenders(config.appenders, options);\n      configureLevels(config.levels);\n      \n      if (config.replaceConsole) {\n        replaceConsole();\n      } else {\n        restoreConsole();\n      }\n    } catch (e) {\n      throw new Error(\n        \"Problem reading log4js config \" + util.inspect(config) + \n          \". Error was \\\"\" + e.message + \"\\\" (\" + e.stack + \")\"\n      );\n    }\n  }\n}\n\nfunction reloadConfiguration() {\n  var mtime = getMTime(configState.filename);\n  if (!mtime) return;\n\n  if (configState.lastMTime && (mtime.getTime() > configState.lastMTime.getTime())) {\n    configureOnceOff(loadConfigurationFile(configState.filename));\n  }\n  configState.lastMTime = mtime;\n}\n\nfunction getMTime(filename) {\n  var mtime;\n  try {\n    mtime = fs.statSync(configState.filename).mtime;\n  } catch (e) {\n    getLogger('log4js').warn('Failed to load configuration file ' + filename);\n  }\n  return mtime;\n}\n\nfunction initReloadConfiguration(filename, options) {\n  if (configState.timerId) {\n    clearInterval(configState.timerId);\n    delete configState.timerId;\n  }\n  configState.filename = filename;\n  configState.lastMTime = getMTime(filename);\n  configState.timerId = setInterval(reloadConfiguration, options.reloadSecs*1000);\n}\n\nfunction configure(configurationFileOrObject, options) {\n  var config = configurationFileOrObject;\n  config = config || process.env.LOG4JS_CONFIG;\n  options = options || {};\n  \n  if (config === undefined || config === null || typeof(config) === 'string') {\n    if (options.reloadSecs) {\n      initReloadConfiguration(config, options);\n    }\n    config = loadConfigurationFile(config) || defaultConfig;\n  } else {\n    if (options.reloadSecs) {\n      getLogger('log4js').warn(\n        'Ignoring configuration reload parameter for \"object\" configuration.'\n      );\n    }\n  }\n  configureOnceOff(config, options);\n}\n\nvar originalConsoleFunctions = {\n  log: console.log,\n  debug: console.debug,\n  info: console.info,\n  warn: console.warn,\n  error: console.error\n};\n\nfunction replaceConsole(logger) {\n  function replaceWith(fn) {\n    return function() {\n      fn.apply(logger, arguments);\n    };\n  }\n  logger = logger || getLogger(\"console\");\n  ['log','debug','info','warn','error'].forEach(function (item) {\n    console[item] = replaceWith(item === 'log' ? logger.info : logger[item]);\n  });\n}\n\nfunction restoreConsole() {\n  ['log', 'debug', 'info', 'warn', 'error'].forEach(function (item) {\n    console[item] = originalConsoleFunctions[item];\n  });\n}\n\nfunction loadAppender(appender) {\n  var appenderModule;\n  try {\n    appenderModule = require('./appenders/' + appender);\n  } catch (e) {\n    appenderModule = require(appender);\n  }\n  module.exports.appenders[appender] = appenderModule.appender.bind(appenderModule);\n  appenderMakers[appender] = appenderModule.configure.bind(appenderModule);\n}\n\nmodule.exports = {\n  getLogger: getLogger,\n  getDefaultLogger: getDefaultLogger,\n  \n  addAppender: addAppender,\n  loadAppender: loadAppender,\n  clearAppenders: clearAppenders,\n  configure: configure,\n  \n  replaceConsole: replaceConsole,\n  restoreConsole: restoreConsole,\n  \n  levels: levels,\n  setGlobalLogLevel: setGlobalLogLevel,\n  \n  layouts: layouts,\n  appenders: {},\n  appenderMakers: appenderMakers,\n  connectLogger: require('./connect-logger').connectLogger\n};\n\n//set ourselves up\nconfigure();\n\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-scheduler/node_modules/log4js/lib/layouts.js":"\"use strict\";\nvar dateFormat = require('./date_format')\n, os = require('os')\n, eol = os.EOL || '\\n'\n, util = require('util')\n, replacementRegExp = /%[sdj]/g\n, layoutMakers = {\n  \"messagePassThrough\": function() { return messagePassThroughLayout; }, \n  \"basic\": function() { return basicLayout; }, \n  \"colored\": function() { return colouredLayout; }, \n  \"coloured\": function() { return colouredLayout; }, \n  \"pattern\": function (config) {\n    return patternLayout(config && config.pattern, config && config.tokens);\n\t}\n}\n, colours = {\n  ALL: \"grey\", \n  TRACE: \"blue\", \n  DEBUG: \"cyan\", \n  INFO: \"green\", \n  WARN: \"yellow\", \n  ERROR: \"red\", \n  FATAL: \"magenta\", \n  OFF: \"grey\"\n};\n\nfunction wrapErrorsWithInspect(items) {\n  return items.map(function(item) {\n    if ((item instanceof Error) && item.stack) {\n      return { inspect: function() { return util.format(item) + '\\n' + item.stack; } };\n    } else {\n      return item;\n    }\n  });\n}\n\nfunction formatLogData(logData) {\n  var data = Array.isArray(logData) ? logData : Array.prototype.slice.call(arguments);\n  return util.format.apply(util, wrapErrorsWithInspect(data));\n}\n\nvar styles = {\n    //styles\n  'bold'      : [1,  22],\n  'italic'    : [3,  23],\n  'underline' : [4,  24],\n  'inverse'   : [7,  27],\n  //grayscale\n  'white'     : [37, 39],\n  'grey'      : [90, 39],\n  'black'     : [90, 39],\n  //colors\n  'blue'      : [34, 39],\n  'cyan'      : [36, 39],\n  'green'     : [32, 39],\n  'magenta'   : [35, 39],\n  'red'       : [31, 39],\n  'yellow'    : [33, 39]\n};\n\nfunction colorizeStart(style) {\n  return style ? '\\x1B[' + styles[style][0] + 'm' : '';\n}\nfunction colorizeEnd(style) {\n  return style ? '\\x1B[' + styles[style][1] + 'm' : '';\n}\n/**\n * Taken from masylum's fork (https://github.com/masylum/log4js-node)\n */\nfunction colorize (str, style) {\n  return colorizeStart(style) + str + colorizeEnd(style);\n}\n\nfunction timestampLevelAndCategory(loggingEvent, colour) {\n  var output = colorize(\n    formatLogData(\n      '[%s] [%s] %s - '\n      , dateFormat.asString(loggingEvent.startTime)\n      , loggingEvent.level\n      , loggingEvent.categoryName\n    )\n    , colour\n  );\n  return output;\n}\n\n/**\n * BasicLayout is a simple layout for storing the logs. The logs are stored\n * in following format:\n * <pre>\n * [startTime] [logLevel] categoryName - message\\n\n * </pre>\n *\n * @author Stephan Strittmatter\n */\nfunction basicLayout (loggingEvent) {\n  return timestampLevelAndCategory(loggingEvent) + formatLogData(loggingEvent.data);\n}\n\n/**\n * colouredLayout - taken from masylum's fork.\n * same as basicLayout, but with colours.\n */\nfunction colouredLayout (loggingEvent) {\n  return timestampLevelAndCategory(\n    loggingEvent,\n    colours[loggingEvent.level.toString()]\n  ) + formatLogData(loggingEvent.data);\n}\n\nfunction messagePassThroughLayout (loggingEvent) {\n  return formatLogData(loggingEvent.data);\n}\n\n/**\n * PatternLayout\n * Format for specifiers is %[padding].[truncation][field]{[format]}\n * e.g. %5.10p - left pad the log level by 5 characters, up to a max of 10\n * Fields can be any of:\n *  - %r time in toLocaleTimeString format\n *  - %p log level\n *  - %c log category\n *  - %m log data\n *  - %d date in various formats\n *  - %% %\n *  - %n newline\n *  - %x{<tokenname>} add dynamic tokens to your log. Tokens are specified in the tokens parameter\n * You can use %[ and %] to define a colored block.\n *\n * Tokens are specified as simple key:value objects. \n * The key represents the token name whereas the value can be a string or function\n * which is called to extract the value to put in the log message. If token is not\n * found, it doesn't replace the field.\n *\n * A sample token would be: { \"pid\" : function() { return process.pid; } }\n *\n * Takes a pattern string, array of tokens and returns a layout function.\n * @param {String} Log format pattern String\n * @param {object} map object of different tokens\n * @return {Function}\n * @author Stephan Strittmatter\n * @author Jan Schmidle\n */\nfunction patternLayout (pattern, tokens) {\n  var TTCC_CONVERSION_PATTERN  = \"%r %p %c - %m%n\";\n  var regex = /%(-?[0-9]+)?(\\.?[0-9]+)?([\\[\\]cdmnprx%])(\\{([^\\}]+)\\})?|([^%]+)/;\n  \n  pattern = pattern || TTCC_CONVERSION_PATTERN;\n\n  function categoryName(loggingEvent, specifier) {\n    var loggerName = loggingEvent.categoryName;\n    if (specifier) {\n      var precision = parseInt(specifier, 10);\n      var loggerNameBits = loggerName.split(\".\");\n      if (precision < loggerNameBits.length) {\n        loggerName = loggerNameBits.slice(loggerNameBits.length - precision).join(\".\");\n      }\n    }\n    return loggerName;\n  }\n\n  function formatAsDate(loggingEvent, specifier) {\n    var format = dateFormat.ISO8601_FORMAT;\n    if (specifier) {\n      format = specifier;\n      // Pick up special cases\n      if (format == \"ISO8601\") {\n        format = dateFormat.ISO8601_FORMAT;\n      } else if (format == \"ABSOLUTE\") {\n        format = dateFormat.ABSOLUTETIME_FORMAT;\n      } else if (format == \"DATE\") {\n        format = dateFormat.DATETIME_FORMAT;\n      }\n    }\n    // Format the date\n    return dateFormat.asString(format, loggingEvent.startTime);\n  }\n\n  function formatMessage(loggingEvent) {\n    return formatLogData(loggingEvent.data);\n  }\n  \n  function endOfLine() {\n    return eol;\n  }\n\n  function logLevel(loggingEvent) {\n    return loggingEvent.level.toString();\n  }\n\n  function startTime(loggingEvent) {\n    return \"\" + loggingEvent.startTime.toLocaleTimeString();\n  }\n\n  function startColour(loggingEvent) {\n    return colorizeStart(colours[loggingEvent.level.toString()]);\n  }\n\n  function endColour(loggingEvent) {\n    return colorizeEnd(colours[loggingEvent.level.toString()]);\n  }\n\n  function percent() {\n    return '%';\n  }\n\n  function userDefined(loggingEvent, specifier) {\n    if (typeof(tokens[specifier]) !== 'undefined') {\n      if (typeof(tokens[specifier]) === 'function') {\n        return tokens[specifier](loggingEvent);\n      } else {\n        return tokens[specifier];\n      }\n    }\n    return null;\n  }\n\n  var replacers = {\n    'c': categoryName,\n    'd': formatAsDate,\n    'm': formatMessage,\n    'n': endOfLine,\n    'p': logLevel,\n    'r': startTime,\n    '[': startColour,\n    ']': endColour,\n    '%': percent,\n    'x': userDefined\n  };\n\n  function replaceToken(conversionCharacter, loggingEvent, specifier) {\n    return replacers[conversionCharacter](loggingEvent, specifier);\n  }\n\n  function truncate(truncation, toTruncate) {\n    var len;\n    if (truncation) {\n      len = parseInt(truncation.substr(1), 10);\n      return toTruncate.substring(0, len);\n    }\n\n    return toTruncate;\n  }\n\n  function pad(padding, toPad) {\n    var len;\n    if (padding) {\n      if (padding.charAt(0) == \"-\") {\n        len = parseInt(padding.substr(1), 10);\n        // Right pad with spaces\n        while (toPad.length < len) {\n          toPad += \" \";\n        }\n      } else {\n        len = parseInt(padding, 10);\n        // Left pad with spaces\n        while (toPad.length < len) {\n          toPad = \" \" + toPad;\n        }\n      }\n    }\n    return toPad;\n  }\n  \n  return function(loggingEvent) {\n    var formattedString = \"\";\n    var result;\n    var searchString = pattern;\n    \n    while ((result = regex.exec(searchString))) {\n      var matchedString = result[0];\n      var padding = result[1];\n      var truncation = result[2];\n      var conversionCharacter = result[3];\n      var specifier = result[5];\n      var text = result[6];\n      \n      // Check if the pattern matched was just normal text\n      if (text) {\n        formattedString += \"\" + text;\n      } else {\n        // Create a raw replacement string based on the conversion\n        // character and specifier\n        var replacement = \n          replaceToken(conversionCharacter, loggingEvent, specifier) || \n          matchedString;\n\n        // Format the replacement according to any padding or\n        // truncation specified\n        replacement = truncate(truncation, replacement);\n        replacement = pad(padding, replacement);\n        formattedString += replacement;\n      }\n      searchString = searchString.substr(result.index + result[0].length);\n    }\n    return formattedString;\n  };\n\n}\n\nmodule.exports = {\n  basicLayout: basicLayout, \n  messagePassThroughLayout: messagePassThroughLayout, \n  patternLayout: patternLayout, \n  colouredLayout: colouredLayout, \n  coloredLayout: colouredLayout, \n  layout: function(name, config) {\n    return layoutMakers[name] && layoutMakers[name](config);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-scheduler/node_modules/log4js/lib/date_format.js":"\"use strict\";\nexports.ISO8601_FORMAT = \"yyyy-MM-dd hh:mm:ss.SSS\";\nexports.ISO8601_WITH_TZ_OFFSET_FORMAT = \"yyyy-MM-ddThh:mm:ssO\";\nexports.DATETIME_FORMAT = \"dd MM yyyy hh:mm:ss.SSS\";\nexports.ABSOLUTETIME_FORMAT = \"hh:mm:ss.SSS\";\n\nfunction padWithZeros(vNumber, width) {\n  var numAsString = vNumber + \"\";\n  while (numAsString.length < width) {\n    numAsString = \"0\" + numAsString;\n  }\n  return numAsString;\n}\n  \nfunction addZero(vNumber) {\n  return padWithZeros(vNumber, 2);\n}\n\n/**\n * Formats the TimeOffest\n * Thanks to http://www.svendtofte.com/code/date_format/\n * @private\n */\nfunction offset(date) {\n  // Difference to Greenwich time (GMT) in hours\n  var os = Math.abs(date.getTimezoneOffset());\n  var h = String(Math.floor(os/60));\n  var m = String(os%60);\n  if (h.length == 1) {\n    h = \"0\" + h;\n  }\n  if (m.length == 1) {\n    m = \"0\" + m;\n  }\n  return date.getTimezoneOffset() < 0 ? \"+\"+h+m : \"-\"+h+m;\n}\n\nexports.asString = function(/*format,*/ date) {\n  var format = exports.ISO8601_FORMAT;\n  if (typeof(date) === \"string\") {\n    format = arguments[0];\n    date = arguments[1];\n  }\n\n  var vDay = addZero(date.getDate());\n  var vMonth = addZero(date.getMonth()+1);\n  var vYearLong = addZero(date.getFullYear());\n  var vYearShort = addZero(date.getFullYear().toString().substring(3,4));\n  var vYear = (format.indexOf(\"yyyy\") > -1 ? vYearLong : vYearShort);\n  var vHour  = addZero(date.getHours());\n  var vMinute = addZero(date.getMinutes());\n  var vSecond = addZero(date.getSeconds());\n  var vMillisecond = padWithZeros(date.getMilliseconds(), 3);\n  var vTimeZone = offset(date);\n  var formatted = format\n    .replace(/dd/g, vDay)\n    .replace(/MM/g, vMonth)\n    .replace(/y{1,4}/g, vYear)\n    .replace(/hh/g, vHour)\n    .replace(/mm/g, vMinute)\n    .replace(/ss/g, vSecond)\n    .replace(/SSS/g, vMillisecond)\n    .replace(/O/g, vTimeZone);\n  return formatted;\n\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-scheduler/node_modules/log4js/lib/levels.js":"\"use strict\";\n\nfunction Level(level, levelStr) {\n  this.level = level;\n  this.levelStr = levelStr;\n}\n\n/**\n * converts given String to corresponding Level\n * @param {String} sArg String value of Level OR Log4js.Level\n * @param {Log4js.Level} defaultLevel default Level, if no String representation\n * @return Level object\n * @type Log4js.Level\n */\nfunction toLevel(sArg, defaultLevel) {\n\n  if (!sArg) {\n    return defaultLevel;\n  }\n\n  if (typeof sArg == \"string\") {\n    var s = sArg.toUpperCase();\n    if (module.exports[s]) {\n      return module.exports[s];\n    } else {\n      return defaultLevel;\n    }\n  }\n\n  return toLevel(sArg.toString());\n}\n\nLevel.prototype.toString = function() {\n  return this.levelStr;\n};\n\nLevel.prototype.isLessThanOrEqualTo = function(otherLevel) {\n  if (typeof otherLevel === \"string\") {\n    otherLevel = toLevel(otherLevel);\n  }\n  return this.level <= otherLevel.level;\n};\n\nLevel.prototype.isGreaterThanOrEqualTo = function(otherLevel) {\n  if (typeof otherLevel === \"string\") {\n    otherLevel = toLevel(otherLevel);\n  }\n  return this.level >= otherLevel.level;\n};\n\nLevel.prototype.isEqualTo = function(otherLevel) {\n  if (typeof otherLevel == \"string\") {\n    otherLevel = toLevel(otherLevel);\n  }\n  return this.level === otherLevel.level;\n};\n\nmodule.exports = {\n  ALL: new Level(Number.MIN_VALUE, \"ALL\"), \n  TRACE: new Level(5000, \"TRACE\"), \n  DEBUG: new Level(10000, \"DEBUG\"), \n  INFO: new Level(20000, \"INFO\"), \n  WARN: new Level(30000, \"WARN\"), \n  ERROR: new Level(40000, \"ERROR\"), \n  FATAL: new Level(50000, \"FATAL\"), \n  OFF: new Level(Number.MAX_VALUE, \"OFF\"), \n  toLevel: toLevel\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-scheduler/node_modules/log4js/lib/logger.js":"\"use strict\";\nvar levels = require('./levels')\n, util = require('util')\n, events = require('events')\n, DEFAULT_CATEGORY = '[default]';\n\n/**\n * Models a logging event.\n * @constructor\n * @param {String} categoryName name of category\n * @param {Log4js.Level} level level of message\n * @param {Array} data objects to log\n * @param {Log4js.Logger} logger the associated logger\n * @author Seth Chisamore\n */\nfunction LoggingEvent (categoryName, level, data, logger) {\n  this.startTime = new Date();\n  this.categoryName = categoryName;\n  this.data = data;\n  this.level = level;\n  this.logger = logger;\n}\n\n/**\n * Logger to log messages.\n * use {@see Log4js#getLogger(String)} to get an instance.\n * @constructor\n * @param name name of category to log to\n * @author Stephan Strittmatter\n */\nfunction Logger (name, level) {\n  this.category = name || DEFAULT_CATEGORY;\n  \n  if (level) {\n    this.setLevel(level);\n  }\n}\nutil.inherits(Logger, events.EventEmitter);\nLogger.DEFAULT_CATEGORY = DEFAULT_CATEGORY;\nLogger.prototype.level = levels.TRACE;\n\nLogger.prototype.setLevel = function(level) {\n  this.level = levels.toLevel(level, this.level || levels.TRACE);\n};\n\nLogger.prototype.removeLevel = function() {\n  delete this.level;\n};\n\nLogger.prototype.log = function() {\n  var args = Array.prototype.slice.call(arguments)\n  , logLevel = args.shift()\n  , loggingEvent = new LoggingEvent(this.category, logLevel, args, this);\n  this.emit(\"log\", loggingEvent);\n};\n\nLogger.prototype.isLevelEnabled = function(otherLevel) {\n  return this.level.isLessThanOrEqualTo(otherLevel);\n};\n\n['Trace','Debug','Info','Warn','Error','Fatal'].forEach(\n  function(levelString) {\n    var level = levels.toLevel(levelString);\n    Logger.prototype['is'+levelString+'Enabled'] = function() {\n      return this.isLevelEnabled(level);\n    };\n    \n    Logger.prototype[levelString.toLowerCase()] = function () {\n      if (this.isLevelEnabled(level)) {\n        var args = Array.prototype.slice.call(arguments);\n        args.unshift(level);\n        Logger.prototype.log.apply(this, args);\n      }\n    };\n  }\n);\n\n\nexports.LoggingEvent = LoggingEvent;\nexports.Logger = Logger;\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-scheduler/node_modules/log4js/lib/connect-logger.js":"\"use strict\";\nvar levels = require(\"./levels\");\nvar DEFAULT_FORMAT = ':remote-addr - -' + \n  ' \":method :url HTTP/:http-version\"' + \n  ' :status :content-length \":referrer\"' + \n  ' \":user-agent\"';\n/**\n * Log requests with the given `options` or a `format` string.\n *\n * Options:\n *\n *   - `format`        Format string, see below for tokens\n *   - `level`         A log4js levels instance. Supports also 'auto'\n *\n * Tokens:\n *\n *   - `:req[header]` ex: `:req[Accept]`\n *   - `:res[header]` ex: `:res[Content-Length]`\n *   - `:http-version`\n *   - `:response-time`\n *   - `:remote-addr`\n *   - `:date`\n *   - `:method`\n *   - `:url`\n *   - `:referrer`\n *   - `:user-agent`\n *   - `:status`\n *\n * @param {String|Function|Object} format or options\n * @return {Function}\n * @api public\n */\n\nfunction getLogger(logger4js, options) {\n\tif ('object' == typeof options) {\n\t\toptions = options || {};\n\t} else if (options) {\n\t\toptions = { format: options };\n\t} else {\n\t\toptions = {};\n\t}\n\n\tvar thislogger = logger4js\n  , level = levels.toLevel(options.level, levels.INFO)\n  , fmt = options.format || DEFAULT_FORMAT\n  , nolog = options.nolog ? createNoLogCondition(options.nolog) : null;\n\n  return function (req, res, next) {\n    // mount safety\n    if (req._logging) return next();\n\n\t\t// nologs\n\t\tif (nolog && nolog.test(req.originalUrl)) return next();\n\t\tif (thislogger.isLevelEnabled(level) || options.level === 'auto') {\n      \n\t\t\tvar start = new Date()\n\t\t\t, statusCode\n\t\t\t, writeHead = res.writeHead\n\t\t\t, end = res.end\n\t\t\t, url = req.originalUrl;\n\n\t\t\t// flag as logging\n\t\t\treq._logging = true;\n      \n\t\t\t// proxy for statusCode.\n\t\t\tres.writeHead = function(code, headers){\n\t\t\t\tres.writeHead = writeHead;\n\t\t\t\tres.writeHead(code, headers);\n\t\t\t\tres.__statusCode = statusCode = code;\n\t\t\t\tres.__headers = headers || {};\n\n\t\t\t\t//status code response level handling\n\t\t\t\tif(options.level === 'auto'){\n\t\t\t\t\tlevel = levels.INFO;\n\t\t\t\t\tif(code >= 300) level = levels.WARN;\n\t\t\t\t\tif(code >= 400) level = levels.ERROR;\n\t\t\t\t} else {\n\t\t\t\t\tlevel = levels.toLevel(options.level, levels.INFO);\n\t\t\t\t}\n\t\t\t};\n      \n\t\t\t// proxy end to output a line to the provided logger.\n\t\t\tres.end = function(chunk, encoding) {\n\t\t\t\tres.end = end;\n\t\t\t\tres.end(chunk, encoding);\n\t\t\t\tres.responseTime = new Date() - start;\n\t\t\t\tif (thislogger.isLevelEnabled(level)) {\n\t\t\t\t\tif (typeof fmt === 'function') {\n\t\t\t\t\t\tvar line = fmt(req, res, function(str){ return format(str, req, res); });\n\t\t\t\t\t\tif (line) thislogger.log(level, line);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthislogger.log(level, format(fmt, req, res));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n    \n    //ensure next gets always called\n    next();\n  };\n}\n\n/**\n * Return formatted log line.\n *\n * @param  {String} str\n * @param  {IncomingMessage} req\n * @param  {ServerResponse} res\n * @return {String}\n * @api private\n */\n\nfunction format(str, req, res) {\n\treturn str\n    .replace(':url', req.originalUrl)\n    .replace(':method', req.method)\n    .replace(':status', res.__statusCode || res.statusCode)\n    .replace(':response-time', res.responseTime)\n    .replace(':date', new Date().toUTCString())\n    .replace(':referrer', req.headers.referer || req.headers.referrer || '')\n    .replace(':http-version', req.httpVersionMajor + '.' + req.httpVersionMinor)\n    .replace(\n      ':remote-addr', \n      req.socket && \n        (req.socket.remoteAddress || (req.socket.socket && req.socket.socket.remoteAddress))\n    )\n    .replace(':user-agent', req.headers['user-agent'] || '')\n    .replace(\n      ':content-length', \n      (res._headers && res._headers['content-length']) || \n        (res.__headers && res.__headers['Content-Length']) || \n        '-'\n    )\n    .replace(/:req\\[([^\\]]+)\\]/g, function(_, field){ return req.headers[field.toLowerCase()]; })\n    .replace(/:res\\[([^\\]]+)\\]/g, function(_, field){\n      return res._headers ? \n        (res._headers[field.toLowerCase()] || res.__headers[field])\n        : (res.__headers && res.__headers[field]);\n    });\n}\n\n/**\n * Return RegExp Object about nolog\n *\n * @param  {String} nolog\n * @return {RegExp}\n * @api private\n *\n * syntax\n *  1. String\n *   1.1 \"\\\\.gif\"\n *         NOT LOGGING http://example.com/hoge.gif and http://example.com/hoge.gif?fuga\n *         LOGGING http://example.com/hoge.agif\n *   1.2 in \"\\\\.gif|\\\\.jpg$\"\n *         NOT LOGGING http://example.com/hoge.gif and \n *           http://example.com/hoge.gif?fuga and http://example.com/hoge.jpg?fuga\n *         LOGGING http://example.com/hoge.agif, \n *           http://example.com/hoge.ajpg and http://example.com/hoge.jpg?hoge\n *   1.3 in \"\\\\.(gif|jpe?g|png)$\"\n *         NOT LOGGING http://example.com/hoge.gif and http://example.com/hoge.jpeg\n *         LOGGING http://example.com/hoge.gif?uid=2 and http://example.com/hoge.jpg?pid=3\n *  2. RegExp\n *   2.1 in /\\.(gif|jpe?g|png)$/\n *         SAME AS 1.3\n *  3. Array\n *   3.1 [\"\\\\.jpg$\", \"\\\\.png\", \"\\\\.gif\"]\n *         SAME AS \"\\\\.jpg|\\\\.png|\\\\.gif\"\n */\nfunction createNoLogCondition(nolog) {\n  var regexp = null;\n\n\tif (nolog) {\n    if (nolog instanceof RegExp) {\n      regexp = nolog;\n    } \n    \n    if (typeof nolog === 'string') {\n      regexp = new RegExp(nolog);\n    }\n    \n    if (Array.isArray(nolog)) {\n      var regexpsAsStrings = nolog.map(\n        function convertToStrings(o) { \n          return o.source ? o.source : o;\n        }\n      );\n      regexp = new RegExp(regexpsAsStrings.join('|'));\n    }\n  }\n\n  return regexp;\n}\n\nexports.connectLogger = getLogger;\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-scheduler/node_modules/log4js/lib/appenders/console.js":"\"use strict\";\nvar layouts = require('../layouts')\n, consoleLog = console.log.bind(console);\n\nfunction consoleAppender (layout) {\n  layout = layout || layouts.colouredLayout;\n  return function(loggingEvent) {\n    consoleLog(layout(loggingEvent));\n  };\n}\n\nfunction configure(config) {\n  var layout;\n  if (config.layout) {\n    layout = layouts.layout(config.layout.type, config.layout);\n  }\n  return consoleAppender(layout);\n}\n\nexports.appender = consoleAppender;\nexports.configure = configure;\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-scheduler/lib/simpleTrigger.js":"/**\n * This is the tirgger that use an object as trigger.\n */\nvar SKIP_OLD_JOB = false;\n\n/**\n * The constructor of simple trigger\n */\nvar SimpleTrigger = function(trigger, job){\n  this.nextTime = (!!trigger.start)?trigger.start:Date.now();\n\n  //The rec\n  this.period = (!!trigger.period)?trigger.period:-1;\n\n  //The running count of the job, -1 means no limit\n  this.count = (!!trigger.count)?trigger.count:-1;\n\n  this.job = job;\n};\n\nvar pro = SimpleTrigger.prototype;\n\n/**\n * Get the current excuteTime of rigger\n */\npro.excuteTime = function(){\n  return this.nextTime;\n};\n\n/**\n * Get the next excuteTime of the trigger, and set the trigger's excuteTime\n * @return Next excute time\n */\npro.nextExcuteTime = function(){\n  var period = this.period;\n\n  if((this.count > 0 && this.count <= this.job.runTime) || period <= 0)\n    return null;\n\n  this.nextTime += period;\n\n  if(SKIP_OLD_JOB && this.nextTime < Date.now()){\n    this.nextTime += Math.floor((Date.now()-this.nextTime)/period) * period;\n  }\n\n  return this.nextTime;\n};\n\n/**\n * Create Simple trigger\n */\nfunction createTrigger(trigger, job){\n  return new SimpleTrigger(trigger, job);\n}\n\nmodule.exports.createTrigger = createTrigger;","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/common/service/filterService.js":"var logger = require('pomelo-logger').getLogger('pomelo', __filename);\n\n/**\n * Filter service.\n * Register and fire before and after filters.\n */\nvar Service = function() {\n  this.befores = [];    // before filters\n  this.afters = [];     // after filters\n};\n\nmodule.exports = Service;\n\nService.prototype.name = 'filter';\n\n/**\n * Add before filter into the filter chain.\n *\n * @param filter {Object|Function} filter instance or filter function.\n */\nService.prototype.before = function(filter){\n  this.befores.push(filter);\n};\n\n/**\n * Add after filter into the filter chain.\n *\n * @param filter {Object|Function} filter instance or filter function.\n */\nService.prototype.after = function(filter){\n  this.afters.unshift(filter);\n};\n\n/**\n * TODO: other insert method for filter? such as unshift\n */\n\n/**\n * Do the before filter.\n * Fail over if any filter pass err parameter to the next function.\n *\n * @param msg {Object} clienet request msg\n * @param session {Object} a session object for current request\n * @param cb {Function} cb(err) callback function to invoke next chain node\n */\nService.prototype.beforeFilter = function(msg, session, cb) {\n  var index = 0, self = this;\n  var next = function(err, resp, opts) {\n    if(err || index >= self.befores.length) {\n      cb(err, resp, opts);\n      return;\n    }\n\n    var handler = self.befores[index++];\n    if(typeof handler === 'function') {\n      handler(msg, session, next);\n    } else if(typeof handler.before === 'function') {\n      handler.before(msg, session, next);\n    } else {\n      logger.error('meet invalid before filter, handler or handler.before should be function.');\n      next(new Error('invalid before filter.'));\n    }\n  }; //end of next\n\n  next();\n};\n\n/**\n * Do after filter chain.\n * Give server a chance to do clean up jobs after request responsed.\n * After filter can not change the request flow before.\n * After filter should call the next callback to let the request pass to next after filter.\n *\n * @param err {Object} error object\n * @param session {Object} session object for current request\n * @param {Object} resp response object send to client\n * @param cb {Function} cb(err) callback function to invoke next chain node\n */\nService.prototype.afterFilter = function(err, msg, session, resp, cb) {\n  var index = 0, self = this;\n  function next(err) {\n    //if done\n    if(index >= self.afters.length) {\n      cb(err);\n      return;\n    }\n\n    var handler = self.afters[index++];\n    if(typeof handler === 'function') {\n      handler(err, msg, session, resp, next);\n    } else if(typeof handler.after === 'function') {\n      handler.after(err, msg, session, resp, next);\n    } else {\n      logger.error('meet invalid after filter, handler or handler.after should be function.');\n      next(new Error('invalid after filter.'));\n    }\n  } //end of next\n\n  next(err);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/common/service/handlerService.js":"var fs = require('fs');\nvar utils = require('../../util/utils');\nvar Loader = require('pomelo-loader');\nvar pathUtil = require('../../util/pathUtil');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar forwardLogger = require('pomelo-logger').getLogger('forward-log', __filename);\n/**\n * Handler service.\n * Dispatch request to the relactive handler.\n *\n * @param {Object} app      current application context\n */\nvar Service = function(app, opts) {\n  this.app = app;\n  this.handlerMap = {};\n  if(!!opts.reloadHandlers) {\n    watchHandlers(app, this.handlerMap);\n  }\n\n  this.enableForwardLog = opts.enableForwardLog || false;\n};\n\nmodule.exports = Service;\n\nService.prototype.name = 'handler';\n\n/**\n * Handler the request.\n */\nService.prototype.handle = function(routeRecord, msg, session, cb) {\n  // the request should be processed by current server\n  var handler = this.getHandler(routeRecord);\n  if(!handler) {\n    logger.error('[handleManager]: fail to find handler for %j', msg.__route__);\n    utils.invokeCallback(cb, new Error('fail to find handler for ' + msg.__route__));\n    return;\n  }\n  var start = Date.now();\n  var self = this;\n\n  var callback = function(err, resp, opts) {\n    if(self.enableForwardLog) {\n      var log = {\n        route : msg.__route__,\n        args : msg,\n        time : utils.format(new Date(start)),\n        timeUsed : new Date() - start\n      };\n      forwardLogger.info(JSON.stringify(log));\n    }\n\n    // resp = getResp(arguments);\n    utils.invokeCallback(cb, err, resp, opts);\n  }\n\n  var method = routeRecord.method;\n\n  if(!Array.isArray(msg)) {\n    handler[method](msg, session, callback);\n  } else {\n    msg.push(session);\n    msg.push(callback);\n    handler[method].apply(handler, msg);\n  }\n  return;\n};\n\n/**\n * Get handler instance by routeRecord.\n *\n * @param  {Object} handlers    handler map\n * @param  {Object} routeRecord route record parsed from route string\n * @return {Object}             handler instance if any matchs or null for match fail\n */\nService.prototype.getHandler = function(routeRecord) {\n  var serverType = routeRecord.serverType;\n  if(!this.handlerMap[serverType]) {\n    loadHandlers(this.app, serverType, this.handlerMap);\n  }\n  var handlers = this.handlerMap[serverType] || {};\n  var handler = handlers[routeRecord.handler];\n  if(!handler) {\n    logger.warn('could not find handler for routeRecord: %j', routeRecord);\n    return null;\n  }\n  if(typeof handler[routeRecord.method] !== 'function') {\n    logger.warn('could not find the method %s in handler: %s', routeRecord.method, routeRecord.handler);\n    return null;\n  }\n  return handler;\n};\n\n/**\n * Load handlers from current application\n */\nvar loadHandlers = function(app, serverType, handlerMap) {\n  var p = pathUtil.getHandlerPath(app.getBase(), serverType);\n  if(p) {\n    handlerMap[serverType] = Loader.load(p, app);\n  }\n};\n\nvar watchHandlers = function(app, handlerMap) {\n  var p = pathUtil.getHandlerPath(app.getBase(), app.serverType);\n  if (!!p){\n    fs.watch(p, function(event, name) {\n      if(event === 'change') {\n        handlerMap[app.serverType] = Loader.load(p, app);\n      }\n    });\n  }\n};\n\nvar getResp = function(args) {\n  var len = args.length;\n  if(len == 1) {\n    return [];\n  }\n\n  if(len == 2) {\n    return [args[1]];\n  }\n\n  if(len == 3) {\n    return [args[1], args[2]];\n  }\n\n  if(len == 4) {\n    return [args[1], args[2], args[3]];\n  }\n\n  var r = new Array(len);\n  for (var i = 1; i < len; i++) {\n    r[i] = args[i];\n  }\n\n  return r;\n}","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/components/session.js":"var SessionService = require('../common/service/sessionService');\n\nmodule.exports = function(app, opts) {\n  var cmp = new Component(app, opts);\n  app.set('sessionService', cmp, true);\n  return cmp;\n};\n\n/**\n * Session component. Manage sessions.\n *\n * @param {Object} app  current application context\n * @param {Object} opts attach parameters\n */\nvar Component = function(app, opts) {\n  opts = opts || {};\n  this.app = app;\n  this.service = new SessionService(opts);\n\n  var getFun = function(m) {\n    return (function() {\n          return function() {\n            return self.service[m].apply(self.service, arguments);\n          };\n    })();\n  };\n  // proxy the service methods except the lifecycle interfaces of component\n  var method, self = this;\n  for(var m in this.service) {\n    if(m !== 'start' && m !== 'stop') {\n      method = this.service[m];\n      if(typeof method === 'function') {\n        this[m] = getFun(m);\n      }\n    }\n  }\n};\n\nComponent.prototype.name = '__session__';\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/common/service/sessionService.js":"var EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar utils = require('../../util/utils');\n\nvar FRONTEND_SESSION_FIELDS = ['id', 'frontendId', 'uid', '__sessionService__'];\nvar EXPORTED_SESSION_FIELDS = ['id', 'frontendId', 'uid', 'settings'];\n\nvar ST_INITED = 0;\nvar ST_CLOSED = 1;\n\n/**\n * Session service maintains the internal session for each client connection.\n *\n * Session service is created by session component and is only\n * <b>available</b> in frontend servers. You can access the service by\n * `app.get('sessionService')` or `app.sessionService` in frontend servers.\n *\n * @param {Object} opts constructor parameters\n * @class\n * @constructor\n */\nvar SessionService = function(opts) {\n  opts = opts || {};\n  this.singleSession = opts.singleSession;\n  this.sessions = {};     // sid -> session\n  this.uidMap = {};       // uid -> sessions\n};\n\nmodule.exports = SessionService;\n\n/**\n * Create and return internal session.\n *\n * @param {Integer} sid uniqe id for the internal session \n * @param {String} frontendId frontend server in which the internal session is created \n * @param {Object} socket the underlying socket would be held by the internal session  \n *\n * @return {Session}\n *\n * @memberOf SessionService\n * @api private\n */\nSessionService.prototype.create = function(sid, frontendId, socket) {\n  var session = new Session(sid, frontendId, socket, this);\n  this.sessions[session.id] = session;\n\n  return session;\n};\n\n/**\n * Bind the session with a user id.\n *\n * @memberOf SessionService\n * @api private\n */\nSessionService.prototype.bind = function(sid, uid, cb) {\n  var session = this.sessions[sid];\n\n  if(!session) {\n    process.nextTick(function() {\n      cb(new Error('session does not exist, sid: ' + sid));\n    });\n    return;\n  }\n\n  if(session.uid) {\n    if(session.uid === uid) {\n      // already bound with the same uid\n      cb();\n      return;\n    }\n\n    // already bound with other uid\n    process.nextTick(function() {\n      cb(new Error('session has already bound with ' + session.uid));\n    });\n    return;\n  }\n\n  var sessions = this.uidMap[uid];\n\n  if(!!this.singleSession && !!sessions) {\n    process.nextTick(function() {\n      cb(new Error('singleSession is enabled, and session has already bound with uid: ' + uid));\n    });\n    return;\n  }\n\n  if(!sessions) {\n    sessions = this.uidMap[uid] = [];\n  }\n\n  for(var i=0, l=sessions.length; i<l; i++) {\n    // session has binded with the uid\n    if(sessions[i].id === session.id) {\n      process.nextTick(cb);\n      return;\n    }\n  }\n  sessions.push(session);\n\n  session.bind(uid);\n\n  if(cb) {\n    process.nextTick(cb);\n  }\n};\n\n/**\n * Unbind a session with the user id.\n *\n * @memberOf SessionService\n * @api private\n */\nSessionService.prototype.unbind = function(sid, uid, cb) {\n  var session = this.sessions[sid];\n\n  if(!session) {\n    process.nextTick(function() {\n      cb(new Error('session does not exist, sid: ' + sid));\n    });\n    return;\n  }\n\n  if(!session.uid || session.uid !== uid) {\n    process.nextTick(function() {\n      cb(new Error('session has not bind with ' + session.uid));\n    });\n    return;\n  }\n\n  var sessions = this.uidMap[uid], sess;\n  if(sessions) {\n    for(var i=0, l=sessions.length; i<l; i++) {\n      sess = sessions[i];\n      if(sess.id === sid) {\n        sessions.splice(i, 1);\n        break;\n      }\n    }\n\n    if(sessions.length === 0) {\n      delete this.uidMap[uid];\n    }\n  }\n  session.unbind(uid);\n\n  if(cb) {\n    process.nextTick(cb);\n  }\n};\n\n/**\n * Get session by id.\n *\n * @param {Number} id The session id\n * @return {Session}\n *\n * @memberOf SessionService\n * @api private\n */\nSessionService.prototype.get = function(sid) {\n  return this.sessions[sid];\n};\n\n/**\n * Get sessions by userId.\n *\n * @param {Number} uid User id associated with the session\n * @return {Array} list of session binded with the uid\n *\n * @memberOf SessionService\n * @api private\n */\nSessionService.prototype.getByUid = function(uid) {\n  return this.uidMap[uid];\n};\n\n/**\n * Remove session by key.\n *\n * @param {Number} sid The session id\n *\n * @memberOf SessionService\n * @api private\n */\nSessionService.prototype.remove = function(sid) {\n  var session = this.sessions[sid];\n  if(session) {\n    var uid = session.uid;\n    delete this.sessions[session.id];\n\n    var sessions = this.uidMap[uid];\n    if(!sessions) {\n      return;\n    }\n\n    for(var i=0, l=sessions.length; i<l; i++) {\n      if(sessions[i].id === sid) {\n        sessions.splice(i, 1);\n        if(sessions.length === 0) {\n          delete this.uidMap[uid];\n        }\n        break;\n      }\n    }\n  }\n};\n\n/**\n * Import the key/value into session.\n *\n * @api private\n */\nSessionService.prototype.import = function(sid, key, value, cb) {\n  var session = this.sessions[sid];\n  if(!session) {\n    utils.invokeCallback(cb, new Error('session does not exist, sid: ' + sid));\n    return;\n  }\n  session.set(key, value);\n  utils.invokeCallback(cb);\n};\n\n/**\n * Import new value for the existed session.\n *\n * @memberOf SessionService\n * @api private\n */\nSessionService.prototype.importAll = function(sid, settings, cb) {\n  var session = this.sessions[sid];\n  if(!session) {\n    utils.invokeCallback(cb, new Error('session does not exist, sid: ' + sid));\n    return;\n  }\n\n  for(var f in settings) {\n    session.set(f, settings[f]);\n  }\n  utils.invokeCallback(cb);\n};\n\n/**\n * Kick all the session offline under the user id.\n *\n * @param {Number}   uid user id asscociated with the session\n * @param {Function} cb  callback function\n *\n * @memberOf SessionService\n */\nSessionService.prototype.kick = function(uid, reason, cb) {\n  // compatible for old kick(uid, cb);\n  if(typeof reason === 'function') {\n    cb = reason;\n    reason = 'kick';\n  }\n  var sessions = this.getByUid(uid);\n\n  if(sessions) {\n    // notify client\n    var sids = [];\n    var self = this;\n    sessions.forEach(function(session) {\n      sids.push(session.id);\n    });\n\n    sids.forEach(function(sid) {\n      self.sessions[sid].closed(reason);\n    });\n\n    process.nextTick(function() {\n      utils.invokeCallback(cb);\n    });\n  } else {\n    process.nextTick(function() {\n      utils.invokeCallback(cb);\n    });\n  }\n};\n\n/**\n * Kick a user offline by session id.\n *\n * @param {Number}   sid session id\n * @param {Function} cb  callback function\n *\n * @memberOf SessionService\n */\nSessionService.prototype.kickBySessionId = function(sid, reason, cb) {\n  if(typeof reason === 'function') {\n    cb = reason;\n    reason = 'kick';\n  }\n\n  var session = this.get(sid);\n\n  if(session) {\n    // notify client\n    session.closed(reason);\n    process.nextTick(function() {\n      utils.invokeCallback(cb);\n    });\n  } else {\n    process.nextTick(function() {\n      utils.invokeCallback(cb);\n    });\n  }\n};\n\n/**\n * Get client remote address by session id.\n *\n * @param {Number}   sid session id\n * @return {Object} remote address of client\n *\n * @memberOf SessionService\n */\n SessionService.prototype.getClientAddressBySessionId = function(sid) {\n   var session = this.get(sid);\n   if(session) {\n      var socket = session.__socket__;\n      return socket.remoteAddress;\n   } else {\n      return null;\n   }\n };\n\n/**\n * Send message to the client by session id.\n *\n * @param {String} sid session id\n * @param {Object} msg message to send\n *\n * @memberOf SessionService\n * @api private\n */\nSessionService.prototype.sendMessage = function(sid, msg) {\n  var session = this.sessions[sid];\n\n  if(!session) {\n    logger.debug('Fail to send message for non-existing session, sid: ' + sid + ' msg: ' + msg);\n    return false;\n  }\n\n  return send(this, session, msg);\n};\n\n/**\n * Send message to the client by user id.\n *\n * @param {String} uid userId\n * @param {Object} msg message to send\n *\n * @memberOf SessionService\n * @api private\n */\nSessionService.prototype.sendMessageByUid = function(uid, msg) {\n  var sessions = this.uidMap[uid];\n\n  if(!sessions) {\n    logger.debug('fail to send message by uid for non-existing session. uid: %j',\n        uid);\n    return false;\n  }\n\n  for(var i=0, l=sessions.length; i<l; i++) {\n    send(this, sessions[i], msg);\n  }\n};\n\n/**\n * Iterate all the session in the session service.\n *\n * @param  {Function} cb callback function to fetch session\n * @api private\n */\nSessionService.prototype.forEachSession = function(cb) {\n  for(var sid in this.sessions) {\n    cb(this.sessions[sid]);\n  }\n};\n\n/**\n * Iterate all the binded session in the session service.\n *\n * @param  {Function} cb callback function to fetch session\n * @api private\n */\nSessionService.prototype.forEachBindedSession = function(cb) {\n  var i, l, sessions;\n  for(var uid in this.uidMap) {\n    sessions = this.uidMap[uid];\n    for(i=0, l=sessions.length; i<l; i++) {\n      cb(sessions[i]);\n    }\n  }\n};\n\n/**\n * Get sessions' quantity in specified server.\n *\n */\nSessionService.prototype.getSessionsCount = function() {\n  return utils.size(this.sessions);\n};\n\n/**\n * Send message to the client that associated with the session.\n *\n * @api private\n */\nvar send = function(service, session, msg) {\n  session.send(msg);\n\n  return true;\n};\n\n/**\n * Session maintains the relationship between client connection and user information.\n * There is a session associated with each client connection. And it should bind to a\n * user id after the client passes the identification.\n *\n * Session is created in frontend server and should not be accessed in handler.\n * There is a proxy class called BackendSession in backend servers and FrontendSession \n * in frontend servers.\n */\nvar Session = function(sid, frontendId, socket, service) {\n  EventEmitter.call(this);\n  this.id = sid;          // r\n  this.frontendId = frontendId; // r\n  this.uid = null;        // r\n  this.settings = {};\n\n  // private\n  this.__socket__ = socket;\n  this.__sessionService__ = service;\n  this.__state__ = ST_INITED;\n};\n\nutil.inherits(Session, EventEmitter);\n\n/*\n * Export current session as frontend session.\n */\nSession.prototype.toFrontendSession = function() {\n  return new FrontendSession(this);\n};\n\n/**\n * Bind the session with the the uid.\n *\n * @param {Number} uid User id\n * @api public\n */\nSession.prototype.bind = function(uid) {\n  this.uid = uid;\n  this.emit('bind', uid);\n};\n\n/**\n * Unbind the session with the the uid.\n *\n * @param {Number} uid User id\n * @api private\n */\nSession.prototype.unbind = function(uid) {\n  this.uid = null;\n  this.emit('unbind', uid);\n};\n\n/**\n * Set values (one or many) for the session.\n *\n * @param {String|Object} key session key\n * @param {Object} value session value\n * @api public\n */\nSession.prototype.set = function(key, value) {\n  if (utils.isObject(key)) {\n    for (var i in key) {\n      this.settings[i] = key[i];\n    }\n  } else {\n    this.settings[key] = value;\n  }\n};\n\n/**\n * Remove value from the session.\n *\n * @param {String} key session key\n * @api public\n */\n Session.prototype.remove = function(key) {\n  delete this[key];\n};\n\n/**\n * Get value from the session.\n *\n * @param {String} key session key\n * @return {Object} value associated with session key\n * @api public\n */\nSession.prototype.get = function(key) {\n  return this.settings[key];\n};\n\n/**\n * Send message to the session.\n *\n * @param  {Object} msg final message sent to client\n */\nSession.prototype.send = function(msg) {\n  this.__socket__.send(msg);\n};\n\n/**\n * Send message to the session in batch.\n *\n * @param  {Array} msgs list of message\n */\nSession.prototype.sendBatch = function(msgs) {\n  this.__socket__.sendBatch(msgs);\n};\n\n/**\n * Closed callback for the session which would disconnect client in next tick.\n *\n * @api public\n */\nSession.prototype.closed = function(reason) {\n  logger.debug('session on [%s] is closed with session id: %s', this.frontendId, this.id);\n  if(this.__state__ === ST_CLOSED) {\n    return;\n  }\n  this.__state__ = ST_CLOSED;\n  this.__sessionService__.remove(this.id);\n  this.emit('closed', this.toFrontendSession(), reason);\n  this.__socket__.emit('closing', reason);\n\n  var self = this;\n  // give a chance to send disconnect message to client\n\n  process.nextTick(function() {\n    self.__socket__.disconnect();\n  });\n};\n\n/**\n * Frontend session for frontend server.\n */\nvar FrontendSession = function(session) {\n  EventEmitter.call(this);\n  clone(session, this, FRONTEND_SESSION_FIELDS);\n  // deep copy for settings\n  this.settings = dclone(session.settings);\n  this.__session__ = session;\n};\n\nutil.inherits(FrontendSession, EventEmitter);\n\nFrontendSession.prototype.bind = function(uid, cb) {\n  var self = this;\n  this.__sessionService__.bind(this.id, uid, function(err) {\n    if(!err) {\n      self.uid = uid;\n    }\n    utils.invokeCallback(cb, err);\n  });\n};\n\nFrontendSession.prototype.unbind = function(uid, cb) {\n  var self = this;\n  this.__sessionService__.unbind(this.id, uid, function(err) {\n    if(!err) {\n      self.uid = null;\n    }\n    utils.invokeCallback(cb, err);\n  });\n};\n\nFrontendSession.prototype.set = function(key, value) {\n  this.settings[key] = value;\n};\n\nFrontendSession.prototype.get = function(key) {\n  return this.settings[key];\n};\n\nFrontendSession.prototype.push = function(key, cb) {\n  this.__sessionService__.import(this.id, key, this.get(key), cb);\n};\n\nFrontendSession.prototype.pushAll = function(cb) {\n  this.__sessionService__.importAll(this.id, this.settings, cb);\n};\n\nFrontendSession.prototype.on = function(event, listener) {\n  EventEmitter.prototype.on.call(this, event, listener);\n  this.__session__.on(event, listener);\n};\n\n/**\n * Export the key/values for serialization.\n *\n * @api private\n */\nFrontendSession.prototype.export = function() {\n  var res = {};\n  clone(this, res, EXPORTED_SESSION_FIELDS);\n  return res;\n};\n\nvar clone = function(src, dest, includes) {\n  var f;\n  for(var i=0, l=includes.length; i<l; i++) {\n    f = includes[i];\n    dest[f] = src[f];\n  }\n};\n\nvar dclone = function(src) {\n  var res = {};\n  for(var f in src) {\n    res[f] = src[f];\n  }\n  return res;\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/filters/handler/serial.js":"/**\n * Filter to keep request sequence.\n */\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar taskManager = require('../../common/manager/taskManager');\n\nmodule.exports = function(timeout) {\n  return new Filter(timeout);\n};\n\nvar Filter = function(timeout) {\n  this.timeout = timeout;\n};\n\n/**\n * request serialization after filter\n */\nFilter.prototype.before = function(msg, session, next) {\n  taskManager.addTask(session.id, function(task) {\n    session.__serialTask__ = task;\n    next();\n  }, function() {\n    logger.error('[serial filter] msg timeout, msg:' + JSON.stringify(msg));\n  }, this.timeout);\n};\n\n/**\n * request serialization after filter\n */\nFilter.prototype.after = function(err, msg, session, resp, next) {\n  var task = session.__serialTask__;\n  if(task) {\n    if(!task.done() && !err) {\n      err = new Error('task time out. msg:' + JSON.stringify(msg));\n    }\n  }\n  next(err);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/filters/handler/time.js":"/**\n * Filter for statistics.\n * Record used time for each request.\n */\nvar conLogger = require('pomelo-logger').getLogger('con-log', __filename);\nvar utils = require('../../util/utils');\n\nmodule.exports = function() {\n  return new Filter();\n};\n\nvar Filter = function() {\n};\n\nFilter.prototype.before = function(msg, session, next) {\n  session.__startTime__ = Date.now();\n  next();\n};\n\nFilter.prototype.after = function(err, msg, session, resp, next) {\n  var start = session.__startTime__;\n  if(typeof start === 'number') {\n    var timeUsed = Date.now() - start;\n    var log = {\n      route : msg.__route__,\n      args : msg,\n      time : utils.format(new Date(start)),\n      timeUsed : timeUsed\n    };\n    conLogger.info(JSON.stringify(log));\n  }\n  next(err);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/filters/handler/timeout.js":"/**\n * Filter for timeout.\n * Print a warn information when request timeout.\n */\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar utils = require('../../util/utils');\n\nvar DEFAULT_TIMEOUT = 3000;\nvar DEFAULT_SIZE = 500;\n\nmodule.exports = function(timeout, maxSize) {\n  return new Filter(timeout || DEFAULT_TIMEOUT, maxSize || DEFAULT_SIZE);\n};\n\nvar Filter = function(timeout, maxSize) {\n  this.timeout = timeout;\n  this.maxSize = maxSize;\n  this.timeouts = {};\n  this.curId = 0;\n};\n\nFilter.prototype.before = function(msg, session, next) {\n  var count = utils.size(this.timeouts);\n  if(count > this.maxSize) {\n    logger.warn('timeout filter is out of range, current size is %s, max size is %s', count, this.maxSize);\n    next();\n    return;\n  }\n  this.curId++;\n  this.timeouts[this.curId] = setTimeout(function() {\n    logger.error('request %j timeout.', msg.__route__);\n  }, this.timeout);\n  session.__timeout__ = this.curId;\n  next();\n};\n\nFilter.prototype.after = function(err, msg, session, resp, next) {\n  var timeout = this.timeouts[session.__timeout__];\n  if(timeout) {\n    clearTimeout(timeout);\n    delete this.timeouts[session.__timeout__];\n  }\n  next(err);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/filters/handler/toobusy.js":"/**\n * Filter for toobusy.\n * if the process is toobusy, just skip the new request\n */\nvar conLogger = require('pomelo-logger').getLogger('con-log', __filename);\nvar toobusy = null;\nvar DEFAULT_MAXLAG = 70;\n\n\nmodule.exports = function(maxLag) {\n  return new Filter(maxLag || DEFAULT_MAXLAG);\n};\n\nvar Filter = function(maxLag) {\n  try {\n    toobusy = require('toobusy');\n  } catch(e) {\n  }\n  if(!!toobusy) {\n    toobusy.maxLag(maxLag);\n  }\n};\n\nFilter.prototype.before = function(msg, session, next) {\n  if (!!toobusy && toobusy()) {\n    conLogger.warn('[toobusy] reject request msg: ' + msg);\n    var err = new Error('Server toobusy!');\n    err.code = 500;\n    next(err);\n  } else {\n    next();\n  }\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/filters/rpc/rpcLog.js":"/**\n * Filter for rpc log.\n * Record used time for remote process call.\n */\nvar rpcLogger = require('pomelo-logger').getLogger('rpc-log', __filename);\nvar utils = require('../../util/utils');\n\nmodule.exports = function() {\n  return new Filter();\n};\n\nvar Filter = function () {\n}; \n\nFilter.prototype.name = 'rpcLog';\n\n/**\n * Before filter for rpc\n */\n\nFilter.prototype.before = function(serverId, msg, opts, next) {\n  opts = opts||{};\n  opts.__start_time__ = Date.now();\n  next();\n};\n\n/**\n * After filter for rpc\n */\nFilter.prototype.after = function(serverId, msg, opts, next) {\n  if(!!opts && !!opts.__start_time__) {\n    var start = opts.__start_time__;\n    var end = Date.now();\n    var timeUsed = end - start;\n    var log = {\n      route: msg.service,\n      args: msg.args,\n      time: utils.format(new Date(start)),\n      timeUsed: timeUsed\n    };\n    rpcLogger.info(JSON.stringify(log));\n  }\n  next();\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/sioconnector.js":"var util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar httpServer = require('http').createServer();\nvar SioSocket = require('./siosocket');\n\nvar PKG_ID_BYTES = 4;\nvar PKG_ROUTE_LENGTH_BYTES = 1;\nvar PKG_HEAD_BYTES = PKG_ID_BYTES + PKG_ROUTE_LENGTH_BYTES;\n\nvar curId = 1;\n\n/**\n * Connector that manager low level connection and protocol bewteen server and client.\n * Develper can provide their own connector to switch the low level prototol, such as tcp or probuf.\n */\nvar Connector = function(port, host, opts) {\n  if (!(this instanceof Connector)) {\n    return new Connector(port, host, opts);\n  }\n\n  EventEmitter.call(this);\n  this.port = port;\n  this.host = host;\n  this.opts = opts;\n  this.heartbeats = opts.heartbeats || true;\n  this.closeTimeout = opts.closeTimeout || 60;\n  this.heartbeatTimeout = opts.heartbeatTimeout || 60;\n  this.heartbeatInterval = opts.heartbeatInterval || 25;\n};\n\nutil.inherits(Connector, EventEmitter);\n\nmodule.exports = Connector;\n\n/**\n * Start connector to listen the specified port\n */\nConnector.prototype.start = function(cb) {\n  var self = this;\n  // issue https://github.com/NetEase/pomelo-cn/issues/174\n  var opts = {}\n  if(!!this.opts) {\n    opts = this.opts;\n  }\n  else {\n    opts = {\n      transports: [\n      'websocket', 'polling-xhr', 'polling-jsonp', 'polling'\n      ]\n    };\n  }\n\n  var sio = require('socket.io')(httpServer, opts);\n\n  var port = this.port;\n  httpServer.listen(port, function () {\n    console.log('sio Server listening at port %d', port);\n  });\n  sio.set('path', '/socket.io');\n  sio.set('transports', this.opts.transports);\n  sio.set('close timeout', this.closeTimeout);\n  sio.set('heartbeat timeout', this.heartbeatTimeout);\n  sio.set('heartbeat interval', this.heartbeatInterval);\n  sio.set('heartbeats', this.heartbeats);\n  sio.set('log level', 1);\n\n  sio.on('connection', function (socket) {\n  // this.wsocket.sockets.on('connection', function (socket) {\n    var siosocket = new SioSocket(curId++, socket);\n    self.emit('connection', siosocket);\n    siosocket.on('closing', function(reason) {\n      siosocket.send({route: 'onKick', reason: reason});\n    });\n  });\n\n  process.nextTick(cb);\n};\n\n/**\n * Stop connector\n */\nConnector.prototype.stop = function(force, cb) {\n  this.wsocket.server.close();\n  process.nextTick(cb);\n};\n\nConnector.encode = Connector.prototype.encode = function(reqId, route, msg) {\n  if(reqId) {\n    return composeResponse(reqId, route, msg);\n  } else {\n    return composePush(route, msg);\n  }\n};\n\n/**\n * Decode client message package.\n *\n * Package format:\n *   message id: 4bytes big-endian integer\n *   route length: 1byte\n *   route: route length bytes\n *   body: the rest bytes\n *\n * @param  {String} data socket.io package from client\n * @return {Object}      message object\n */\nConnector.decode = Connector.prototype.decode = function(msg) {\n  var index = 0;\n\n  var id = parseIntField(msg, index, PKG_ID_BYTES);\n  index += PKG_ID_BYTES;\n\n  var routeLen = parseIntField(msg, index, PKG_ROUTE_LENGTH_BYTES);\n\n  var route = msg.substr(PKG_HEAD_BYTES, routeLen);\n  var body = msg.substr(PKG_HEAD_BYTES + routeLen);\n\n  return {\n    id: id,\n    route: route,\n    body: JSON.parse(body)\n  };\n};\n\nvar composeResponse = function(msgId, route, msgBody) {\n  return {\n    id: msgId,\n    body: msgBody\n  };\n};\n\nvar composePush = function(route, msgBody) {\n  return JSON.stringify({route: route, body: msgBody});\n};\n\nvar parseIntField = function(str, offset, len) {\n  var res = 0;\n  for(var i=0; i<len; i++) {\n    if(i > 0) {\n      res <<= 8;\n    }\n    res |= str.charCodeAt(offset + i) & 0xff;\n  }\n\n  return res;\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/siosocket.js":"var util = require('util');\nvar EventEmitter = require('events').EventEmitter;\n\nvar ST_INITED = 0;\nvar ST_CLOSED = 1;\n\n/**\n * Socket class that wraps socket.io socket to provide unified interface for up level.\n */\nvar Socket = function(id, socket) {\n  EventEmitter.call(this);\n  this.id = id;\n  this.socket = socket;\n  this.remoteAddress = {\n    ip: socket.handshake.address.address,\n    port: socket.handshake.address.port\n  };\n\n  var self = this;\n\n  socket.on('disconnect', this.emit.bind(this, 'disconnect'));\n\n  socket.on('error', this.emit.bind(this, 'error'));\n\n  socket.on('message', function(msg) {\n    self.emit('message', msg);\n  });\n\n  this.state = ST_INITED;\n\n  // TODO: any other events?\n};\n\nutil.inherits(Socket, EventEmitter);\n\nmodule.exports = Socket;\n\nSocket.prototype.send = function(msg) {\n  if(this.state !== ST_INITED) {\n    return;\n  }\n  if(typeof msg !== 'string') {\n    msg = JSON.stringify(msg);\n  }\n  this.socket.send(msg);\n};\n\nSocket.prototype.disconnect = function() {\n  if(this.state === ST_CLOSED) {\n    return;\n  }\n\n  this.state = ST_CLOSED;\n  this.socket.disconnect();\n};\n\nSocket.prototype.sendBatch = function(msgs) {\n  this.send(encodeBatch(msgs));\n};\n\n/**\n * Encode batch msg to client\n */\nvar encodeBatch = function(msgs){\n  var res = '[', msg;\n  for(var i=0, l=msgs.length; i<l; i++) {\n    if(i > 0) {\n      res += ',';\n    }\n    msg = msgs[i];\n    if(typeof msg === 'string') {\n      res += msg;\n    } else {\n      res += JSON.stringify(msg);\n    }\n  }\n  res += ']';\n  return res;\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/hybridconnector.js":"var net = require('net');\nvar tls = require('tls');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\n\nvar HybridSocket = require('./hybridsocket');\nvar Switcher = require('./hybrid/switcher');\nvar Handshake = require('./commands/handshake');\nvar Heartbeat = require('./commands/heartbeat');\nvar Kick = require('./commands/kick');\nvar coder = require('./common/coder');\n\nvar curId = 1;\n\n/**\n * Connector that manager low level connection and protocol bewteen server and client.\n * Develper can provide their own connector to switch the low level prototol, such as tcp or probuf.\n */\nvar Connector = function(port, host, opts) {\n  if (!(this instanceof Connector)) {\n    return new Connector(port, host, opts);\n  }\n\n  EventEmitter.call(this);\n\n  this.opts = opts || {};\n  this.port = port;\n  this.host = host;\n  this.useDict = opts.useDict;\n  this.useProtobuf = opts.useProtobuf;\n  this.handshake = new Handshake(opts);\n  this.heartbeat = new Heartbeat(opts);\n  this.distinctHost = opts.distinctHost;\n  this.ssl = opts.ssl;\n\n  this.switcher = null;\n};\n\nutil.inherits(Connector, EventEmitter);\n\nmodule.exports = Connector;\n\n/**\n * Start connector to listen the specified port\n */\nConnector.prototype.start = function(cb) {\n  var app = require('../pomelo').app;\n  var self = this;\n\n  var gensocket = function(socket) {\n    var hybridsocket = new HybridSocket(curId++, socket);\n    hybridsocket.on('handshake', self.handshake.handle.bind(self.handshake, hybridsocket));\n    hybridsocket.on('heartbeat', self.heartbeat.handle.bind(self.heartbeat, hybridsocket));\n    hybridsocket.on('disconnect', self.heartbeat.clear.bind(self.heartbeat, hybridsocket.id));\n    hybridsocket.on('closing', Kick.handle.bind(null, hybridsocket));\n    self.emit('connection', hybridsocket);\n  };\n\n  this.connector = app.components.__connector__.connector;\n  this.dictionary = app.components.__dictionary__;\n  this.protobuf = app.components.__protobuf__;\n  this.decodeIO_protobuf = app.components.__decodeIO__protobuf__;\n\n  if(!this.ssl) {\n    this.listeningServer = net.createServer();\n  } else {\n    this.listeningServer = tls.createServer(this.ssl);\n  }\n  this.switcher = new Switcher(this.listeningServer, self.opts);\n\n  this.switcher.on('connection', function(socket) {\n    gensocket(socket);\n  });\n\n  if(!!this.distinctHost) {\n    this.listeningServer.listen(this.port, this.host);\n  } else {\n    this.listeningServer.listen(this.port);\n  }\n\n  process.nextTick(cb);\n};\n\nConnector.prototype.stop = function(force, cb) {\n  this.switcher.close();\n  this.listeningServer.close();\n\n  process.nextTick(cb);\n};\n\nConnector.decode = Connector.prototype.decode = coder.decode;\n\nConnector.encode = Connector.prototype.encode = coder.encode;\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/hybridsocket.js":"var util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar handler = require('./common/handler');\nvar protocol = require('pomelo-protocol');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar Package = protocol.Package;\n\nvar ST_INITED = 0;\nvar ST_WAIT_ACK = 1;\nvar ST_WORKING = 2;\nvar ST_CLOSED = 3;\n\n/**\n * Socket class that wraps socket and websocket to provide unified interface for up level.\n */\nvar Socket = function(id, socket) {\n  EventEmitter.call(this);\n  this.id = id;\n  this.socket = socket;\n\n  if(!socket._socket) {\n    this.remoteAddress = {\n      ip: socket.address().address,\n      port: socket.address().port\n    };\n  } else {\n    this.remoteAddress = {\n      ip: socket._socket.remoteAddress,\n      port: socket._socket.remotePort\n    };\n  }\n\n  var self = this;\n\n  socket.once('close', this.emit.bind(this, 'disconnect'));\n  socket.on('error', this.emit.bind(this, 'error'));\n\n  socket.on('message', function(msg) {\n    if(msg) {\n      msg = Package.decode(msg);\n      handler(self, msg);\n    }\n  });\n\n  this.state = ST_INITED;\n\n  // TODO: any other events?\n};\n\nutil.inherits(Socket, EventEmitter);\n\nmodule.exports = Socket;\n\n/**\n * Send raw byte data.\n *\n * @api private\n */\nSocket.prototype.sendRaw = function(msg) {\n  if(this.state !== ST_WORKING) {\n    return;\n  }\n  var self = this;\n\n  this.socket.send(msg, {binary: true}, function(err) {\n    if(!!err) {\n      logger.error('websocket send binary data failed: %j', err.stack);\n      return;\n    }\n  });\n};\n\n/**\n * Send byte data package to client.\n *\n * @param  {Buffer} msg byte data\n */\nSocket.prototype.send = function(msg) {\n  if(msg instanceof String) {\n    msg = new Buffer(msg);\n  } else if(!(msg instanceof Buffer)) {\n    msg = new Buffer(JSON.stringify(msg));\n  }\n  this.sendRaw(Package.encode(Package.TYPE_DATA, msg));\n};\n\n/**\n * Send byte data packages to client in batch.\n *\n * @param  {Buffer} msgs byte data\n */\nSocket.prototype.sendBatch = function(msgs) {\n  var rs = [];\n  for(var i=0; i<msgs.length; i++) {\n    var src = Package.encode(Package.TYPE_DATA, msgs[i]);\n    rs.push(src);\n  }\n  this.sendRaw(Buffer.concat(rs));\n};\n\n/**\n * Send message to client no matter whether handshake.\n *\n * @api private\n */\nSocket.prototype.sendForce = function(msg) {\n  if(this.state === ST_CLOSED) {\n    return;\n  }\n  this.socket.send(msg, {binary: true});\n};\n\n/**\n * Response handshake request\n *\n * @api private\n */\nSocket.prototype.handshakeResponse = function(resp) {\n  if(this.state !== ST_INITED) {\n    return;\n  }\n\n  this.socket.send(resp, {binary: true});\n  this.state = ST_WAIT_ACK;\n};\n\n/**\n * Close the connection.\n *\n * @api private\n */\nSocket.prototype.disconnect = function() {\n  if(this.state === ST_CLOSED) {\n    return;\n  }\n\n  this.state = ST_CLOSED;\n  this.socket.emit('close');\n  this.socket.close();\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/common/handler.js":"var protocol = require('pomelo-protocol');\nvar Package = protocol.Package;\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\n\nvar handlers = {};\n\nvar ST_INITED = 0;\nvar ST_WAIT_ACK = 1;\nvar ST_WORKING = 2;\nvar ST_CLOSED = 3;\n\nvar handleHandshake = function(socket, pkg) {\n  if(socket.state !== ST_INITED) {\n    return;\n  }\n  try {\n    socket.emit('handshake', JSON.parse(protocol.strdecode(pkg.body)));\n  } catch (ex) {\n    socket.emit('handshake', {});\n  }\n};\n\nvar handleHandshakeAck = function(socket, pkg) {\n  if(socket.state !== ST_WAIT_ACK) {\n    return;\n  }\n  socket.state = ST_WORKING;\n  socket.emit('heartbeat');\n};\n\nvar handleHeartbeat = function(socket, pkg) {\n  if(socket.state !== ST_WORKING) {\n    return;\n  }\n  socket.emit('heartbeat');\n};\n\nvar handleData = function(socket, pkg) {\n  if(socket.state !== ST_WORKING) {\n    return;\n  }\n  socket.emit('message', pkg);\n};\n\nhandlers[Package.TYPE_HANDSHAKE] = handleHandshake;\nhandlers[Package.TYPE_HANDSHAKE_ACK] = handleHandshakeAck;\nhandlers[Package.TYPE_HEARTBEAT] = handleHeartbeat;\nhandlers[Package.TYPE_DATA] = handleData;\n\nvar handle = function(socket, pkg) {\n  var handler = handlers[pkg.type];\n  if(!!handler) {\n    handler(socket, pkg);\n  } else {\n    logger.error('could not find handle invalid data package.');\n    socket.disconnect();\n  }\n};\n\nmodule.exports = handle;\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-protocol/index.js":"module.exports = require('./lib/protocol');","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo-protocol/lib/protocol.js":"(function (exports, ByteArray, global) {\n  var Protocol = exports;\n\n  var PKG_HEAD_BYTES = 4;\n  var MSG_FLAG_BYTES = 1;\n  var MSG_ROUTE_CODE_BYTES = 2;\n  var MSG_ID_MAX_BYTES = 5;\n  var MSG_ROUTE_LEN_BYTES = 1;\n\n  var MSG_ROUTE_CODE_MAX = 0xffff;\n\n  var MSG_COMPRESS_ROUTE_MASK = 0x1;\n  var MSG_COMPRESS_GZIP_MASK = 0x1;\n  var MSG_COMPRESS_GZIP_ENCODE_MASK = 1 << 4;\n  var MSG_TYPE_MASK = 0x7;\n\n  var Package = Protocol.Package = {};\n  var Message = Protocol.Message = {};\n\n  Package.TYPE_HANDSHAKE = 1;\n  Package.TYPE_HANDSHAKE_ACK = 2;\n  Package.TYPE_HEARTBEAT = 3;\n  Package.TYPE_DATA = 4;\n  Package.TYPE_KICK = 5;\n\n  Message.TYPE_REQUEST = 0;\n  Message.TYPE_NOTIFY = 1;\n  Message.TYPE_RESPONSE = 2;\n  Message.TYPE_PUSH = 3;\n\n  /**\n   * pomele client encode\n   * id message id;\n   * route message route\n   * msg message body\n   * socketio current support string\n   */\n  Protocol.strencode = function(str) {\n    if(typeof Buffer !== \"undefined\" && ByteArray === Buffer) {\n      // encoding defaults to 'utf8'\n      return (new Buffer(str));\n    } else {\n      var byteArray = new ByteArray(str.length * 3);\n      var offset = 0;\n      for(var i = 0; i < str.length; i++){\n        var charCode = str.charCodeAt(i);\n        var codes = null;\n        if(charCode <= 0x7f){\n          codes = [charCode];\n        }else if(charCode <= 0x7ff){\n          codes = [0xc0|(charCode>>6), 0x80|(charCode & 0x3f)];\n        }else{\n          codes = [0xe0|(charCode>>12), 0x80|((charCode & 0xfc0)>>6), 0x80|(charCode & 0x3f)];\n        }\n        for(var j = 0; j < codes.length; j++){\n          byteArray[offset] = codes[j];\n          ++offset;\n        }\n      }\n      var _buffer = new ByteArray(offset);\n      copyArray(_buffer, 0, byteArray, 0, offset);\n      return _buffer;\n    }\n  };\n\n  /**\n   * client decode\n   * msg String data\n   * return Message Object\n   */\n  Protocol.strdecode = function(buffer) {\n    if(typeof Buffer !== \"undefined\" && ByteArray === Buffer) {\n      // encoding defaults to 'utf8'\n      return buffer.toString();\n    } else {\n      var bytes = new ByteArray(buffer);\n      var array = [];\n      var offset = 0;\n      var charCode = 0;\n      var end = bytes.length;\n      while(offset < end){\n        if(bytes[offset] < 128){\n          charCode = bytes[offset];\n          offset += 1;\n        }else if(bytes[offset] < 224){\n          charCode = ((bytes[offset] & 0x1f)<<6) + (bytes[offset+1] & 0x3f);\n          offset += 2;\n        }else{\n          charCode = ((bytes[offset] & 0x0f)<<12) + ((bytes[offset+1] & 0x3f)<<6) + (bytes[offset+2] & 0x3f);\n          offset += 3;\n        }\n        array.push(charCode);\n      }\n      return String.fromCharCode.apply(null, array);\n    }\n  };\n\n  /**\n   * Package protocol encode.\n   *\n   * Pomelo package format:\n   * +------+-------------+------------------+\n   * | type | body length |       body       |\n   * +------+-------------+------------------+\n   *\n   * Head: 4bytes\n   *   0: package type,\n   *      1 - handshake,\n   *      2 - handshake ack,\n   *      3 - heartbeat,\n   *      4 - data\n   *      5 - kick\n   *   1 - 3: big-endian body length\n   * Body: body length bytes\n   *\n   * @param  {Number}    type   package type\n   * @param  {ByteArray} body   body content in bytes\n   * @return {ByteArray}        new byte array that contains encode result\n   */\n  Package.encode = function(type, body){\n    var length = body ? body.length : 0;\n    var buffer = new ByteArray(PKG_HEAD_BYTES + length);\n    var index = 0;\n    buffer[index++] = type & 0xff;\n    buffer[index++] = (length >> 16) & 0xff;\n    buffer[index++] = (length >> 8) & 0xff;\n    buffer[index++] = length & 0xff;\n    if(body) {\n      copyArray(buffer, index, body, 0, length);\n    }\n    return buffer;\n  };\n\n  /**\n   * Package protocol decode.\n   * See encode for package format.\n   *\n   * @param  {ByteArray} buffer byte array containing package content\n   * @return {Object}           {type: package type, buffer: body byte array}\n   */\n  Package.decode = function(buffer){\n    var offset = 0;\n    var bytes = new ByteArray(buffer);\n    var length = 0;\n    var rs = [];\n    while(offset < bytes.length) {\n      var type = bytes[offset++];\n      length = ((bytes[offset++]) << 16 | (bytes[offset++]) << 8 | bytes[offset++]) >>> 0;\n      var body = length ? new ByteArray(length) : null;\n      if(body) {\n        copyArray(body, 0, bytes, offset, length);\n      }\n      offset += length;\n      rs.push({'type': type, 'body': body});\n    }\n    return rs.length === 1 ? rs[0]: rs;\n  };\n\n  /**\n   * Message protocol encode.\n   *\n   * @param  {Number} id            message id\n   * @param  {Number} type          message type\n   * @param  {Number} compressRoute whether compress route\n   * @param  {Number|String} route  route code or route string\n   * @param  {Buffer} msg           message body bytes\n   * @return {Buffer}               encode result\n   */\n  Message.encode = function(id, type, compressRoute, route, msg, compressGzip){\n    // caculate message max length\n    var idBytes = msgHasId(type) ? caculateMsgIdBytes(id) : 0;\n    var msgLen = MSG_FLAG_BYTES + idBytes;\n\n    if(msgHasRoute(type)) {\n      if(compressRoute) {\n        if(typeof route !== 'number'){\n          throw new Error('error flag for number route!');\n        }\n        msgLen += MSG_ROUTE_CODE_BYTES;\n      } else {\n        msgLen += MSG_ROUTE_LEN_BYTES;\n        if(route) {\n          route = Protocol.strencode(route);\n          if(route.length>255) {\n            throw new Error('route maxlength is overflow');\n          }\n          msgLen += route.length;\n        }\n      }\n    }\n\n    if(msg) {\n      msgLen += msg.length;\n    }\n\n    var buffer = new ByteArray(msgLen);\n    var offset = 0;\n\n    // add flag\n    offset = encodeMsgFlag(type, compressRoute, buffer, offset, compressGzip);\n\n    // add message id\n    if(msgHasId(type)) {\n      offset = encodeMsgId(id, buffer, offset);\n    }\n\n    // add route\n    if(msgHasRoute(type)) {\n      offset = encodeMsgRoute(compressRoute, route, buffer, offset);\n    }\n\n    // add body\n    if(msg) {\n      offset = encodeMsgBody(msg, buffer, offset);\n    }\n\n    return buffer;\n  };\n\n  /**\n   * Message protocol decode.\n   *\n   * @param  {Buffer|Uint8Array} buffer message bytes\n   * @return {Object}            message object\n   */\n  Message.decode = function(buffer) {\n    var bytes =  new ByteArray(buffer);\n    var bytesLen = bytes.length || bytes.byteLength;\n    var offset = 0;\n    var id = 0;\n    var route = null;\n\n    // parse flag\n    var flag = bytes[offset++];\n    var compressRoute = flag & MSG_COMPRESS_ROUTE_MASK;\n    var type = (flag >> 1) & MSG_TYPE_MASK;\n    var compressGzip = (flag >> 4) & MSG_COMPRESS_GZIP_MASK;\n\n    // parse id\n    if(msgHasId(type)) {\n      var m = 0;\n      var i = 0;\n      do{\n        m = parseInt(bytes[offset]);\n        id += (m & 0x7f) << (7 * i);\n        offset++;\n        i++;\n      }while(m >= 128);\n    }\n\n    // parse route\n    if(msgHasRoute(type)) {\n      if(compressRoute) {\n        route = (bytes[offset++]) << 8 | bytes[offset++];\n      } else {\n        var routeLen = bytes[offset++];\n        if(routeLen) {\n          route = new ByteArray(routeLen);\n          copyArray(route, 0, bytes, offset, routeLen);\n          route = Protocol.strdecode(route);\n        } else {\n          route = '';\n        }\n        offset += routeLen;\n      }\n    }\n\n    // parse body\n    var bodyLen = bytesLen - offset;\n    var body = new ByteArray(bodyLen);\n\n    copyArray(body, 0, bytes, offset, bodyLen);\n\n    return {'id': id, 'type': type, 'compressRoute': compressRoute,\n            'route': route, 'body': body, 'compressGzip': compressGzip};\n  };\n\n  var copyArray = function(dest, doffset, src, soffset, length) {\n    if('function' === typeof src.copy) {\n      // Buffer\n      src.copy(dest, doffset, soffset, soffset + length);\n    } else {\n      // Uint8Array\n      for(var index=0; index<length; index++){\n        dest[doffset++] = src[soffset++];\n      }\n    }\n  };\n\n  var msgHasId = function(type) {\n    return type === Message.TYPE_REQUEST || type === Message.TYPE_RESPONSE;\n  };\n\n  var msgHasRoute = function(type) {\n    return type === Message.TYPE_REQUEST || type === Message.TYPE_NOTIFY ||\n           type === Message.TYPE_PUSH;\n  };\n\n  var caculateMsgIdBytes = function(id) {\n    var len = 0;\n    do {\n      len += 1;\n      id >>= 7;\n    } while(id > 0);\n    return len;\n  };\n\n  var encodeMsgFlag = function(type, compressRoute, buffer, offset, compressGzip) {\n    if(type !== Message.TYPE_REQUEST && type !== Message.TYPE_NOTIFY &&\n       type !== Message.TYPE_RESPONSE && type !== Message.TYPE_PUSH) {\n      throw new Error('unkonw message type: ' + type);\n    }\n\n    buffer[offset] = (type << 1) | (compressRoute ? 1 : 0);\n\n    if(compressGzip) {\n      buffer[offset] = buffer[offset] | MSG_COMPRESS_GZIP_ENCODE_MASK;\n    }\n\n    return offset + MSG_FLAG_BYTES;\n  };\n\n  var encodeMsgId = function(id, buffer, offset) {\n    do{\n      var tmp = id % 128;\n      var next = Math.floor(id/128);\n\n      if(next !== 0){\n        tmp = tmp + 128;\n      }\n      buffer[offset++] = tmp;\n\n      id = next;\n    } while(id !== 0);\n\n    return offset;\n  };\n\n  var encodeMsgRoute = function(compressRoute, route, buffer, offset) {\n    if (compressRoute) {\n      if(route > MSG_ROUTE_CODE_MAX){\n        throw new Error('route number is overflow');\n      }\n\n      buffer[offset++] = (route >> 8) & 0xff;\n      buffer[offset++] = route & 0xff;\n    } else {\n      if(route) {\n        buffer[offset++] = route.length & 0xff;\n        copyArray(buffer, offset, route, 0, route.length);\n        offset += route.length;\n      } else {\n        buffer[offset++] = 0;\n      }\n    }\n\n    return offset;\n  };\n\n  var encodeMsgBody = function(msg, buffer, offset) {\n    copyArray(buffer, offset, msg, 0, msg.length);\n    return offset + msg.length;\n  };\n\n  module.exports = Protocol;\n  if(typeof(window) != \"undefined\") {\n    window.Protocol = Protocol;\n  }\n})(typeof(window)==\"undefined\" ? module.exports : (this.Protocol = {}),typeof(window)==\"undefined\"  ? Buffer : Uint8Array, this);\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/hybrid/switcher.js":"var EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar WSProcessor = require('./wsprocessor');\nvar TCPProcessor = require('./tcpprocessor');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\n\nvar HTTP_METHODS = [\n  'GET', 'POST', 'DELETE', 'PUT', 'HEAD'\n];\n\nvar ST_STARTED = 1;\nvar ST_CLOSED = 2;\n\nvar DEFAULT_TIMEOUT = 90;\n\n/**\n * Switcher for tcp and websocket protocol\n *\n * @param {Object} server tcp server instance from node.js net module\n */\nvar Switcher = function(server, opts) {\n  EventEmitter.call(this);\n  this.server = server;\n  this.wsprocessor = new WSProcessor();\n  this.tcpprocessor = new TCPProcessor(opts.closeMethod);\n  this.id = 1;\n  this.timeout = (opts.timeout || DEFAULT_TIMEOUT) * 1000;\n  this.setNoDelay = opts.setNoDelay;\n\n  if (!opts.ssl) {\n    this.server.on('connection', this.newSocket.bind(this));\n  } else {\n    this.server.on('secureConnection', this.newSocket.bind(this));\n    this.server.on('clientError', function(e, tlsSo) {\n      logger.warn('an ssl error occured before handshake established: ', e);\n      tlsSo.destroy();\n    });\n  }\n\n  this.wsprocessor.on('connection', this.emit.bind(this, 'connection'));\n  this.tcpprocessor.on('connection', this.emit.bind(this, 'connection'));\n\n  this.state = ST_STARTED;\n};\nutil.inherits(Switcher, EventEmitter);\n\nmodule.exports = Switcher;\n\nSwitcher.prototype.newSocket = function(socket) {\n  if(this.state !== ST_STARTED) {\n    return;\n  }\n\n  socket.setTimeout(this.timeout, function() {\n     logger.warn('connection is timeout without communication, the remote ip is %s && port is %s',\n       socket.remoteAddress, socket.remotePort);\n     socket.destroy();\n  });\n\n  var self = this;\n\n  socket.once('data', function(data) {\n    // FIXME: handle incomplete HTTP method\n    if(isHttp(data)) {\n      processHttp(self, self.wsprocessor, socket, data);\n    } else {\n      if(!!self.setNoDelay) {\n        socket.setNoDelay(true);\n      }\n      processTcp(self, self.tcpprocessor, socket, data);\n    }\n  });\n};\n\nSwitcher.prototype.close = function() {\n  if(this.state !== ST_STARTED) {\n    return;\n  }\n\n  this.state = ST_CLOSED;\n  this.wsprocessor.close();\n  this.tcpprocessor.close();\n};\n\nvar isHttp = function(data) {\n  var head = data.toString('utf8', 0, 4);\n\n  for(var i=0, l=HTTP_METHODS.length; i<l; i++) {\n    if(head.indexOf(HTTP_METHODS[i]) === 0) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nvar processHttp = function(switcher, processor, socket, data) {\n  processor.add(socket, data);\n};\n\nvar processTcp = function(switcher, processor, socket, data) {\n  processor.add(socket, data);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/hybrid/wsprocessor.js":"var HttpServer = require('http').Server;\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar WebSocketServer = require('ws').Server;\n\nvar ST_STARTED = 1;\nvar ST_CLOSED = 2;\n\n/**\n * websocket protocol processor\n */\nvar Processor = function() {\n  EventEmitter.call(this);\n  this.httpServer = new HttpServer();\n\n  var self = this;\n  this.wsServer = new WebSocketServer({server: this.httpServer});\n\n  this.wsServer.on('connection', function(socket) {\n    // emit socket to outside\n    self.emit('connection', socket);\n  });\n\n  this.state = ST_STARTED;\n};\nutil.inherits(Processor, EventEmitter);\n\nmodule.exports = Processor;\n\nProcessor.prototype.add = function(socket, data) {\n  if(this.state !== ST_STARTED) {\n    return;\n  }\n  this.httpServer.emit('connection', socket);\n  if(typeof socket.ondata === 'function') {\n    // compatible with stream2\n    socket.ondata(data, 0, data.length);\n  } else {\n    // compatible with old stream\n    socket.emit('data', data);\n  }\n};\n\nProcessor.prototype.close = function() {\n  if(this.state !== ST_STARTED) {\n    return;\n  }\n  this.state = ST_CLOSED;\n  this.wsServer.close();\n  this.wsServer = null;\n  this.httpServer = null;\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/hybrid/tcpprocessor.js":"var EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar utils = require('../../util/utils');\nvar TcpSocket = require('./tcpsocket');\n\nvar ST_STARTED = 1;\nvar ST_CLOSED = 2;\n\n// private protocol, no need exports\nvar HEAD_SIZE = 4;\n\n/**\n * websocket protocol processor\n */\nvar Processor = function(closeMethod) {\n  EventEmitter.call(this);\n  this.closeMethod = closeMethod;\n  this.state = ST_STARTED;\n};\nutil.inherits(Processor, EventEmitter);\n\nmodule.exports = Processor;\n\nProcessor.prototype.add = function(socket, data) {\n  if(this.state !== ST_STARTED) {\n    return;\n  }\n  var tcpsocket = new TcpSocket(socket, {headSize: HEAD_SIZE,\n                                         headHandler: utils.headHandler,\n                                         closeMethod: this.closeMethod});\n  this.emit('connection', tcpsocket);\n  socket.emit('data', data);\n};\n\nProcessor.prototype.close = function() {\n  if(this.state !== ST_STARTED) {\n    return;\n  }\n  this.state = ST_CLOSED;\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/hybrid/tcpsocket.js":"var Stream = require('stream');\nvar util = require('util');\nvar protocol = require('pomelo-protocol');\nvar Package = protocol.Package;\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\n\n/**\n * Work states\n */\nvar ST_HEAD = 1;      // wait for head\nvar ST_BODY = 2;      // wait for body\nvar ST_CLOSED = 3;    // closed\n\n/**\n * Tcp socket wrapper with package compositing.\n * Collect the package from socket and emit a completed package with 'data' event.\n * Uniform with ws.WebSocket interfaces.\n *\n * @param {Object} socket origin socket from node.js net module\n * @param {Object} opts   options parameter.\n *                        opts.headSize size of package head\n *                        opts.headHandler(headBuffer) handler for package head. caculate and return body size from head data.\n */\nvar Socket = function(socket, opts) {\n  if(!(this instanceof Socket)) {\n    return new Socket(socket, opts);\n  }\n\n  if(!socket || !opts) {\n    throw new Error('invalid socket or opts');\n  }\n\n  if(!opts.headSize || typeof opts.headHandler !== 'function') {\n    throw new Error('invalid opts.headSize or opts.headHandler');\n  }\n\n  // stream style interfaces.\n  // TODO: need to port to stream2 after node 0.9\n  Stream.call(this);\n  this.readable = true;\n  this.writeable = true;\n\n  this._socket = socket;\n  this.headSize = opts.headSize;\n  this.closeMethod = opts.closeMethod;\n  this.headBuffer = new Buffer(opts.headSize);\n  this.headHandler = opts.headHandler;\n\n  this.headOffset = 0;\n  this.packageOffset = 0;\n  this.packageSize = 0;\n  this.packageBuffer = null;\n\n  // bind event form the origin socket\n  this._socket.on('data', ondata.bind(null, this));\n  this._socket.on('end', onend.bind(null, this));\n  this._socket.on('error', this.emit.bind(this, 'error'));\n  this._socket.on('close', this.emit.bind(this, 'close'));\n\n  this.state = ST_HEAD;\n};\n\nutil.inherits(Socket, Stream);\n\nmodule.exports = Socket;\n\nSocket.prototype.send = function(msg, encode, cb) {\n  this._socket.write(msg, encode, cb);\n};\n\nSocket.prototype.close = function() {\n  if(!!this.closeMethod && this.closeMethod === 'end') {\n    this._socket.end();\n  } else {\n    try { \n      this._socket.destroy(); \n    } catch (e) {\n      logger.error('socket close with destroy error: %j', e.stack);\n    }\n  }\n};\n\nvar ondata = function(socket, chunk) {\n  if(socket.state === ST_CLOSED) {\n    throw new Error('socket has closed');\n  }\n\n  if(typeof chunk !== 'string' && !Buffer.isBuffer(chunk)) {\n    throw new Error('invalid data');\n  }\n\n  if(typeof chunk === 'string') {\n    chunk = new Buffer(chunk, 'utf8');\n  }\n\n  var offset = 0, end = chunk.length;\n\n  while(offset < end && socket.state !== ST_CLOSED) {\n    if(socket.state === ST_HEAD) {\n      offset = readHead(socket, chunk, offset);\n    }\n\n    if(socket.state === ST_BODY) {\n      offset = readBody(socket, chunk, offset);\n    }\n  }\n\n  return true;\n};\n\nvar onend = function(socket, chunk) {\n  if(chunk) {\n    socket._socket.write(chunk);\n  }\n\n  socket.state = ST_CLOSED;\n  reset(socket);\n  socket.emit('end');\n};\n\n/**\n * Read head segment from data to socket.headBuffer.\n *\n * @param  {Object} socket Socket instance\n * @param  {Object} data   Buffer instance\n * @param  {Number} offset offset read star from data\n * @return {Number}        new offset of data after read\n */\nvar readHead = function(socket, data, offset) {\n  var hlen = socket.headSize - socket.headOffset;\n  var dlen = data.length - offset;\n  var len = Math.min(hlen, dlen);\n  var dend = offset + len;\n\n  data.copy(socket.headBuffer, socket.headOffset, offset, dend);\n  socket.headOffset += len;\n\n  if(socket.headOffset === socket.headSize) {\n    // if head segment finished\n    var size = socket.headHandler(socket.headBuffer);\n    if(size < 0) {\n      throw new Error('invalid body size: ' + size);\n    }\n    // check if header contains a valid type\n    if(checkTypeData(socket.headBuffer[0])) {\n      socket.packageSize = size + socket.headSize;\n      socket.packageBuffer = new Buffer(socket.packageSize);\n      socket.headBuffer.copy(socket.packageBuffer, 0, 0, socket.headSize);\n      socket.packageOffset = socket.headSize;\n      socket.state = ST_BODY;\n    } else {\n      dend = data.length;\n      logger.error('close the connection with invalid head message, the remote ip is %s && port is %s && message is %j', socket._socket.remoteAddress, socket._socket.remotePort, data);\n      socket.close();\n    }\n\n  }\n\n  return dend;\n};\n\n/**\n * Read body segment from data buffer to socket.packageBuffer;\n *\n * @param  {Object} socket Socket instance\n * @param  {Object} data   Buffer instance\n * @param  {Number} offset offset read star from data\n * @return {Number}        new offset of data after read\n */\nvar readBody = function(socket, data, offset) {\n  var blen = socket.packageSize - socket.packageOffset;\n  var dlen = data.length - offset;\n  var len = Math.min(blen, dlen);\n  var dend = offset + len;\n\n  data.copy(socket.packageBuffer, socket.packageOffset, offset, dend);\n\n  socket.packageOffset += len;\n\n  if(socket.packageOffset === socket.packageSize) {\n    // if all the package finished\n    var buffer = socket.packageBuffer;\n    socket.emit('message', buffer);\n    reset(socket);\n  }\n\n  return dend;\n};\n\nvar reset = function(socket) {\n  socket.headOffset = 0;\n  socket.packageOffset = 0;\n  socket.packageSize = 0;\n  socket.packageBuffer = null;\n  socket.state = ST_HEAD;\n};\n\nvar checkTypeData = function(data) {\n  return data === Package.TYPE_HANDSHAKE || data === Package.TYPE_HANDSHAKE_ACK || data === Package.TYPE_HEARTBEAT || data === Package.TYPE_DATA || data === Package.TYPE_KICK;\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/commands/handshake.js":"var pomelo = require('../../pomelo');\nvar Package = require('pomelo-protocol').Package;\n\nvar CODE_OK = 200;\nvar CODE_USE_ERROR = 500;\nvar CODE_OLD_CLIENT = 501;\n\n/**\n * Process the handshake request.\n *\n * @param {Object} opts option parameters\n *                      opts.handshake(msg, cb(err, resp)) handshake callback. msg is the handshake message from client.\n *                      opts.hearbeat heartbeat interval (level?)\n *                      opts.version required client level\n */\nvar Command = function(opts) {\n  opts = opts || {};\n  this.userHandshake = opts.handshake;\n\n  if(opts.heartbeat) {\n    this.heartbeatSec = opts.heartbeat;\n    this.heartbeat = opts.heartbeat * 1000;\n  }\n\n  this.checkClient = opts.checkClient;\n\n  this.useDict = opts.useDict;\n  this.useProtobuf = opts.useProtobuf;\n  this.useCrypto = opts.useCrypto;\n};\n\nmodule.exports = Command;\n\nCommand.prototype.handle = function(socket, msg) {\n  if(!msg.sys) {\n    processError(socket, CODE_USE_ERROR);\n    return;\n  }\n\n  if(typeof this.checkClient === 'function') {\n    if(!msg || !msg.sys || !this.checkClient(msg.sys.type, msg.sys.version)) {\n      processError(socket, CODE_OLD_CLIENT);\n      return;\n    }\n  }\n\n  var opts = {\n    heartbeat : setupHeartbeat(this)\n  };\n\n  if(this.useDict) {\n    var dictVersion = pomelo.app.components.__dictionary__.getVersion();\n    if(!msg.sys.dictVersion || msg.sys.dictVersion !== dictVersion){\n\n      // may be deprecated in future\n      opts.dict = pomelo.app.components.__dictionary__.getDict();\n\n      opts.routeToCode = pomelo.app.components.__dictionary__.getDict();\n      opts.codeToRoute = pomelo.app.components.__dictionary__.getAbbrs();\n      opts.dictVersion = dictVersion; \n    }\n    opts.useDict = true;\n  }\n\n  if(this.useProtobuf) {\n    var protoVersion = pomelo.app.components.__protobuf__.getVersion();\n    if(!msg.sys.protoVersion || msg.sys.protoVersion !== protoVersion){\n      opts.protos = pomelo.app.components.__protobuf__.getProtos();\n    }\n    opts.useProto = true;\n  }\n\n  if(!!pomelo.app.components.__decodeIO__protobuf__) {\n    if(!!this.useProtobuf) {\n      throw new Error('protobuf can not be both used in the same project.');\n    }\n    var version = pomelo.app.components.__decodeIO__protobuf__.getVersion();\n    if(!msg.sys.protoVersion || msg.sys.protoVersion < version) {\n      opts.protos = pomelo.app.components.__decodeIO__protobuf__.getProtos();\n    }\n    opts.useProto = true;\n  }\n\n  if(this.useCrypto) {\n    pomelo.app.components.__connector__.setPubKey(socket.id, msg.sys.rsa);\n  }\n\n  if(typeof this.userHandshake === 'function') {\n    this.userHandshake(msg, function(err, resp) {\n      if(err) {\n        process.nextTick(function() {\n          processError(socket, CODE_USE_ERROR);\n        });\n        return;\n      }\n      process.nextTick(function() {\n        response(socket, opts, resp);\n      });\n    }, socket);\n    return;\n  }\n\n  process.nextTick(function() {\n    response(socket, opts);\n  });\n};\n\nvar setupHeartbeat = function(self) {\n  return self.heartbeatSec;\n};\n\nvar response = function(socket, sys, resp) {\n  var res = {\n    code: CODE_OK,\n    sys: sys\n  };\n  if(resp) {\n    res.user = resp;\n  }\n  socket.handshakeResponse(Package.encode(Package.TYPE_HANDSHAKE, new Buffer(JSON.stringify(res))));\n};\n\nvar processError = function(socket, code) {\n  var res = {\n    code: code\n  };\n  socket.sendForce(Package.encode(Package.TYPE_HANDSHAKE, new Buffer(JSON.stringify(res))));\n  process.nextTick(function() {\n    socket.disconnect();\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/commands/heartbeat.js":"var Package = require('pomelo-protocol').Package;\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\n\n/**\n * Process heartbeat request.\n *\n * @param {Object} opts option request\n *                      opts.heartbeat heartbeat interval\n */\nvar Command = function(opts) {\n  opts = opts || {};\n  this.heartbeat = null;\n  this.timeout = null;\n  this.disconnectOnTimeout = opts.disconnectOnTimeout;\n\n  if(opts.heartbeat) {\n    this.heartbeat = opts.heartbeat * 1000; // heartbeat interval\n    this.timeout = opts.timeout * 1000 || this.heartbeat * 2;      // max heartbeat message timeout\n    this.disconnectOnTimeout = true;\n  }\n\n  this.timeouts = {};\n  this.clients = {};\n};\n\nmodule.exports = Command;\n\nCommand.prototype.handle = function(socket) {\n  if(!this.heartbeat) {\n    // no heartbeat setting\n    return;\n  }\n\n  var self = this;\n\n  if(!this.clients[socket.id]) {\n    // clear timers when socket disconnect or error\n    this.clients[socket.id] = 1;\n    socket.once('disconnect', clearTimers.bind(null, this, socket.id));\n    socket.once('error', clearTimers.bind(null, this, socket.id));\n  }\n\n  // clear timeout timer\n  if(self.disconnectOnTimeout) {\n    this.clear(socket.id);\n  }\n\n  socket.sendRaw(Package.encode(Package.TYPE_HEARTBEAT));\n\n  if(self.disconnectOnTimeout) {\n    self.timeouts[socket.id] = setTimeout(function() {\n      logger.info('client %j heartbeat timeout.', socket.id);\n      socket.disconnect();\n    }, self.timeout);\n  }\n};\n\nCommand.prototype.clear = function(id) {\n  var tid = this.timeouts[id];\n  if(tid) {\n    clearTimeout(tid);\n    delete this.timeouts[id];\n  }\n};\n\nvar clearTimers = function(self, id) {\n  delete self.clients[id];\n  var tid = self.timeouts[id];\n  if(tid) {\n    clearTimeout(tid);\n    delete self.timeouts[id];\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/commands/kick.js":"var Package = require('pomelo-protocol').Package;\n\nmodule.exports.handle = function(socket, reason) {\n// websocket close code 1000 would emit when client close the connection\n  if(typeof reason === 'string') {\n    var res = {\n      reason: reason\n    };\n    socket.sendRaw(Package.encode(Package.TYPE_KICK, new Buffer(JSON.stringify(res))));\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/common/coder.js":"var Message = require('pomelo-protocol').Message;\nvar Constants = require('../../util/constants');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\n\nvar encode = function(reqId, route, msg) {\n  if(!!reqId) {\n    return composeResponse(this, reqId, route, msg);\n  } else {\n    return composePush(this, route, msg);\n  }\n};\n\nvar decode = function(msg) {\n  msg = Message.decode(msg.body);\n  var route = msg.route;\n\n  // decode use dictionary\n  if(!!msg.compressRoute) {\n    if(!!this.connector.useDict) {\n      var abbrs = this.dictionary.getAbbrs();\n      if(!abbrs[route]) {\n        logger.error('dictionary error! no abbrs for route : %s', route);\n        return null;\n      }\n      route = msg.route = abbrs[route];\n    } else {\n      logger.error('fail to uncompress route code for msg: %j, server not enable dictionary.', msg);\n      return null;\n    }\n  }\n\n  // decode use protobuf\n  if(!!this.protobuf && !!this.protobuf.getProtos().client[route]) {\n    msg.body = this.protobuf.decode(route, msg.body);\n  } else if(!!this.decodeIO_protobuf && !!this.decodeIO_protobuf.check(Constants.RESERVED.CLIENT, route)) {\n    msg.body = this.decodeIO_protobuf.decode(route, msg.body);\n  } else {\n    try {\n      msg.body = JSON.parse(msg.body.toString('utf8'));\n    } catch (ex) {\n      msg.body = {};\n    }\n  }\n\n  return msg;\n};\n\nvar composeResponse = function(server, msgId, route, msgBody) {\n  if(!msgId || !route || !msgBody) {\n    return null;\n  }\n  msgBody = encodeBody(server, route, msgBody);\n  return Message.encode(msgId, Message.TYPE_RESPONSE, 0, null, msgBody);\n};\n\nvar composePush = function(server, route, msgBody) {\n  if(!route || !msgBody){\n    return null;\n  }\n  msgBody = encodeBody(server, route, msgBody);\n  // encode use dictionary\n  var compressRoute = 0;\n  if(!!server.dictionary) {\n    var dict = server.dictionary.getDict();\n    if(!!server.connector.useDict && !!dict[route]) {\n      route = dict[route];\n      compressRoute = 1;\n    }\n  }\n  return Message.encode(0, Message.TYPE_PUSH, compressRoute, route, msgBody);\n};\n\nvar encodeBody = function(server, route, msgBody) {\n    // encode use protobuf\n  if(!!server.protobuf && !!server.protobuf.getProtos().server[route]) {\n    msgBody = server.protobuf.encode(route, msgBody);\n  } else if(!!server.decodeIO_protobuf && !!server.decodeIO_protobuf.check(Constants.RESERVED.SERVER, route)) {\n     msgBody = server.decodeIO_protobuf.encode(route, msgBody);\n  } else {\n    msgBody = new Buffer(JSON.stringify(msgBody), 'utf8');\n  }\n  return msgBody;\n};\n\nmodule.exports = {\n  encode: encode,\n  decode: decode\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/udpconnector.js":"var net = require('net');\nvar util = require('util');\nvar dgram = require(\"dgram\");\nvar utils = require('../util/utils');\nvar Constants = require('../util/constants');\nvar UdpSocket = require('./udpsocket');\nvar Kick = require('./commands/kick');\nvar Handshake = require('./commands/handshake');\nvar Heartbeat = require('./commands/heartbeat');\nvar protocol = require('pomelo-protocol');\nvar Package = protocol.Package;\nvar Message = protocol.Message;\nvar coder = require('./common/coder');\nvar EventEmitter = require('events').EventEmitter;\n\nvar curId = 1;\n\nvar Connector = function(port, host, opts) {\n  if (!(this instanceof Connector)) {\n    return new Connector(port, host, opts);\n  }\n\n  EventEmitter.call(this);\n  this.opts = opts || {};\n  this.type = opts.udpType || 'udp4';\n  this.handshake = new Handshake(opts);\n  if(!opts.heartbeat) {\n    opts.heartbeat = Constants.TIME.DEFAULT_UDP_HEARTBEAT_TIME;\n    opts.timeout = Constants.TIME.DEFAULT_UDP_HEARTBEAT_TIMEOUT;\n  }\n  this.heartbeat = new Heartbeat(utils.extends(opts, {disconnectOnTimeout: true}));\n  this.clients = {};\n  this.host = host;\n  this.port = port;\n};\n\nutil.inherits(Connector, EventEmitter);\n\nmodule.exports = Connector;\n\nConnector.prototype.start = function(cb) {\n  var self = this;\n  this.tcpServer = net.createServer();\n  this.socket = dgram.createSocket(this.type, function(msg, peer) {\n    var key = genKey(peer);\n    if(!self.clients[key]) {\n      var udpsocket = new UdpSocket(curId++, self.socket, peer);\n      self.clients[key] = udpsocket;\n\n      udpsocket.on('handshake',\n      self.handshake.handle.bind(self.handshake, udpsocket));\n\n      udpsocket.on('heartbeat',\n      self.heartbeat.handle.bind(self.heartbeat, udpsocket));\n\n      udpsocket.on('disconnect',\n      self.heartbeat.clear.bind(self.heartbeat, udpsocket.id));\n\n      udpsocket.on('disconnect', function() {\n        delete self.clients[genKey(udpsocket.peer)];\n      });\n\n      udpsocket.on('closing', Kick.handle.bind(null, udpsocket));\n\n      self.emit('connection', udpsocket);\n    }\n  });\n\n  this.socket.on('message', function(data, peer) {\n    var socket = self.clients[genKey(peer)];\n    if(!!socket) {\n      socket.emit('package', data);\n    }\n  });\n\n  this.socket.on('error', function(err) {\n    logger.error('udp socket encounters with error: %j', err.stack);\n    return;\n  });\n\n  this.socket.bind(this.port, this.host);\n  this.tcpServer.listen(this.port);\n  process.nextTick(cb);\n};\n\nConnector.decode = Connector.prototype.decode = coder.decode;\n\nConnector.encode = Connector.prototype.encode = coder.encode;\n\nConnector.prototype.stop = function(force, cb) {\n  this.socket.close();\n  process.nextTick(cb);\n};\n\nvar genKey = function(peer) {\n  return peer.address + \":\" + peer.port;\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/udpsocket.js":"var util = require('util');\nvar handler = require('./common/handler');\nvar protocol = require('pomelo-protocol');\nvar Package = protocol.Package;\nvar EventEmitter = require('events').EventEmitter;\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\n\nvar ST_INITED = 0;\nvar ST_WAIT_ACK = 1;\nvar ST_WORKING = 2;\nvar ST_CLOSED = 3;\n\nvar Socket = function(id, socket, peer) {\n\tEventEmitter.call(this);\n\t\n  this.id = id;\n\tthis.socket = socket;\n  this.peer = peer;\n\tthis.host = peer.address;\n\tthis.port = peer.port;\n\tthis.remoteAddress = {\n    ip: this.host,\n    port: this.port\n  };\n\n  var self = this;\n  this.on('package', function(pkg) {\n    if(!!pkg) {\n      pkg = Package.decode(pkg);\n      handler(self, pkg);\n    }\n  });\n\n  this.state = ST_INITED;\n};\n\nutil.inherits(Socket, EventEmitter);\n\nmodule.exports = Socket;\n\n/**\n * Send byte data package to client.\n *\n * @param  {Buffer} msg byte data\n */\nSocket.prototype.send = function(msg) {\n  if(this.state !== ST_WORKING) {\n    return;\n  }\n  if(msg instanceof String) {\n    msg = new Buffer(msg);\n  } else if(!(msg instanceof Buffer)) {\n    msg = new Buffer(JSON.stringify(msg));\n  }\n  this.sendRaw(Package.encode(Package.TYPE_DATA, msg));\n};\n\nSocket.prototype.sendRaw = function(msg) {\n\tthis.socket.send(msg, 0, msg.length, this.port, this.host, function(err, bytes) {\n    if(!!err)\t{\n      logger.error('send msg to remote with err: %j', err.stack);\n      return;\n    }\n  });\n};\n\nSocket.prototype.sendForce = function(msg) {\n  if(this.state === ST_CLOSED) {\n    return;\n  }\n  this.sendRaw(msg);\n};\n\nSocket.prototype.handshakeResponse = function(resp) {\n  if(this.state !== ST_INITED) {\n    return;\n  }\n  this.sendRaw(resp);\n  this.state = ST_WAIT_ACK;\n};\n\nSocket.prototype.sendBatch = function(msgs) {\n  if(this.state !== ST_WORKING) {\n    return;\n  }\n  var rs = [];\n  for(var i=0; i<msgs.length; i++) {\n    var src = Package.encode(Package.TYPE_DATA, msgs[i]);\n    rs.push(src);\n  }\n  this.sendRaw(Buffer.concat(rs));\n};\n\nSocket.prototype.disconnect = function() {\n  if(this.state === ST_CLOSED) {\n    return;\n  }\n  this.state = ST_CLOSED;\n  this.emit('disconnect', 'the connection is disconnected.');\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/mqttconnector.js":"var util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar mqtt = require('mqtt');\nvar constants = require('../util/constants');\nvar MQTTSocket = require('./mqttsocket');\nvar Adaptor = require('./mqtt/mqttadaptor');\nvar generate = require('./mqtt/generate');\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\n\nvar curId = 1;\n/**\n * Connector that manager low level connection and protocol bewteen server and client.\n * Develper can provide their own connector to switch the low level prototol, such as tcp or probuf.\n */\nvar Connector = function(port, host, opts) {\n  if (!(this instanceof Connector)) {\n    return new Connector(port, host, opts);\n  }\n\n  EventEmitter.call(this);\n  this.port = port;\n  this.host = host;\n  this.opts = opts || {};\n\n  this.adaptor = new Adaptor(this.opts);\n};\nutil.inherits(Connector, EventEmitter);\n\nmodule.exports = Connector;\n/**\n * Start connector to listen the specified port\n */\nConnector.prototype.start = function(cb) {\n  var self = this;\n  this.mqttServer = mqtt.createServer();\n  this.mqttServer.on('client', function(client) {\n\t\tclient.on('error', function(err) {\n\t\t\tclient.stream.destroy();\n\t\t});\n\t\t\n    client.on('close', function() {\n\t\t\tclient.stream.destroy();\n\t\t});\n\t\t\n    client.on('disconnect', function(packet) {\n\t\t\tclient.stream.destroy();\n\t\t});\n    \n    if(self.opts.disconnectOnTimeout) {\n      var timeout = self.opts.timeout * 1000 || constants.TIME.DEFAULT_MQTT_HEARTBEAT_TIMEOUT;\n      client.stream.setTimeout(timeout,function() {\n        client.emit('close');\n      });\n    }\n    \n    client.on('connect', function(packet) {\n      client.connack({returnCode: 0});\n      var mqttsocket = new MQTTSocket(curId++, client, self.adaptor);\n      self.emit('connection', mqttsocket);\n    });\n  });\n\n  this.mqttServer.listen(this.port);\n\n  process.nextTick(cb);\n};\n\nConnector.prototype.stop = function() {\n\tthis.mqttServer.close();\n\tprocess.exit(0);\n};\n\nvar composeResponse = function(msgId, route, msgBody) {\n  return {\n    id: msgId,\n    body: msgBody\n  };\n};\n\nvar composePush = function(route, msgBody) {\n  var msg = generate.publish(msgBody);\n  if(!msg) {\n    logger.error('invalid mqtt publish message: %j', msgBody);\n  }\n\n  return msg;\n};\n\nConnector.prototype.encode = function(reqId, route, msgBody) {\n\tif (!!reqId) {\n\t\treturn composeResponse(reqId, route, msgBody);\n\t} else {\n\t\treturn composePush(route, msgBody);\n\t}\n};\n\nConnector.prototype.close = function() {\n  this.mqttServer.close();\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/mqttsocket.js":"var util = require('util');\nvar EventEmitter = require('events').EventEmitter;\n\nvar ST_INITED = 1;\nvar ST_CLOSED = 2;\n\n/**\n * Socket class that wraps socket and websocket to provide unified interface for up level.\n */\nvar Socket = function(id, socket, adaptor) {\n  EventEmitter.call(this);\n  this.id = id;\n  this.socket = socket;\n  this.remoteAddress = {\n    ip: socket.stream.remoteAddress,\n    port: socket.stream.remotePort\n  };\n  this.adaptor = adaptor;\n\n  var self = this;\n\n  socket.on('close', this.emit.bind(this, 'disconnect'));\n  socket.on('error', this.emit.bind(this, 'disconnect'));\n  socket.on('disconnect', this.emit.bind(this, 'disconnect'));\n\n  socket.on('pingreq', function(packet) {\n    socket.pingresp();\n  });\n\n  socket.on('subscribe', this.adaptor.onSubscribe.bind(this.adaptor, this));\n\n  socket.on('publish', this.adaptor.onPublish.bind(this.adaptor, this));\n\n  this.state = ST_INITED;\n\n  // TODO: any other events?\n};\n\nutil.inherits(Socket, EventEmitter);\n\nmodule.exports = Socket;\n\nSocket.prototype.send = function(msg) {\n  if(this.state !== ST_INITED) {\n    return;\n  }\n  if(msg instanceof Buffer) {\n    // if encoded, send directly\n    this.socket.stream.write(msg);\n  } else {\n    this.adaptor.publish(this, msg);\n  }\n};\n\nSocket.prototype.sendBatch = function(msgs) {\n  for(var i = 0, l = msgs.length; i<l; i++) {\n    this.send(msgs[i]);\n  }\n};\n\nSocket.prototype.disconnect = function() {\n  if(this.state === ST_CLOSED) {\n    return;\n  }\n\n  this.state = ST_CLOSED;\n  this.socket.stream.destroy();\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/mqtt/mqttadaptor.js":"var Adaptor = function(opts) {\n  opts = opts || {};\n  this.subReqs = {};\n  this.publishRoute = opts.publishRoute;\n  this.subscribeRoute = opts.subscribeRoute;\n};\n\nmodule.exports = Adaptor;\n\nAdaptor.prototype.onPublish = function(client, packet) {\n  var route = this.publishRoute;\n\n  if(!route) {\n    throw new Error('unspecified publish route.');\n  }\n\n  var payload = packet.payload;\n  if(payload instanceof Buffer) {\n    payload = payload.toString('utf8');\n  }\n\n  var req = {\n    id: packet.messageId,\n    route: route,\n    body: packet\n  };\n\n  client.emit('message', req);\n\n  if(packet.qos === 1) {\n    client.socket.puback({messageId: packet.messageId});\n  }\n};\n\nAdaptor.prototype.onSubscribe = function(client, packet) {\n  var route = this.subscribeRoute;\n\n  if(!route) {\n    throw new Error('unspecified subscribe route.');\n  }\n\n  var req = {\n    id: packet.messageId,\n    route: route,\n    body: {\n      subscriptions: packet.subscriptions\n    }\n  };\n\n  this.subReqs[packet.messageId] = packet;\n\n  client.emit('message', req);\n};\n\nAdaptor.prototype.onPubAck = function(client, packet) {\n  var req = {\n    id: packet.messageId,\n    route: 'connector.mqttHandler.pubAck',\n    body: {\n      mid: packet.messageId\n    }\n  };\n\n  this.subReqs[packet.messageId] = packet;\n\n  client.emit('message', req);\n};\n\n/**\n * Publish message or subscription ack.\n *\n * if packet.id exist and this.subReqs[packet.id] exist then packet is a suback.\n * Subscription is request/response mode.\n * packet.id is pass from client in packet.messageId and record in Pomelo context and attached to the subscribe response packet.\n * packet.body is the context that returned by subscribe next callback.\n *\n * if packet.id not exist then packet is a publish message.\n *\n * otherwise packet is a illegal packet.\n */\nAdaptor.prototype.publish = function(client, packet) {\n  var mid = packet.id;\n  var subreq = this.subReqs[mid];\n  if(subreq) {\n    // is suback\n    client.socket.suback({messageId: mid, granted: packet.body});\n    delete this.subReqs[mid];\n    return;\n  }\n\n  client.socket.publish(packet.body);\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/mqtt/generate.js":"var protocol = require('./protocol');\nvar crypto = require('crypto');\n\n/* TODO: consider rewriting these functions using buffers instead\n * of arrays\n */\n\n/* Publish */\nmodule.exports.publish = function(opts) {\n  opts = opts || {};\n  var dup = opts.dup ? protocol.DUP_MASK : 0;\n  var qos = opts.qos || 0;\n  var retain = opts.retain ? protocol.RETAIN_MASK : 0;\n  var topic = opts.topic;\n  var payload = opts.payload || new Buffer(0);\n  var id = (typeof opts.messageId === 'undefined') ? randint() : opts.messageId;\n  var packet = {header: 0, payload: []};\n\n  /* Check required fields */\n  if (typeof topic !== 'string' || topic.length <= 0) return null;\n  /* if payload is a string, we'll convert it into a buffer */\n  if(typeof payload == 'string') {\n    payload = new Buffer(payload);\n  }\n  /* accepting only a buffer for payload */\n  if (!Buffer.isBuffer(payload)) return null;\n  if (typeof qos !== 'number' || qos < 0 || qos > 2) return null;\n  if (typeof id !== 'number' || id < 0 || id > 0xFFFF) return null;\n\n  /* Generate header */\n  packet.header = protocol.codes.publish << protocol.CMD_SHIFT | dup | qos << protocol.QOS_SHIFT | retain;\n\n  /* Topic name */\n  packet.payload = packet.payload.concat(gen_string(topic));\n\n  /* Message ID */\n  if (qos > 0) packet.payload = packet.payload.concat(gen_number(id));\n\n\n  var buf = new Buffer([packet.header]\n      .concat(gen_length(packet.payload.length + payload.length))\n      .concat(packet.payload));\n\n  return Buffer.concat([buf, payload]);\n};\n\n/* Requires length be a number > 0 */\nvar gen_length = function(length) {\n  if(typeof length !== \"number\") return null;\n  if(length < 0) return null;\n\n  var len = [];\n  var digit = 0;\n\n  do {\n    digit = length % 128 | 0;\n    length = length / 128 | 0;\n    if (length > 0) {\n        digit = digit | 0x80;\n    }\n    len.push(digit);\n  } while (length > 0);\n\n  return len;\n};\n\nvar gen_string = function(str, without_length) { /* based on code in (from http://farhadi.ir/downloads/utf8.js) */\n  if(arguments.length < 2) without_length = false;\n  if(typeof str !== \"string\") return null;\n  if(typeof without_length !== \"boolean\") return null;\n\n  var string = [];\n  var length = 0;\n  for(var i = 0; i < str.length; i++) {\n    var code = str.charCodeAt(i);\n    if (code < 128) {\n      string.push(code);                      ++length;\n\n    } else if (code < 2048) {\n      string.push(192 + ((code >> 6 )   )); ++length;\n      string.push(128 + ((code    ) & 63)); ++length;\n    } else if (code < 65536) {\n      string.push(224 + ((code >> 12)   )); ++length;\n      string.push(128 + ((code >> 6 ) & 63)); ++length;\n      string.push(128 + ((code    ) & 63)); ++length;\n    } else if (code < 2097152) {\n      string.push(240 + ((code >> 18)   )); ++length;\n      string.push(128 + ((code >> 12) & 63)); ++length;\n      string.push(128 + ((code >> 6 ) & 63)); ++length;\n      string.push(128 + ((code    ) & 63)); ++length;\n    } else {\n      throw new Error(\"Can't encode character with code \" + code);\n    }\n  }\n  return without_length ? string : gen_number(length).concat(string);\n};\n\nvar gen_number = function(num) {\n  var number = [num >> 8, num & 0x00FF];\n  return number;\n};\n\nvar randint = function() { return Math.floor(Math.random() * 0xFFFF); };","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/connectors/mqtt/protocol.js":"/* Protocol - protocol constants */\n\n/* Command code => mnemonic */\nmodule.exports.types = {\n  0: 'reserved',\n  1: 'connect',\n  2: 'connack',\n  3: 'publish',\n  4: 'puback',\n  5: 'pubrec',\n  6: 'pubrel',\n  7: 'pubcomp',\n  8: 'subscribe',\n  9: 'suback',\n  10: 'unsubscribe',\n  11: 'unsuback',\n  12: 'pingreq',\n  13: 'pingresp',\n  14: 'disconnect',\n  15: 'reserved'\n};\n\n/* Mnemonic => Command code */\nmodule.exports.codes = {};\nfor(var k in module.exports.types) {\n  var v = module.exports.types[k];\n  module.exports.codes[v] = k;\n}\n\n/* Header */\nmodule.exports.CMD_SHIFT = 4;\nmodule.exports.CMD_MASK = 0xF0;\nmodule.exports.DUP_MASK = 0x08;\nmodule.exports.QOS_MASK = 0x03;\nmodule.exports.QOS_SHIFT = 1;\nmodule.exports.RETAIN_MASK = 0x01;\n\n/* Length */\nmodule.exports.LENGTH_MASK = 0x7F;\nmodule.exports.LENGTH_FIN_MASK = 0x80;\n\n/* Connect */\nmodule.exports.USERNAME_MASK = 0x80;\nmodule.exports.PASSWORD_MASK = 0x40;\nmodule.exports.WILL_RETAIN_MASK = 0x20;\nmodule.exports.WILL_QOS_MASK = 0x18;\nmodule.exports.WILL_QOS_SHIFT = 3;\nmodule.exports.WILL_FLAG_MASK = 0x04;\nmodule.exports.CLEAN_SESSION_MASK = 0x02;\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/pushSchedulers/buffer.js":"var utils = require('../util/utils');\nvar DEFAULT_FLUSH_INTERVAL = 20;\n\nvar Service = function(app, opts) {\n  if (!(this instanceof Service)) {\n    return new Service(app, opts);\n  }\n\n  opts = opts || {};\n  this.app = app;\n  this.flushInterval = opts.flushInterval || DEFAULT_FLUSH_INTERVAL;\n  this.sessions = {};   // sid -> msg queue\n  this.tid = null;\n};\n\nmodule.exports = Service;\n\nService.prototype.start = function(cb) {\n  this.tid = setInterval(flush.bind(null, this), this.flushInterval);\n  process.nextTick(function() {\n    utils.invokeCallback(cb);\n  });\n};\n\nService.prototype.stop = function(force, cb) {\n  if(this.tid) {\n    clearInterval(this.tid);\n    this.tid = null;\n  }\n  process.nextTick(function() {\n    utils.invokeCallback(cb);\n  });\n};\n\nService.prototype.schedule = function(reqId, route, msg, recvs, opts, cb) {\n  opts = opts || {};\n  if(opts.type === 'broadcast') {\n    doBroadcast(this, msg, opts.userOptions);\n  } else {\n    doBatchPush(this, msg, recvs);\n  }\n\n  process.nextTick(function() {\n    utils.invokeCallback(cb);\n  });\n};\n\nvar doBroadcast = function(self, msg, opts) {\n  var channelService = self.app.get('channelService');\n  var sessionService = self.app.get('sessionService');\n\n  if(opts.binded) {\n    sessionService.forEachBindedSession(function(session) {\n      if(channelService.broadcastFilter &&\n         !channelService.broadcastFilter(session, msg, opts.filterParam)) {\n        return;\n      }\n\n      enqueue(self, session, msg);\n    });\n  } else {\n    sessionService.forEachSession(function(session) {\n      if(channelService.broadcastFilter &&\n          !channelService.broadcastFilter(session, msg, opts.filterParam)) {\n        return;\n      }\n\n      enqueue(self, session, msg);\n    });\n  }\n};\n\nvar doBatchPush = function(self, msg, recvs) {\n  var sessionService = self.app.get('sessionService');\n  var session;\n  for(var i=0, l=recvs.length; i<l; i++) {\n    session = sessionService.get(recvs[i]);\n    if(session) {\n      enqueue(self, session, msg);\n    }\n  }\n};\n\nvar enqueue = function(self, session, msg) {\n  var queue = self.sessions[session.id];\n  if(!queue) {\n    queue = self.sessions[session.id] = [];\n    session.once('closed', onClose.bind(null, self));\n  }\n\n  queue.push(msg);\n};\n\nvar onClose = function(self, session) {\n  delete self.sessions[session.id];\n};\n\nvar flush = function(self) {\n  var sessionService = self.app.get('sessionService');\n  var queue, session;\n  for(var sid in self.sessions) {\n    session = sessionService.get(sid);\n    if(!session) {\n      continue;\n    }\n\n    queue = self.sessions[sid];\n    if(!queue || queue.length === 0) {\n      continue;\n    }\n\n    session.sendBatch(queue);\n    self.sessions[sid] = [];\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/filters/rpc/toobusy.js":"/**\n * Filter for rpc log.\n * Reject rpc request when toobusy\n */\nvar rpcLogger = require('pomelo-logger').getLogger('rpc-log', __filename);\nvar toobusy = null;\n\nvar DEFAULT_MAXLAG = 70;\n\nmodule.exports = function(maxLag) {\n  return new Filter(maxLag || DEFAULT_MAXLAG);\n};\n\nvar Filter = function(maxLag) {\n  try {\n    toobusy = require('toobusy');\n  } catch(e) {\n  }\n  if(!!toobusy) {\n    toobusy.maxLag(maxLag);\n  }\n};\n\nFilter.prototype.name = 'toobusy';\n\n/**\n * Before filter for rpc\n */\n Filter.prototype.before = function(serverId, msg, opts, next) {\n  opts = opts||{};\n  if (!!toobusy && toobusy()) {\n    rpcLogger.warn('Server too busy for rpc request, serverId:' + serverId + ' msg: ' + msg);\n    var err =  new Error('Backend server ' + serverId + ' is too busy now!');\n    err.code = 500;\n    next(err);\n  } else {\n    next();\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/gruntfile.js":"'use strict';\n\nmodule.exports = function(grunt) {\n\n  grunt.loadNpmTasks('grunt-mocha-test');\n  grunt.loadNpmTasks('grunt-contrib-clean');\n  grunt.loadNpmTasks('grunt-contrib-jshint');\n\n  var src = ['test/manager/taskManager.js', 'test/filters/*.js', \n  'test/remote/*.js', 'test/service/*.js', 'test/modules/*.js', 'test/util/*.js', 'test/*.js'];\n\n  // Project configuration.\n  grunt.initConfig({\n    mochaTest: {\n       test: {\n        options: {\n          reporter: 'spec',\n          timeout: 5000,\n          require: 'coverage/blanket'\n        },\n        src: src\n      },\n      coverage: {\n        options: {\n          reporter: 'html-cov',\n          quiet: true,\n          captureFile: 'coverage.html'\n        },\n        src: src\n      }\n    },\n    clean: {\n      \"coverage.html\" : {\n        src: ['coverage.html']\n      }\n    },\n    jshint: {\n      all: ['lib/*']\n    }\n  });\n\n  // Default task.\n  grunt.registerTask('default', ['clean', 'mochaTest', 'jshint']);\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/master/watchdog.js":"var logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar utils = require('../util/utils');\nvar Constants = require('../util/constants');\nvar countDownLatch = require('../util/countDownLatch');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nvar Watchdog = function(app, service) {\n  EventEmitter.call(this);\n\n  this.app = app;\n  this.service = service;\n  this.isStarted = false;\n  this.count = utils.size(app.getServersFromConfig());\n\n  this.servers = {};\n  this.listeners = {};\n};\nutil.inherits(Watchdog, EventEmitter);\n\nmodule.exports = Watchdog;\n\nWatchdog.prototype.addServer = function(server) {\n  if(!server) {\n    return;\n  }\n  this.servers[server.id] = server;\n  this.notify({action: 'addServer', server: server});\n};\n\nWatchdog.prototype.removeServer = function(id) {\n  if(!id) {\n    return;\n  }\n  this.unsubscribe(id);\n  delete this.servers[id];\n  this.notify({action: 'removeServer', id: id});\n};\n\nWatchdog.prototype.reconnectServer = function(server) {\n  var self = this;\n  if(!server) {\n    return;\n  }\n  if(!this.servers[server.id]) {\n    this.servers[server.id] = server;\n  }\n  //replace server in reconnect server\n  this.notifyById(server.id, {action: 'replaceServer', servers: self.servers});\n  // notify other server to add server\n  this.notify({action: 'addServer', server: server});\n  // add server in listener\n  this.subscribe(server.id);\n};\n\nWatchdog.prototype.subscribe = function(id) {\n  this.listeners[id] = 1;\n};\n\nWatchdog.prototype.unsubscribe = function(id) {\n  delete this.listeners[id];\n};\n\nWatchdog.prototype.query = function() {\n  return this.servers;\n};\n\nWatchdog.prototype.record = function(id) {\n  if(!this.isStarted && --this.count < 0) {\n    var usedTime = Date.now() - this.app.startTime;\n    logger.info('all servers startup in %s ms', usedTime);\n    this.notify({action: 'startOver'});\n    this.isStarted = true;\n  }\n};\n\nWatchdog.prototype.notifyById = function(id, msg) {\n  this.service.agent.request(id, Constants.KEYWORDS.MONITOR_WATCHER, msg, function(signal) {\n    if(signal !== Constants.SIGNAL.OK) {\n      logger.error('master watchdog fail to notify to monitor, id: %s, msg: %j', id, msg);\n    } else {\n      logger.debug('master watchdog notify to monitor success, id: %s, msg: %j', id, msg);\n    }\n  });\n};\n\nWatchdog.prototype.notify = function(msg) {\n  var listeners = this.listeners;\n  var success = true;\n  var fails = [];\n  var timeouts = [];\n  var requests = {};\n  var count = utils.size(listeners);\n  if(count === 0) {\n    logger.warn('master watchdog listeners is none, msg: %j', msg);\n    return;\n  }\n  var latch = countDownLatch.createCountDownLatch(count, {timeout: Constants.TIME.TIME_WAIT_COUNTDOWN}, function(isTimeout) {\n    if(!!isTimeout) {\n      for(var key in requests) {\n        if(!requests[key])  {\n          timeouts.push(key);\n        }\n      }\n      logger.error('master watchdog request timeout message: %j, timeouts: %j, fails: %j', msg, timeouts, fails);\n    }\n    if(!success) {\n      logger.error('master watchdog request fail message: %j, fails: %j', msg, fails);\n    }\n  });\n\n  var moduleRequest = function(self, id) {\n    return (function() {\n      self.service.agent.request(id, Constants.KEYWORDS.MONITOR_WATCHER, msg, function(signal) {\n        if(signal !== Constants.SIGNAL.OK) {\n          fails.push(id);\n          success = false;\n        }\n        requests[id] = 1;\n        latch.done();\n      });\n    })();\n  };\n\n  for(var id in listeners) {\n    requests[id] = 0;\n    moduleRequest(this, id);\n  }\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/modules/console.js":"/*!\n * Pomelo -- consoleModule serverStop stop/kill\n * Copyright(c) 2012 fantasyni <fantasyni@163.com>\n * MIT Licensed\n */\nvar logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar countDownLatch = require('../util/countDownLatch');\nvar utils = require('../util/utils');\nvar Constants = require('../util/constants');\nvar starter = require('../master/starter');\nvar exec = require('child_process').exec;\n\nmodule.exports = function(opts) {\n  return new Module(opts);\n};\n\nmodule.exports.moduleId = '__console__';\n\nvar Module = function(opts) {\n  opts = opts || {};\n  this.app = opts.app;\n  this.starter = opts.starter;\n};\n\nModule.prototype.monitorHandler = function(agent, msg, cb) {\n  var serverId = agent.id;\n  switch(msg.signal) {\n    case 'stop':\n      if(agent.type === Constants.RESERVED.MASTER) {\n        return;\n      }\n      this.app.stop(true);\n      break;\n    case 'list':\n      var serverType = agent.type;\n      var pid = process.pid;\n      var heapUsed = (process.memoryUsage().heapUsed/(1024 * 1024)).toFixed(2);\n      var rss = (process.memoryUsage().rss/(1024 * 1024)).toFixed(2);\n      var heapTotal = (process.memoryUsage().heapTotal/(1024 * 1024)).toFixed(2);\n      var uptime = (process.uptime()/60).toFixed(2);\n      utils.invokeCallback(cb, {\n        serverId: serverId,\n        body: {serverId:serverId, serverType: serverType, pid:pid, rss: rss, heapTotal: heapTotal, heapUsed:heapUsed, uptime:uptime}\n      });\n      break;\n    case 'kill':\n      utils.invokeCallback(cb, serverId);\n      if (agent.type !== 'master') {\n        setTimeout(function() {\n          process.exit(-1);\n        }, Constants.TIME.TIME_WAIT_MONITOR_KILL);\n      }\n      break;\n    case 'addCron':\n      this.app.addCrons([msg.cron]);\n      break;\n    case 'removeCron':\n      this.app.removeCrons([msg.cron]);\n      break;\n    case 'blacklist':\n      if(this.app.isFrontend()) {\n        var connector = this.app.components.__connector__;\n        connector.blacklist = connector.blacklist.concat(msg.blacklist);\n      }\n      break;\n    case 'restart':\n      if(agent.type === Constants.RESERVED.MASTER) {\n        return;\n      }\n      var self = this;\n      var server = this.app.get(Constants.RESERVED.CURRENT_SERVER);\n      utils.invokeCallback(cb, server);\n      process.nextTick(function() {\n        self.app.stop(true);\n      });\n      break;\n    default:\n      logger.error('receive error signal: %j', msg);\n      break;\n  }\n};\n\nModule.prototype.clientHandler = function(agent, msg, cb) {\n  var app = this.app;\n  switch(msg.signal) {\n    case 'kill':\n      kill(app, agent, msg, cb);\n      break;\n    case 'stop':\n      stop(app, agent, msg, cb);\n      break;\n    case 'list':\n      list(agent, msg, cb);\n      break;\n    case 'add':\n      add(app, msg, cb);\n      break;\n    case 'addCron':\n      addCron(app, agent, msg, cb);\n      break;\n    case 'removeCron':\n      removeCron(app, agent, msg, cb);\n      break;\n    case 'blacklist':\n      blacklist(agent, msg, cb);\n      break;\n    case 'restart':\n      restart(app, agent, msg, cb);\n      break;\n    default:\n      utils.invokeCallback(cb, new Error('The command cannot be recognized, please check.'), null);\n      break;\n  }\n};\n\nvar kill = function(app, agent, msg, cb) {\n  var sid, record;\n  var serverIds = [];\n  var count = utils.size(agent.idMap);\n  var latch = countDownLatch.createCountDownLatch(count, {timeout: Constants.TIME.TIME_WAIT_MASTER_KILL}, function(isTimeout) {\n    if (!isTimeout) {\n      utils.invokeCallback(cb, null, {code: 'ok'});\n    } else {\n      utils.invokeCallback(cb, null, {code: 'remained', serverIds: serverIds});\n    }\n    setTimeout(function() {\n      process.exit(-1);\n    }, Constants.TIME.TIME_WAIT_MONITOR_KILL);\n  });\n\n  var agentRequestCallback = function(msg) {\n      for (var i = 0; i < serverIds.length; ++i) {\n        if (serverIds[i] === msg) {\n          serverIds.splice(i,1);\n          latch.done();\n          break;\n        }\n      }\n  };\n\n  for(sid in agent.idMap) {\n    record = agent.idMap[sid];\n    serverIds.push(record.id);\n    agent.request(record.id, module.exports.moduleId, { signal: msg.signal }, agentRequestCallback);\n  }\n};\n\nvar stop = function(app, agent, msg, cb) {\n  var serverIds = msg.ids;\n  if(!!serverIds.length) {\n    var servers = app.getServers();\n    app.set(Constants.RESERVED.STOP_SERVERS, serverIds);\n    for(var i=0; i<serverIds.length; i++) {\n      var serverId = serverIds[i];\n      if(!servers[serverId]) {\n        utils.invokeCallback(cb, new Error('Cannot find the server to stop.'), null);\n      } else {\n        agent.notifyById(serverId, module.exports.moduleId, { signal: msg.signal });\n      }\n    }\n    utils.invokeCallback(cb, null, { status: \"part\" });\n  } else {\n    var servers = app.getServers();\n    var serverIds = [];\n    for(var i in servers){\n        serverIds.push(i)\n    }\n    app.set(Constants.RESERVED.STOP_SERVERS, serverIds);\n    agent.notifyAll(module.exports.moduleId, { signal: msg.signal });\n    setTimeout(function() {\n      app.stop(true);\n      utils.invokeCallback(cb, null, { status: \"all\" });\n    }, Constants.TIME.TIME_WAIT_STOP);\n  }\n};\n\nvar restart = function(app, agent, msg, cb) {\n  var successFlag;\n  var successIds = [];\n  var serverIds = msg.ids;\n  var type = msg.type;\n  var servers;\n  if(!serverIds.length && !!type) {\n    servers = app.getServersByType(type);\n    if(!servers) {\n      utils.invokeCallback(cb, new Error('restart servers with unknown server type: ' + type));\n      return;\n    }\n    for(var i=0; i<servers.length; i++) {\n      serverIds.push(servers[i].id);\n    }\n  } else if(!serverIds.length) {\n    servers = app.getServers();\n    for(var key in servers) {\n      serverIds.push(key);\n    }\n  }  \n  var count = serverIds.length;\n  var latch = countDownLatch.createCountDownLatch(count, {timeout: Constants.TIME.TIME_WAIT_COUNTDOWN}, function() {\n    if(!successFlag) {\n      utils.invokeCallback(cb, new Error('all servers start failed.'));\n      return;\n    }\n    utils.invokeCallback(cb, null, utils.arrayDiff(serverIds, successIds));\n  });\n\n  var request = function(id) {\n    return (function() {\n      agent.request(id, module.exports.moduleId, { signal: msg.signal }, function(msg) {\n        if(!utils.size(msg)) {\n          latch.done();\n          return;\n        }\n        setTimeout(function() {\n         runServer(app, msg, function(err, status) {\n          if(!!err) {\n            logger.error('restart ' + id + ' failed.');\n          } else {\n            successIds.push(id);\n            successFlag = true;\n          }\n          latch.done();\n        });\n       }, Constants.TIME.TIME_WAIT_RESTART);\n      });\n    })();\n  };\n\n  for(var j=0; j<serverIds.length; j++) {\n    request(serverIds[j]);\n  }\n};\n\nvar list = function(agent, msg, cb) {\n  var sid, record;\n  var serverInfo = {};\n  var count = utils.size(agent.idMap);\n  var latch = countDownLatch.createCountDownLatch(count, {timeout: Constants.TIME.TIME_WAIT_COUNTDOWN}, function() {\n    utils.invokeCallback(cb, null, { msg: serverInfo });\n  });\n\n  var callback = function(msg) {\n    serverInfo[msg.serverId] = msg.body;\n    latch.done();\n  };\n  for(sid in agent.idMap) {\n    record = agent.idMap[sid];\n    agent.request(record.id, module.exports.moduleId, { signal: msg.signal }, callback);\n  }\n};\n\nvar add = function(app, msg, cb) {\n  if(checkCluster(msg)) {\n    startCluster(app, msg, cb);\n  } else {\n    startServer(app, msg, cb);\n  }\n  reset(ServerInfo);\n};\n\nvar addCron = function(app, agent, msg, cb) {\n  var cron = parseArgs(msg, CronInfo, cb);\n  sendCronInfo(cron, agent, msg, CronInfo, cb);\n};\n\nvar removeCron = function(app, agent, msg, cb) {\n  var cron = parseArgs(msg, RemoveCron, cb);\n  sendCronInfo(cron, agent, msg, RemoveCron, cb);\n};\n\nvar blacklist = function(agent, msg, cb) {\n  var ips = msg.args;\n  for(var i=0; i<ips.length; i++) {\n    if(!(new RegExp(/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)/g).test(ips[i]))) {\n      utils.invokeCallback(cb, new Error('blacklist ip: ' + ips[i] + ' is error format.'), null);\n      return;\n    }\n  }\n  agent.notifyAll(module.exports.moduleId, { signal: msg.signal, blacklist: msg.args });\n  process.nextTick(function() {\n    cb(null, { status: \"ok\" });\n  });\n};\n\nvar checkPort = function(server, cb) {\n  if (!server.port && !server.clientPort) {\n    utils.invokeCallback(cb, 'leisure');\n    return;\n  }\n\n  var p = server.port || server.clientPort;\n  var host = server.host;\n  var cmd = 'netstat -tln | grep ';\n  if (!utils.isLocal(host)) {\n    cmd = 'ssh ' + host + ' ' + cmd;\n  }\n\n  exec(cmd + p, function(err, stdout, stderr) {\n    if (stdout || stderr) {\n      utils.invokeCallback(cb, 'busy');\n    } else {\n      p = server.clientPort;\n      exec(cmd + p, function(err, stdout, stderr) {\n        if (stdout || stderr) {\n          utils.invokeCallback(cb, 'busy');\n        } else {\n          utils.invokeCallback(cb, 'leisure');\n        }\n      });\n    }\n  });\n};\n\nvar parseArgs = function(msg, info, cb) {\n  var rs = {};\n  var args = msg.args;\n  for(var i =0; i<args.length; i++) {\n    if(args[i].indexOf('=') < 0) {\n      cb(new Error('Error server parameters format.'), null);\n      return;\n    }\n    var pairs = args[i].split('=');\n    var key = pairs[0];\n    if(!!info[key]) {\n      info[key] = 1;\n    }\n    rs[pairs[0]] = pairs[1];\n  }\n  return rs;\n};\n\nvar sendCronInfo = function(cron, agent, msg, info, cb) {\n  if(isReady(info) && (cron.serverId || cron.serverType)) {\n    if(!!cron.serverId) {\n      agent.notifyById(cron.serverId, module.exports.moduleId, { signal: msg.signal, cron: cron });\n    } else {\n      agent.notifyByType(cron.serverType, module.exports.moduleId, { signal: msg.signal, cron: cron });\n    }\n    process.nextTick(function() {\n      cb(null, { status: \"ok\" });\n    });\n  } else {\n    cb(new Error('Miss necessary server parameters.'), null);\n  }\n  reset(info);\n};\n\nvar startServer = function(app, msg, cb) {\n  var server = parseArgs(msg, ServerInfo, cb);\n  if(isReady(ServerInfo)) {\n    runServer(app, server, cb);\n  } else {\n    cb(new Error('Miss necessary server parameters.'), null);\n  }\n};\n\nvar runServer = function(app, server, cb) {\n  checkPort(server, function(status) {\n    if(status === 'busy') {\n      utils.invokeCallback(cb, new Error('Port occupied already, check your server to add.'));\n    } else {\n      starter.run(app, server, function(err) {\n        if(err) {\n          utils.invokeCallback(cb, new Error(err), null);\n          return;\n        }\n      });\n      process.nextTick(function() {\n        utils.invokeCallback(cb, null, { status: \"ok\" });\n      });\n    }\n  });\n};\n\nvar startCluster = function(app, msg, cb) {\n  var serverMap = {};\n  var fails = [];\n  var successFlag;\n  var serverInfo = parseArgs(msg, ClusterInfo, cb);\n  utils.loadCluster(app, serverInfo, serverMap);\n  var count = utils.size(serverMap);\n  var latch = countDownLatch.createCountDownLatch(count, function() {\n    if(!successFlag) {\n      utils.invokeCallback(cb, new Error('all servers start failed.'));\n      return;\n    }\n    utils.invokeCallback(cb, null, fails);\n  });\n\n  var start = function(server) {\n    return (function() {\n      checkPort(server, function(status) {\n        if(status === 'busy') {\n          fails.push(server);\n          latch.done();\n        } else {\n          starter.run(app, server, function(err) {\n            if(err) {\n              fails.push(server);\n              latch.done();\n            }\n          });\n          process.nextTick(function() {\n            successFlag = true;\n            latch.done();\n          });\n        }\n      });\n    })();\n  };\n  for(var key in serverMap) {\n    var server = serverMap[key];\n    start(server);\n  }\n};\n\nvar checkCluster = function(msg) {\n  var flag = false;\n  var args = msg.args;\n  for(var i=0; i < args.length; i++) {\n    if(utils.startsWith(args[i], Constants.RESERVED.CLUSTER_COUNT)) {\n      flag = true;\n    }\n  }\n  return flag;\n};\n\nvar isReady = function(info) {\n  for(var key in info) {\n    if(info[key]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nvar reset = function(info) {\n  for(var key in info) {\n    info[key] = 0;\n  }\n};\n\nvar ServerInfo = {\n  host: 0,\n  port: 0,\n  id:   0,\n  serverType: 0\n};\n\nvar CronInfo = {\n  id: 0,\n  action: 0,\n  time: 0\n};\n\nvar RemoveCron = {\n  id: 0\n};\n\nvar ClusterInfo = {\n  host: 0,\n  port: 0,\n  clusterCount: 0\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/modules/masterwatcher.js":"var logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar utils = require('../util/utils');\nvar Constants = require('../util/constants');\nvar MasterWatchdog = require('../master/watchdog');\n\nmodule.exports = function(opts, consoleService) {\n  return new Module(opts, consoleService);\n};\n\nmodule.exports.moduleId = Constants.KEYWORDS.MASTER_WATCHER;\n\nvar Module = function(opts, consoleService) {\n  this.app = opts.app;\n  this.service = consoleService;\n  this.id = this.app.getServerId();\n\n  this.watchdog = new MasterWatchdog(this.app, this.service);\n  this.service.on('register', onServerAdd.bind(null, this));\n  this.service.on('disconnect', onServerLeave.bind(null, this));\n  this.service.on('reconnect', onServerReconnect.bind(null, this));\n};\n\n// ----------------- bind methods -------------------------\n\nvar onServerAdd = function(module, record) {\n  logger.debug('masterwatcher receive add server event, with server: %j', record);\n  if(!record || record.type === 'client' || !record.serverType) {\n    return;\n  }\n  module.watchdog.addServer(record);\n};\n\nvar onServerReconnect = function(module, record) {\n  logger.debug('masterwatcher receive reconnect server event, with server: %j', record);\n  if(!record || record.type === 'client' || !record.serverType) {\n    logger.warn('onServerReconnect receive wrong message: %j', record);\n    return;\n  }\n  module.watchdog.reconnectServer(record);\n};\n\nvar onServerLeave = function(module, id, type) {\n  logger.debug('masterwatcher receive remove server event, with server: %s, type: %s', id, type);\n  if(!id) {\n    logger.warn('onServerLeave receive server id is empty.');\n    return;\n  }\n  if(type !== 'client') {\n    module.watchdog.removeServer(id);\n  }\n};\n\n// ----------------- module methods -------------------------\n\nModule.prototype.start = function(cb) {\n  utils.invokeCallback(cb);\n};\n\nModule.prototype.masterHandler = function(agent, msg, cb) {\n  if(!msg) {\n    logger.warn('masterwatcher receive empty message.');\n    return;\n  }\n  var func = masterMethods[msg.action];\n  if(!func) {\n    logger.info('masterwatcher unknown action: %j', msg.action);\n    return;\n  }\n  func(this, agent, msg, cb);\n};\n\n// ----------------- monitor request methods -------------------------\n\nvar subscribe = function(module, agent, msg, cb) {\n  if(!msg) {\n    utils.invokeCallback(cb, new Error('masterwatcher subscribe empty message.'));\n    return;\n  }\n\n  module.watchdog.subscribe(msg.id);\n  utils.invokeCallback(cb, null, module.watchdog.query());\n};\n\nvar unsubscribe = function(module, agent, msg, cb) {\n  if(!msg) {\n    utils.invokeCallback(cb, new Error('masterwatcher unsubscribe empty message.'));\n    return;\n  }\n  module.watchdog.unsubscribe(msg.id);\n  utils.invokeCallback(cb);\n};\n\nvar query = function(module, agent, msg, cb) {\n  utils.invokeCallback(cb, null, module.watchdog.query());\n};\n\nvar record = function(module, agent, msg) {\n  if(!msg) {\n    utils.invokeCallback(cb, new Error('masterwatcher record empty message.'));\n    return;\n  }\n  module.watchdog.record(msg.id);\n};\n\nvar masterMethods = {\n  'subscribe': subscribe,\n  'unsubscribe': unsubscribe,\n  'query': query,\n  'record': record\n};","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/lib/modules/monitorwatcher.js":"var logger = require('pomelo-logger').getLogger('pomelo', __filename);\nvar utils = require('../util/utils');\nvar events = require('../util/events');\nvar Constants = require('../util/constants');\nvar util = require('util');\n\nmodule.exports = function(opts, consoleService) {\n  return new Module(opts, consoleService);\n};\n\nmodule.exports.moduleId = Constants.KEYWORDS.MONITOR_WATCHER;\n\nvar Module = function(opts, consoleService) {\n  this.app = opts.app;\n  this.service = consoleService;\n  this.id = this.app.getServerId();\n\n  this.app.event.on(events.START_SERVER, finishStart.bind(null, this));\n};\n\nModule.prototype.start = function(cb) {\n  subscribeRequest(this, this.service.agent, this.id, cb);\n};\n\nModule.prototype.monitorHandler = function(agent, msg, cb) {\n  if(!msg || !msg.action) {\n    return;\n  }\n  var func = monitorMethods[msg.action];\n  if(!func) {\n    logger.info('monitorwatcher unknown action: %j', msg.action);\n    return;\n  }\n  func(this, agent, msg, cb);\n};\n\n// ----------------- monitor start method -------------------------\n\nvar subscribeRequest = function(self, agent, id, cb) {\n  var msg = {action: 'subscribe', id: id};\n  agent.request(Constants.KEYWORDS.MASTER_WATCHER, msg, function(err, servers) {\n    if(err) {\n      logger.error('subscribeRequest request to master with error: %j', err.stack);\n      utils.invokeCallback(cb, err);\n    }\n    var res = [];\n    for(var id in servers) {\n      res.push(servers[id]);\n    }\n    addServers(self, res);\n    utils.invokeCallback(cb);\n  });\n};\n\n// ----------------- monitor request methods -------------------------\n\nvar addServer = function(self, agent, msg, cb) {\n  logger.debug('[%s] receive addServer signal: %j', self.app.serverId, msg);\n  if(!msg || !msg.server) {\n    logger.warn('monitorwatcher addServer receive empty message: %j', msg);\n    utils.invokeCallback(cb, Constants.SIGNAL.FAIL);\n    return;\n  }\n  addServers(self, [msg.server]);\n  utils.invokeCallback(cb, Constants.SIGNAL.OK);\n};\n\nvar removeServer = function(self, agent, msg, cb) {\n  logger.debug('%s receive removeServer signal: %j', self.app.serverId, msg);\n  if(!msg || !msg.id) {\n    logger.warn('monitorwatcher removeServer receive empty message: %j', msg);\n    utils.invokeCallback(cb, Constants.SIGNAL.FAIL);\n    return;\n  }\n  removeServers(self, [msg.id]);\n  utils.invokeCallback(cb, Constants.SIGNAL.OK);\n};\n\nvar replaceServer = function(self, agent, msg, cb) {\n  logger.debug('%s receive replaceServer signal: %j', self.app.serverId, msg);\n  if(!msg || !msg.servers) {\n    logger.warn('monitorwatcher replaceServer receive empty message: %j', msg);\n    utils.invokeCallback(cb, Constants.SIGNAL.FAIL);\n    return;\n  }\n  replaceServers(self, msg.servers);\n  utils.invokeCallback(cb, Constants.SIGNAL.OK);\n};\n\nvar startOver = function(self, agent, msg, cb) {\n  var fun = self.app.lifecycleCbs[Constants.LIFECYCLE.AFTER_STARTALL];\n  if(!!fun) {\n    fun.call(null, self.app);\n  }\n  self.app.event.emit(events.START_ALL);\n  utils.invokeCallback(cb, Constants.SIGNAL.OK);\n};\n\n// ----------------- common methods -------------------------\n\nvar addServers = function(self, servers) {\n  if(!servers || !servers.length) {\n    return;\n  }\n  self.app.addServers(servers);\n};\n\nvar removeServers = function(self, ids) {\n  if(!ids || !ids.length) {\n    return;\n  }\n  self.app.removeServers(ids);\n};\n\nvar replaceServers = function(self, servers) {\n  self.app.replaceServers(servers);\n};\n\n// ----------------- bind methods -------------------------\n\nvar finishStart = function(self, id) {\n  var msg = {action: 'record', id: id};\n  self.service.agent.notify(Constants.KEYWORDS.MASTER_WATCHER, msg);\n};\n\nvar monitorMethods = {\n  'addServer': addServer,\n  'removeServer': removeServer,\n  'replaceServer': replaceServer,\n  'startOver': startOver\n};\n","/home/travis/build/npmtest/node-npmtest-pomelo/node_modules/pomelo/template/game-server/app.js":"var pomelo = require('pomelo');\n\n/**\n * Init app for client.\n */\nvar app = pomelo.createApp();\napp.set('name', '$');\n\n// app configuration\napp.configure('production|development', 'connector', function(){\n  app.set('connectorConfig',\n    {\n      connector : pomelo.connectors.hybridconnector,\n      heartbeat : 3,\n      useDict : true,\n      useProtobuf : true\n    });\n});\n\n// start app\napp.start();\n\nprocess.on('uncaughtException', function (err) {\n  console.error(' Caught exception: ' + err.stack);\n});\n"}